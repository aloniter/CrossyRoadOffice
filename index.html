<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Office Crossing Challenge - Firebase Leaderboard!</title>
    <style>
        /* Styles remain the same */
        body { margin: 0; overflow: hidden; font-family: sans-serif; background: linear-gradient(to bottom, #87CEEB, #B0E0E6); color: #333; height: 100vh; }
        canvas { display: block; }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; flex-direction: column; background-color: rgba(0, 0, 0, 0.75); color: white; z-index: 100; padding: 20px; box-sizing: border-box; text-align: center; }
        .hidden { display: none; }
        .overlay-content { background-color: rgba(40, 60, 80, 0.9); padding: 30px 40px; border-radius: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.4); max-width: 90%; width: 450px; }
        .overlay h2 { margin-top: 0; margin-bottom: 20px; border-bottom: 1px solid rgba(255,255,255,0.5); padding-bottom: 10px; color: #FFD700; }
        .overlay button { display: block; width: 80%; margin: 15px auto; padding: 12px 20px; font-size: 18px; cursor: pointer; border: none; border-radius: 8px; background-color: #4682B4; color: white; transition: background-color 0.3s, transform 0.1s; box-shadow: 0 4px 6px rgba(0,0,0,0.2); }
        .overlay button:hover { background-color: #5A9BD5; }
        .overlay button:active { transform: scale(0.95); background-color: #41729F; }
        #mainMenu .character-selection { margin-bottom: 20px; padding: 10px; background-color: rgba(255,255,255,0.1); border-radius: 8px; max-height: 250px; overflow-y: auto; /* Added scroll for many characters */ }
        #mainMenu .character-selection h3 { margin-top: 0; margin-bottom: 10px; font-size: 16px; }
        #mainMenu .char-button { display: inline-block; width: auto; padding: 8px 15px; margin: 5px; font-size: 14px; border: 2px solid transparent; background-color: #6c757d; }
        #mainMenu .char-button.selected { border-color: #FFD700; background-color: #4682B4; }
        #scoreboardScreen ol { margin: 0 0 15px 0; padding: 0 0 0 25px; list-style-position: outside; max-height: 150px; overflow-y: auto; }
        #scoreboardScreen li { margin-bottom: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 16px; border-bottom: 1px dotted rgba(255, 255, 255, 0.2); padding-bottom: 4px; }
        #scoreboardScreen li:last-child { border-bottom: none; }
        #scoreboardScreen li span { display: inline-block; }
        #scoreboardScreen li .score { float: right; font-weight: bold; margin-left: 15px; }
        #scoreboardScreen .no-scores { text-align: center; font-style: italic; color: #ccc; margin-top: 10px;}
        #info { position: absolute; top: 10px; left: 10px; width: auto; text-align: left; z-index: 50; display: block; color: #000080; font-size: 24px; font-weight: bold; text-shadow: 1px 1px 1px #FFFFFF; background-color: rgba(255, 255, 255, 0.6); padding: 5px 10px; border-radius: 5px; }
        #gameOver { z-index: 101; }
        #gameOverReason { font-size: 24px; margin-bottom: 15px; font-style: italic; color: #ffdddd; }
    </style>

    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-database-compat.js"></script>

</head>
<body>
    <div id="info" class="hidden">Score: 0</div>
    <div id="mainMenu" class="overlay"> <div class="overlay-content"> <h2>Office Crossing Challenge</h2> <div class="character-selection"> <h3>Select Character</h3> <div id="characterButtons"></div> </div> <button id="startGameButton">Start Game</button> <button id="viewScoresButton">High Scores</button> </div> </div>
    <div id="scoreboardScreen" class="overlay hidden"> <div class="overlay-content"> <h2>High Scores (Top 3)</h2> <ol id="scoreList"></ol> <div id="noScoresMessage" class="no-scores" style="display: none;">Loading scores or none yet...</div> <button id="backToMenuButton">Back to Menu</button> </div> </div>
    <div id="gameOver" class="overlay hidden"> <div class="overlay-content"> <h2 id="gameOverReason">Deadline Missed!</h2> Final Score: <span id="finalScore">0</span><br> <button onclick="goToMenu()">Main Menu</button> </div> </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Firebase Configuration ---
        const firebaseConfig = {
          apiKey: "AIzaSyCEVtcw6InjPAtT6qRDnMNNciNAVhMIBhM", // Keep this secure if needed
          authDomain: "office-crossing-game.firebaseapp.com",
          // --- URL UPDATED ---
          databaseURL: "https://office-crossing-game-default-rtdb.europe-west1.firebasedatabase.app",
          projectId: "office-crossing-game",
          storageBucket: "office-crossing-game.appspot.com", // Verify this
          messagingSenderId: "1060039127140",
          appId: "1:1060039127140:web:d7e01f6f64e97b4fcb6f71"
        };

        // --- Initialize Firebase ---
        let firebaseApp;
        let database;
        try {
            // Use compat libraries for easy transition if needed, or update to modular v9 syntax fully
            firebaseApp = firebase.initializeApp(firebaseConfig); // Using compat library syntax
            database = firebase.database(); // Using compat library syntax
            console.log("Firebase Initialized Successfully.");
        } catch (e) {
            console.error("Firebase initialization failed:", e);
            // Optionally, disable leaderboard features or notify user
            alert("Could not connect to the leaderboard database. High scores will not be available.");
        }

        // --- Game States ---
        const GAME_STATE = { MENU: 'menu', PLAYING: 'playing', GAME_OVER: 'game_over', SHOW_SCORES: 'show_scores' };
        let currentGameState = GAME_STATE.MENU;

        // --- Global Variables (Game Logic - unchanged) ---
        let scene, camera, renderer;
        let player, playerBoundingBox;
        let lanes = []; let obstacles = []; let score = 0; let scenery = [];
        let safeSpots = [];
        let wallSegments = [];
        let laneWidth = 6;
        let laneLength = 80;
        let playerPosition = { x: 0, z: 0 }; let targetPlayerPosition = { x: 0, z: 0 };
        let isMoving = false; let moveDuration = 150; let moveStartTime = 0;
        let lastLaneZ = 0; let generationDistance = 20; let cleanupBuffer = 5;
        let clock = new THREE.Clock(); let textureLoader = new THREE.TextureLoader();
        // const MAX_HIGH_SCORES = 3; // No longer needed for local storage limit
        let animationFrameId = null;
        let laneMaterials = {}; let wallMaterial; let sceneryMaterials = {};
        let lastMoveTime = 0; const MAX_IDLE_TIME = 5.0;
        let directionalLight;

        // --- Wall Constants (Unchanged) ---
        const WALL_HEIGHT = 8;
        const WALL_THICKNESS = 1.0;

        // --- Character Definition (Unchanged) ---
        const CHARACTERS = [
             { name: 'Alon', imageUrl: 'Alon.png', width: 2.8, height: 3.36 },
             { name: 'Sahar', imageUrl: 'Sahar.png', width: 2.8, height: 3.36 },
             { name: 'Mor', imageUrl: 'Mor.png', width: 2.8, height: 3.36 },
             { name: 'Lin', imageUrl: 'Lin.png', width: 2.8, height: 3.36 },
             { name: 'Asaf', imageUrl: 'Asaf.png', width: 2.8, height: 3.36 },
             { name: 'Tal', imageUrl: 'Tal.png', width: 2.8, height: 3.36 },
             { name: 'Ron', imageUrl: 'Ron.png', width: 2.8, height: 3.36 },
             { name: 'Hadar', imageUrl: 'Hadar.png', width: 2.8, height: 3.36 },
             { name: 'Adi', imageUrl: 'Adi.png', width: 2.8, height: 3.36 },
             { name: 'Alex', imageUrl: 'Alex.png', width: 2.8, height: 3.36 },
             { name: 'Amit', imageUrl: 'Amit.png', width: 2.8, height: 3.36 },
             { name: 'Anna', imageUrl: 'Anna.png', width: 2.8, height: 3.36 },
             { name: 'May Boss', imageUrl: 'May Boss.png', width: 2.8, height: 3.36 },
             { name: 'May QA', imageUrl: 'May QA.png', width: 2.8, height: 3.36 },
             { name: 'Ofek', imageUrl: 'Ofek.png', width: 2.8, height: 3.36 },
             { name: 'Default', imageUrl: null, width: 2.2, height: 2.2 }
        ];
        let selectedCharacterIndex = 0;
        let characterTextures = {};

        // --- THEME Constants & Colors (Unchanged) ---
        const LANE_TYPES = { CARPET: 'carpet', WALKWAY: 'walkway', WATER: 'water' };
        const DEFAULT_PLAYER_COLOR = 0xADD8E6;
        const DEFAULT_OBSTACLE_COLOR = 0xff00ff;
        const SCENERY_COLORS = { DESK: 0xAF8F6D, PLANT_POT: 0xCD853F, PLANT_LEAF: 0x2E8B57 };
        const SAFE_SPOT_COLOR = 0x90EE90;
        const WATER_COLOR = 0x1E90FF;

        // --- Obstacle Definitions (Unchanged) ---
        const OBSTACLE_TYPES = { CC: 'cc', LIVE_CHANGE: 'live_change', ON_CALL: 'on_call' };
        const OBSTACLE_IMAGES = {
            [OBSTACLE_TYPES.CC]: { right: 'CC.png', left: 'CC R.png' },
            [OBSTACLE_TYPES.LIVE_CHANGE]: { right: 'Live Change.png', left: 'Live Change R.png' },
            [OBSTACLE_TYPES.ON_CALL]: { right: 'On Call.png', left: 'On Call R.png' }
        };
        let obstacleTextures = {};
        const OBSTACLE_PLANE_WIDTH = 5.0;
        const OBSTACLE_PLANE_HEIGHT = 5.0;

        // --- DOM Elements (Unchanged) ---
        let infoElement, mainMenuElement, scoreboardScreenElement, gameOverElement;
        let characterButtonsElement, startGameButton, viewScoresButton, backToMenuButton;
        let scoreListElement, noScoresMessageElement, finalScoreElement, gameOverReasonElement;

        // --- Texture Generation Functions (Unchanged) ---
        function createNoiseTexture(width, height, color1, color2, alpha = 1) { const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height; const ctx = canvas.getContext('2d'); ctx.fillStyle = color1; ctx.fillRect(0, 0, width, height); const imageData = ctx.getImageData(0, 0, width, height); const data = imageData.data; for (let i = 0; i < data.length; i += 4) { if (Math.random() > 0.85) { const shade = Math.random() * 50 + (color2 === '#000000' ? 0 : 205); data[i] = shade; data[i + 1] = shade; data[i + 2] = shade; } data[i + 3] = alpha * 255; } ctx.putImageData(imageData, 0, 0); const texture = new THREE.CanvasTexture(canvas); texture.wrapS = texture.wrapT = THREE.RepeatWrapping; return texture; }
        function createTileTexture(width, height, bgColor, lineColor, tileSize) { const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height; const ctx = canvas.getContext('2d'); ctx.fillStyle = bgColor; ctx.fillRect(0, 0, width, height); ctx.strokeStyle = lineColor; ctx.lineWidth = Math.max(1, Math.floor(width / 100)); ctx.beginPath(); for (let x = 0; x <= width; x += tileSize) { ctx.moveTo(x, 0); ctx.lineTo(x, height); } for (let y = 0; y <= height; y += tileSize) { ctx.moveTo(0, y); ctx.lineTo(width, y); } ctx.stroke(); const texture = new THREE.CanvasTexture(canvas); texture.wrapS = texture.wrapT = THREE.RepeatWrapping; return texture; }

        // --- Firebase Leaderboard Functions ---

        /**
         * Submits the player's score to the Firebase Realtime Database.
         * @param {string} playerName - The name of the player (currently character name).
         * @param {number} playerScore - The score achieved by the player.
         */
        function submitScoreToFirebase(playerName, playerScore) {
            if (!database) {
                console.error("Database not initialized. Cannot submit score.");
                return;
            }
            if (playerScore <= 0) {
                console.log("Score is 0 or less, not submitting.");
                return; // Don't submit scores of 0 or less
            }

            const scoresRef = database.ref('scores'); // Reference to the 'scores' node
            const newScoreRef = scoresRef.push(); // Generate a unique key

            newScoreRef.set({
                name: playerName,
                score: playerScore,
                // Use server timestamp for fair ordering/tie-breaking if needed
                timestamp: firebase.database.ServerValue.TIMESTAMP
            })
            .then(() => {
                console.log(`Score for ${playerName} (${playerScore}) submitted successfully.`);
            })
            .catch((error) => {
                console.error("Error submitting score to Firebase:", error);
                // Optionally alert the user
                // alert("There was an error submitting your score. Please try again later.");
            });
        }

        /**
         * Sets up a listener for the top 3 high scores from Firebase
         * and updates the scoreboard UI in real-time.
         */
        function listenForHighScores() {
            if (!database) {
                console.error("Database not initialized. Cannot listen for scores.");
                noScoresMessageElement.textContent = "Leaderboard unavailable.";
                noScoresMessageElement.style.display = 'block';
                scoreListElement.innerHTML = '';
                return;
            }

            const scoresRef = database.ref('scores');
            // Query: Order by 'score' descending, limit to the last 3 (which are the highest)
            const topScoresQuery = scoresRef.orderByChild('score').limitToLast(3);

            // Detach previous listener if any (important for re-entering scoreboard)
            topScoresQuery.off('value'); // Turn off previous listeners on this query

            // Attach the listener
            topScoresQuery.on('value', (snapshot) => {
                scoreListElement.innerHTML = ''; // Clear previous list
                const scores = [];
                if (snapshot.exists()) {
                    // Firebase returns data as an object, convert to array
                    snapshot.forEach((childSnapshot) => {
                        scores.push({
                            key: childSnapshot.key,
                            name: childSnapshot.val().name,
                            score: childSnapshot.val().score
                        });
                    });

                    // Sort descending (Firebase limitToLast should already do this, but good practice)
                    scores.sort((a, b) => b.score - a.score);

                    noScoresMessageElement.style.display = 'none'; // Hide 'no scores' message
                    scores.forEach((scoreEntry) => {
                        const li = document.createElement('li');
                        // Truncate name if too long for display
                        const displayName = scoreEntry.name.length > 15 ? scoreEntry.name.substring(0, 12) + '...' : scoreEntry.name;
                        li.innerHTML = `<span class="name">${escapeHtml(displayName)}</span><span class="score">${scoreEntry.score}</span>`;
                        scoreListElement.appendChild(li);
                    });
                } else {
                    // No scores found in the database
                    noScoresMessageElement.textContent = "No scores yet! Be the first!";
                    noScoresMessageElement.style.display = 'block';
                }
            }, (error) => {
                console.error("Error fetching high scores:", error);
                noScoresMessageElement.textContent = "Error loading scores.";
                noScoresMessageElement.style.display = 'block';
                scoreListElement.innerHTML = '';
            });
        }

        // Utility to prevent basic HTML injection from names
        function escapeHtml(unsafe) {
            if (!unsafe) return '';
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        }

        // --- UI State Management (Unchanged) ---
        function showOverlay(overlayElement) {
            mainMenuElement.classList.add('hidden');
            scoreboardScreenElement.classList.add('hidden');
            gameOverElement.classList.add('hidden');
            infoElement.classList.add('hidden'); // Hide score during overlays
            if (overlayElement) {
                overlayElement.classList.remove('hidden');
            }
        }

        // --- Character Selection (Unchanged) ---
        function selectCharacter(index) {
            if (index >= 0 && index < CHARACTERS.length) {
                selectedCharacterIndex = index;
                updateCharacterButtonSelection();
                console.log(`Selected character: ${CHARACTERS[selectedCharacterIndex].name}`);
            }
        }
        function updateCharacterButtonSelection() {
            const buttons = characterButtonsElement.querySelectorAll('.char-button');
            buttons.forEach((button, index) => {
                if (index === selectedCharacterIndex) button.classList.add('selected');
                else button.classList.remove('selected');
            });
        }
        function populateCharacterButtons() {
             characterButtonsElement.innerHTML = '';
             CHARACTERS.forEach((char, index) => {
                 const button = document.createElement('button');
                 button.textContent = char.name;
                 button.classList.add('char-button');
                 button.onclick = () => selectCharacter(index);
                 characterButtonsElement.appendChild(button);
             });
             updateCharacterButtonSelection(); // Set initial selection highlight
        }

        // --- Preload Assets & Materials (Unchanged, ensure paths are correct) ---
        function preloadAssets() {
            console.log("Preloading assets...");
            let maxAnisotropy = renderer ? renderer.capabilities.getMaxAnisotropy() : 1;
            // Load Character Textures
            CHARACTERS.forEach((char, index) => {
                if (char.imageUrl) {
                    characterTextures[index] = textureLoader.load(char.imageUrl, (texture) => {
                         texture.magFilter = THREE.NearestFilter; // Pixelated look
                         texture.anisotropy = maxAnisotropy;
                         texture.needsUpdate = true;
                    }, undefined, (err) => console.error(`Failed texture: ${char.name} (${char.imageUrl})`, err) );
                }
             });
            // Load Obstacle Textures
            obstacleTextures = {};
            for (const typeKey in OBSTACLE_IMAGES) {
                const images = OBSTACLE_IMAGES[typeKey];
                obstacleTextures[typeKey] = {};
                const loadCallback = (texture) => { texture.magFilter = THREE.NearestFilter; texture.anisotropy = maxAnisotropy; texture.needsUpdate = true; };
                if (images.right) { obstacleTextures[typeKey].right = textureLoader.load(images.right, loadCallback, undefined, (err) => console.error(`Failed texture: ${typeKey} Right (${images.right})`, err)); } else { console.warn(`Missing right image for obstacle type: ${typeKey}`); }
                if (images.left) { obstacleTextures[typeKey].left = textureLoader.load(images.left, loadCallback, undefined, (err) => console.error(`Failed texture: ${typeKey} Left (${images.left})`, err)); } else { console.warn(`Missing left image for obstacle type: ${typeKey}`); obstacleTextures[typeKey].left = obstacleTextures[typeKey].right; } // Fallback to right image if left is missing
            }
            // Define Materials
            const carpetTexture = createNoiseTexture(64, 64, '#90EE90', '#3CB371'); carpetTexture.repeat.set(8, 8);
            laneMaterials[LANE_TYPES.CARPET] = new THREE.MeshStandardMaterial({ map: carpetTexture, roughness: 0.9, metalness: 0.05 });
            const walkwayTexture = createTileTexture(64, 64, '#E07A5F', '#D45D3D', 24); walkwayTexture.repeat.set(8, 8);
            laneMaterials[LANE_TYPES.WALKWAY] = new THREE.MeshStandardMaterial({ map: walkwayTexture, roughness: 0.4, metalness: 0.1 });
            laneMaterials[LANE_TYPES.WATER] = new THREE.MeshStandardMaterial({ color: WATER_COLOR, roughness: 0.2, metalness: 0.1, transparent: true, opacity: 0.85 });
            wallMaterial = new THREE.MeshStandardMaterial({ color: 0xFFEBCD, roughness: 0.9, metalness: 0.0 });
            sceneryMaterials.desk = new THREE.MeshStandardMaterial({ color: SCENERY_COLORS.DESK, roughness: 0.8, metalness: 0.1 });
            sceneryMaterials.plantPot = new THREE.MeshStandardMaterial({ color: SCENERY_COLORS.PLANT_POT, roughness: 0.7, metalness: 0.1 });
            sceneryMaterials.plantLeaf = new THREE.MeshStandardMaterial({ color: SCENERY_COLORS.PLANT_LEAF, roughness: 0.8, metalness: 0.0 });
            sceneryMaterials.safeSpot = new THREE.MeshStandardMaterial({ color: SAFE_SPOT_COLOR, roughness: 0.9, metalness: 0.0 });
            console.log("Asset preloading & generation initiated.");
        }

        // --- Initialization (Modified for Firebase) ---
        function init() {
            // Get DOM Elements
            infoElement = document.getElementById('info');
            mainMenuElement = document.getElementById('mainMenu');
            scoreboardScreenElement = document.getElementById('scoreboardScreen');
            gameOverElement = document.getElementById('gameOver');
            characterButtonsElement = document.getElementById('characterButtons');
            startGameButton = document.getElementById('startGameButton');
            viewScoresButton = document.getElementById('viewScoresButton');
            backToMenuButton = document.getElementById('backToMenuButton');
            scoreListElement = document.getElementById('scoreList');
            noScoresMessageElement = document.getElementById('noScoresMessage');
            finalScoreElement = document.getElementById('finalScore');
            gameOverReasonElement = document.getElementById('gameOverReason');

            // Basic Scene Setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 12);
            camera.lookAt(0, 0, 0);

            // Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // alpha:true for transparent background if needed
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
            document.body.appendChild(renderer.domElement);
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // Better color grading
            renderer.toneMappingExposure = 1.0;

            // Lighting Setup
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // Soft ambient light
            scene.add(ambientLight);
            const hemiLight = new THREE.HemisphereLight( 0xE8E8FF, 0xB0B0B0, 0.6 ); // Sky/ground light
            scene.add( hemiLight );
            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Main sunlight
            directionalLight.position.set(20, 35, 25);
            directionalLight.castShadow = true;
            // Configure shadow properties
            directionalLight.shadow.mapSize.width = 2048; // Higher resolution shadows
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 1;
            directionalLight.shadow.camera.far = 500;
            const initialShadowSize = laneLength / 2 + 10; // Adjust shadow camera frustum
            directionalLight.shadow.camera.left = -initialShadowSize;
            directionalLight.shadow.camera.right = initialShadowSize;
            directionalLight.shadow.camera.top = initialShadowSize;
            directionalLight.shadow.camera.bottom = -initialShadowSize;
            directionalLight.shadow.bias = -0.005; // Adjust shadow bias to prevent artifacts
            scene.add(directionalLight);
            scene.add(directionalLight.target); // Target for the light

            // Preload assets (textures, materials)
            preloadAssets();

            // Populate UI Elements
            if (characterButtonsElement) populateCharacterButtons();
            else console.error("characterButtonsElement not found!");

            // Setup Button Listeners
            if (startGameButton) startGameButton.onclick = startGame;
            else console.error("startGameButton not found!");

            if (viewScoresButton) {
                viewScoresButton.onclick = () => {
                    // --- MODIFIED ---
                    // Start listening for scores when the button is clicked
                    // The listener will automatically update the display
                    listenForHighScores();
                    currentGameState = GAME_STATE.SHOW_SCORES;
                    showOverlay(scoreboardScreenElement);
                };
            } else {
                console.error("viewScoresButton not found!");
            }

            if (backToMenuButton) {
                backToMenuButton.onclick = () => {
                    // Detach listener when leaving scoreboard to save resources (optional but good practice)
                    if (database) {
                         database.ref('scores').orderByChild('score').limitToLast(3).off('value');
                    }
                    goToMenu();
                };
            } else {
                console.error("backToMenuButton not found!");
            }

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);

            // Initial State
            goToMenu(); // Start at the main menu
            animate(); // Start the animation loop
        }


        // --- Game Start Logic (Unchanged) ---
        function startGame() {
            console.log("Starting game...");
            score = 0;
            playerPosition = { x: 0, z: 0 };
            targetPlayerPosition = { x: 0, z: 0 };
            lastLaneZ = 0;
            isMoving = false;
            infoElement.innerText = `Score: ${score}`;
            infoElement.classList.remove('hidden'); // Show score display
            lastMoveTime = clock.getElapsedTime(); // Reset idle timer

            clearGameObjects(); // Remove old objects
            createPlayer(); // Create the player model
            createLane(LANE_TYPES.CARPET, 0); // Create starting lane
            // Generate initial set of lanes
            for (let i = 1; i < generationDistance; i++) {
                generateLane();
            }

            // Reset camera for game start
            camera.position.set(0, 15, 12); // Adjust as needed
            camera.lookAt(player.position.x, player.position.y, player.position.z);

            currentGameState = GAME_STATE.PLAYING;
            showOverlay(null); // Hide all overlays
            if (animationFrameId) cancelAnimationFrame(animationFrameId); // Ensure no duplicate loops
            animate(); // Make sure animation loop is running
        }

        // --- Game Object Creation (Player, Lane, Obstacles, Scenery - Largely Unchanged) ---
        function createPlayer() {
            const selectedChar = CHARACTERS[selectedCharacterIndex];
            let playerGeometry;
            let playerMaterial;

            if (selectedChar.imageUrl && characterTextures[selectedCharacterIndex]) {
                // Use texture if available
                playerGeometry = new THREE.PlaneGeometry(selectedChar.width, selectedChar.height);
                playerMaterial = new THREE.MeshStandardMaterial({
                    map: characterTextures[selectedCharacterIndex],
                    transparent: true, // Needed for PNG transparency
                    side: THREE.DoubleSide, // Render both sides
                    roughness: 0.8,
                    metalness: 0.1
                });
            } else {
                // Fallback to default colored box if no image/texture
                playerGeometry = new THREE.BoxGeometry(selectedChar.width * 0.8, selectedChar.height * 0.8, selectedChar.width * 0.8);
                playerMaterial = new THREE.MeshStandardMaterial({ color: DEFAULT_PLAYER_COLOR, roughness: 0.6, metalness: 0.2 });
            }

            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(playerPosition.x, selectedChar.height / 2, playerPosition.z); // Adjust Y based on geometry
            player.rotation.y = Math.PI; // Start facing forward (down the Z axis)
            player.castShadow = true;
            player.receiveShadow = false; // Player likely won't receive shadows onto itself much
            scene.add(player);

            // Bounding box for collision detection (adjust size as needed)
            const buffer = 0.1; // Small buffer
            playerBoundingBox = new THREE.Box3().setFromObject(player).expandByScalar(-buffer); // Slightly smaller box
        }

        function createLane(type, zPos) {
            const laneGeometry = new THREE.PlaneGeometry(laneWidth, laneLength);
            const material = laneMaterials[type] || laneMaterials[LANE_TYPES.CARPET]; // Fallback material
            const laneMesh = new THREE.Mesh(laneGeometry, material);
            laneMesh.rotation.x = -Math.PI / 2; // Rotate flat
            laneMesh.position.set(0, 0, zPos - laneLength / 2); // Position centered at zPos
            laneMesh.receiveShadow = true; // Lanes receive shadows
            scene.add(laneMesh);
            lanes.push({ mesh: laneMesh, type: type, z: zPos });

            // Add walls to the sides of the lane
            createWallSegment(zPos);

            // Add scenery based on lane type
            if (type === LANE_TYPES.CARPET || type === LANE_TYPES.WALKWAY) {
                addSceneryToLane(zPos, type);
            }

            // Add safe spots on CARPET lanes only
            if (type === LANE_TYPES.CARPET) {
                 addSafeSpotsToLane(zPos);
            }

            // Add obstacles based on lane type (avoid obstacles on the very first lane)
            if (zPos !== 0 && type !== LANE_TYPES.WATER) { // No obstacles on water or first lane
                addObstaclesToLane(zPos, type);
            }
        }

        function createWallSegment(zPos) {
            const wallGeometry = new THREE.BoxGeometry(WALL_THICKNESS, WALL_HEIGHT, laneLength);
            const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
            const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);

            leftWall.position.set(-laneWidth / 2 - WALL_THICKNESS / 2, WALL_HEIGHT / 2, zPos - laneLength / 2);
            rightWall.position.set(laneWidth / 2 + WALL_THICKNESS / 2, WALL_HEIGHT / 2, zPos - laneLength / 2);

            leftWall.castShadow = true;
            leftWall.receiveShadow = true;
            rightWall.castShadow = true;
            rightWall.receiveShadow = true;

            scene.add(leftWall);
            scene.add(rightWall);
            wallSegments.push({ left: leftWall, right: rightWall, z: zPos });
        }

        function addSceneryToLane(zPos, type) {
            const numSceneryItems = Math.floor(Math.random() * 3) + 1; // 1 to 3 items per lane
            for (let i = 0; i < numSceneryItems; i++) {
                const xPos = (Math.random() - 0.5) * (laneWidth * 0.8); // Slightly inside lane edges
                const zOffset = (Math.random() - 0.5) * (laneLength * 0.9); // Random position along lane length
                const itemZ = zPos - laneLength / 2 + zOffset;

                if (Math.random() < 0.7) { // 70% chance of desk
                    createDesk(xPos, itemZ);
                } else { // 30% chance of plant
                    createPlant(xPos, itemZ);
                }
            }
        }

        function createDesk(x, z) {
            const deskGroup = new THREE.Group();
            const topGeo = new THREE.BoxGeometry(2.5, 0.2, 1.5);
            const legGeo = new THREE.BoxGeometry(0.2, 1.0, 0.2);
            const top = new THREE.Mesh(topGeo, sceneryMaterials.desk);
            top.position.y = 1.0 + 0.1; // Legs height + half top thickness
            top.castShadow = true;
            deskGroup.add(top);
            const legPositions = [ {x: -1.1, z: -0.6}, {x: 1.1, z: -0.6}, {x: -1.1, z: 0.6}, {x: 1.1, z: 0.6} ];
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeo, sceneryMaterials.desk);
                leg.position.set(pos.x, 0.5, pos.z); // Half leg height
                leg.castShadow = true;
                deskGroup.add(leg);
            });
            deskGroup.position.set(x, 0, z);
            scene.add(deskGroup);
            scenery.push(deskGroup);
        }

        function createPlant(x, z) {
            const plantGroup = new THREE.Group();
            const potGeo = new THREE.CylinderGeometry(0.5, 0.4, 0.8, 12);
            const pot = new THREE.Mesh(potGeo, sceneryMaterials.plantPot);
            pot.position.y = 0.4; // Half pot height
            pot.castShadow = true;
            plantGroup.add(pot);
            const leafGeo = new THREE.SphereGeometry(0.4, 8, 6);
            const leaves = new THREE.Mesh(leafGeo, sceneryMaterials.plantLeaf);
            leaves.position.y = 0.8 + 0.3; // Pot height + offset
            leaves.castShadow = true;
            plantGroup.add(leaves);
            plantGroup.position.set(x, 0, z);
            scene.add(plantGroup);
            scenery.push(plantGroup);
        }

         function addSafeSpotsToLane(zPos) {
            const numSpots = Math.random() < 0.4 ? 1 : 0; // 40% chance of a safe spot
            if (numSpots > 0) {
                const xPos = (Math.random() - 0.5) * (laneWidth * 0.7);
                const zOffset = (Math.random() - 0.5) * (laneLength * 0.8);
                const spotZ = zPos - laneLength / 2 + zOffset;
                createSafeSpot(xPos, spotZ);
            }
        }

        function createSafeSpot(x, z) {
            const spotGeometry = new THREE.CylinderGeometry(1.0, 1.0, 0.1, 16); // Flat cylinder
            const spotMesh = new THREE.Mesh(spotGeometry, sceneryMaterials.safeSpot);
            spotMesh.position.set(x, 0.05, z); // Slightly above ground
            spotMesh.receiveShadow = true; // Can receive shadows
            scene.add(spotMesh);
            safeSpots.push(spotMesh); // Add to safe spots array for potential collision checks
        }

        function addObstaclesToLane(zPos, type) {
            const obstacleCount = Math.floor(Math.random() * 2) + 1; // 1 or 2 obstacles
            const speed = (Math.random() * 1.5 + 1.0) * (Math.random() < 0.5 ? 1 : -1); // Random speed & direction
            const startX = speed > 0 ? -laneWidth / 2 - OBSTACLE_PLANE_WIDTH : laneWidth / 2 + OBSTACLE_PLANE_WIDTH; // Start off-screen

            for (let i = 0; i < obstacleCount; i++) {
                 // Ensure obstacles don't overlap too much vertically within the same lane generation
                const zOffset = (laneLength / (obstacleCount + 1)) * (i + 1) - laneLength / 2;
                const obstacleZ = zPos + zOffset;
                createObstacle(startX + i * (speed > 0 ? -2 : 2), obstacleZ, speed, type); // Stagger start X slightly
            }
        }

        function createObstacle(x, z, speed, laneType) {
            const obstacleTypes = Object.values(OBSTACLE_TYPES);
            const randomTypeKey = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
            const texturesForType = obstacleTextures[randomTypeKey];

            if (!texturesForType) {
                console.warn(`Textures not loaded for obstacle type: ${randomTypeKey}. Skipping obstacle.`);
                return; // Skip if textures aren't ready
            }

            const texture = speed > 0 ? texturesForType.right : texturesForType.left;
            if (!texture) {
                 console.warn(`Specific direction texture missing for ${randomTypeKey}. Using fallback/skipping.`);
                 // Potentially use the other direction's texture if available, or skip
                 if (texturesForType.right) texture = texturesForType.right;
                 else if (texturesForType.left) texture = texturesForType.left;
                 else return; // Skip if no textures at all
            }

            const geometry = new THREE.PlaneGeometry(OBSTACLE_PLANE_WIDTH, OBSTACLE_PLANE_HEIGHT);
            const material = new THREE.MeshStandardMaterial({
                map: texture,
                transparent: true, // For PNG transparency
                side: THREE.DoubleSide, // Show texture from both sides
                roughness: 0.9,
                metalness: 0.0
            });

            const obstacleMesh = new THREE.Mesh(geometry, material);
            obstacleMesh.position.set(x, OBSTACLE_PLANE_HEIGHT / 2, z); // Position center Y at half height
            obstacleMesh.castShadow = true;
            scene.add(obstacleMesh);

            const obstacleData = {
                mesh: obstacleMesh,
                speed: speed,
                boundingBox: new THREE.Box3().setFromObject(obstacleMesh) // Initialize bounding box
            };
            obstacles.push(obstacleData);
        }


        // --- Game Logic (Movement, Update, Collision, Generation - Largely Unchanged) ---
        function onKeyDown(event) {
            if (currentGameState !== GAME_STATE.PLAYING || isMoving) return; // Only move when playing and not already moving

            let moved = false;
            let targetX = targetPlayerPosition.x;
            let targetZ = targetPlayerPosition.z;

            switch (event.key) {
                case 'ArrowUp':
                case 'w':
                    targetZ -= laneLength; // Move forward one lane length
                    moved = true;
                    break;
                case 'ArrowDown':
                case 's':
                    // Allow moving back, but don't decrease score
                    targetZ += laneLength;
                    moved = true;
                    break;
                case 'ArrowLeft':
                case 'a':
                    targetX -= laneWidth / 3; // Move left within the lane (adjust step)
                    targetX = Math.max(-laneWidth / 2 + player.geometry.parameters.width / 2, targetX); // Clamp to left edge
                    moved = true;
                    break;
                case 'ArrowRight':
                case 'd':
                    targetX += laneWidth / 3; // Move right within the lane (adjust step)
                    targetX = Math.min(laneWidth / 2 - player.geometry.parameters.width / 2, targetX); // Clamp to right edge
                    moved = true;
                    break;
            }

            if (moved) {
                // Check if moving forward to update score
                if (targetZ < targetPlayerPosition.z) {
                    score++;
                    infoElement.innerText = `Score: ${score}`;
                    // Generate new lane if moving forward
                    generateLane();
                }

                targetPlayerPosition.x = targetX;
                targetPlayerPosition.z = targetZ;
                isMoving = true;
                moveStartTime = clock.getElapsedTime();
                lastMoveTime = moveStartTime; // Reset idle timer on move
            }
        }

        function updatePlayerPosition(deltaTime) {
            if (!isMoving) return;

            const elapsedTime = clock.getElapsedTime() - moveStartTime;
            const moveProgress = Math.min(elapsedTime * 1000 / moveDuration, 1); // Progress from 0 to 1

            // Smooth interpolation (e.g., ease-out)
            const easedProgress = 1 - Math.pow(1 - moveProgress, 3); // Cubic ease-out

            playerPosition.x = THREE.MathUtils.lerp(player.position.x, targetPlayerPosition.x, easedProgress);
            playerPosition.z = THREE.MathUtils.lerp(player.position.z, targetPlayerPosition.z, easedProgress);

            player.position.set(playerPosition.x, player.position.y, playerPosition.z);

            if (moveProgress >= 1) {
                isMoving = false;
                player.position.set(targetPlayerPosition.x, player.position.y, targetPlayerPosition.z); // Snap to final position
                playerPosition = { ...targetPlayerPosition }; // Update current position state
            }
        }

        function updateObstacles(deltaTime) {
            obstacles.forEach(obstacle => {
                obstacle.mesh.position.x += obstacle.speed * deltaTime;
                // Wrap around horizontally
                if (obstacle.speed > 0 && obstacle.mesh.position.x > laneWidth / 2 + OBSTACLE_PLANE_WIDTH * 2) {
                    obstacle.mesh.position.x = -laneWidth / 2 - OBSTACLE_PLANE_WIDTH * 2;
                } else if (obstacle.speed < 0 && obstacle.mesh.position.x < -laneWidth / 2 - OBSTACLE_PLANE_WIDTH * 2) {
                    obstacle.mesh.position.x = laneWidth / 2 + OBSTACLE_PLANE_WIDTH * 2;
                }
                // Update bounding box after moving
                obstacle.boundingBox.setFromObject(obstacle.mesh);
            });
        }

        function checkCollisions() {
            if (!player || currentGameState !== GAME_STATE.PLAYING) return;

            // Update player bounding box
            playerBoundingBox.setFromObject(player);

            // 1. Check Obstacle Collisions
            for (const obstacle of obstacles) {
                if (playerBoundingBox.intersectsBox(obstacle.boundingBox)) {
                    gameOver("hit"); // Pass reason for game over
                    return; // Stop checking after game over
                }
            }

            // 2. Check Water Collision (if player is over a water lane)
            const currentLane = lanes.find(lane =>
                player.position.z < lane.z && player.position.z >= lane.z - laneLength
            );
            if (currentLane && currentLane.type === LANE_TYPES.WATER) {
                 // Check if player is NOT on a safe spot within the water lane
                 let onSafeSpot = false;
                 for (const spot of safeSpots) {
                     // Simple distance check from center of spot (adjust radius as needed)
                     if (spot.position.distanceTo(player.position) < 1.1) { // Radius + buffer
                         onSafeSpot = true;
                         break;
                     }
                 }
                 if (!onSafeSpot) {
                     gameOver("drowned");
                     return;
                 }
            }

            // 3. Check Idle Timeout
            if (clock.getElapsedTime() - lastMoveTime > MAX_IDLE_TIME) {
                gameOver("idle");
                return;
            }
        }

        function generateLane() {
            const nextZ = lastLaneZ - laneLength;
            const laneTypes = Object.values(LANE_TYPES);
            // Slightly bias towards non-water lanes after water
            const previousLaneType = lanes.length > 0 ? lanes[lanes.length - 1].type : null;
            let randomType;
            if (previousLaneType === LANE_TYPES.WATER && Math.random() < 0.7) {
                 // 70% chance of non-water after water
                 const nonWaterTypes = laneTypes.filter(t => t !== LANE_TYPES.WATER);
                 randomType = nonWaterTypes[Math.floor(Math.random() * nonWaterTypes.length)];
            } else {
                 // Normal random selection
                 randomType = laneTypes[Math.floor(Math.random() * laneTypes.length)];
            }

            createLane(randomType, nextZ);
            lastLaneZ = nextZ;
        }

        function cleanupOldObjects() {
            const cleanupZ = player ? player.position.z + laneLength * cleanupBuffer : 0; // Z position threshold

            // Cleanup Lanes
            lanes = lanes.filter(lane => {
                if (lane.z < cleanupZ) {
                    scene.remove(lane.mesh);
                    lane.mesh.geometry.dispose();
                    // Material disposal handled globally if needed, or per-lane if unique
                    return false; // Remove from array
                }
                return true; // Keep in array
            });

             // Cleanup Walls
            wallSegments = wallSegments.filter(wall => {
                if (wall.z < cleanupZ) {
                    scene.remove(wall.left);
                    scene.remove(wall.right);
                    wall.left.geometry.dispose(); // Geometry is shared, dispose carefully or manage refs
                    // wall.right.geometry.dispose(); // Dispose only once if shared
                    // Material disposal handled globally
                    return false;
                }
                return true;
            });

            // Cleanup Obstacles
            obstacles = obstacles.filter(obstacle => {
                if (obstacle.mesh.position.z > cleanupZ + laneLength) { // Obstacles are further ahead
                    scene.remove(obstacle.mesh);
                    obstacle.mesh.geometry.dispose();
                    obstacle.mesh.material.dispose(); // Dispose material if unique per obstacle
                    return false;
                }
                return true;
            });

            // Cleanup Scenery
            scenery = scenery.filter(item => {
                if (item.position.z > cleanupZ + laneLength) {
                    scene.remove(item);
                    // Dispose geometries/materials within the group if necessary
                    item.traverse(child => {
                        if (child.isMesh) {
                            child.geometry.dispose();
                            // child.material.dispose(); // If materials are unique
                        }
                    });
                    return false;
                }
                return true;
            });

             // Cleanup Safe Spots
            safeSpots = safeSpots.filter(spot => {
                if (spot.position.z > cleanupZ + laneLength) {
                    scene.remove(spot);
                    spot.geometry.dispose();
                    // spot.material.dispose(); // If material is unique
                    return false;
                }
                return true;
            });
        }

        // --- Animation Loop (Unchanged) ---
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            if (currentGameState === GAME_STATE.PLAYING) {
                updatePlayerPosition(deltaTime);
                updateObstacles(deltaTime);
                checkCollisions(); // Check collisions after updates

                // Dynamic camera follow
                if (player) {
                    const targetCameraPos = new THREE.Vector3(
                        player.position.x, // Follow X slightly
                        camera.position.y, // Keep Y fixed for now
                        player.position.z + 12 // Maintain distance behind player
                    );
                     // Smooth camera movement (lerp)
                    camera.position.lerp(targetCameraPos, deltaTime * 2.0); // Adjust lerp factor for speed
                    camera.lookAt(player.position.x, player.position.y, player.position.z); // Look at player

                    // Update light target to follow player
                    directionalLight.target.position.copy(player.position);
                    directionalLight.target.updateMatrixWorld(); // Important after moving target

                     // Adjust shadow camera frustum to follow player - helps maintain shadow quality
                    const shadowCam = directionalLight.shadow.camera;
                    const followOffset = 10; // How far ahead/behind player the shadow focuses
                    const shadowSize = 25; // Size of the shadow area around the player
                    shadowCam.left = player.position.x - shadowSize;
                    shadowCam.right = player.position.x + shadowSize;
                    shadowCam.top = player.position.z + shadowSize - followOffset;
                    shadowCam.bottom = player.position.z - shadowSize - followOffset;
                    shadowCam.updateProjectionMatrix(); // Apply changes
                }

                // Cleanup objects far behind the player
                cleanupOldObjects();
            }

            // Always render the scene regardless of game state
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // --- Game Over (Modified for Firebase) ---
        function gameOver(reason = "hit") {
            if (currentGameState === GAME_STATE.GAME_OVER) return; // Prevent multiple calls

            currentGameState = GAME_STATE.GAME_OVER;
            console.log(`Game Over! Score: ${score}, Reason: ${reason}`);
            finalScoreElement.innerText = score; // Update final score display

            // Set reason text
            if (reason === "idle") { gameOverReasonElement.innerText = "Took too long!"; }
            else if (reason === "drowned") { gameOverReasonElement.innerText = "Fell in the water cooler!"; }
            else { gameOverReasonElement.innerText = "Deadline Missed!"; } // Default "hit"

            showOverlay(gameOverElement); // Show game over screen
            infoElement.classList.add('hidden'); // Hide in-game score display

            // --- MODIFIED: Submit score to Firebase ---
            const characterName = CHARACTERS[selectedCharacterIndex].name;
            // Optional: Prompt for player name instead of using character name
            // let playerName = prompt("Enter your name for the leaderboard:", characterName);
            // if (!playerName || playerName.trim() === "") {
            //     playerName = characterName; // Default to character name if empty/cancelled
            // }
            // submitScoreToFirebase(playerName.trim(), score);
            submitScoreToFirebase(characterName, score); // Using character name for now

            // Stop animation loop if desired (or let it run for background)
            // cancelAnimationFrame(animationFrameId);
            // animationFrameId = null;
        }

        // --- Go To Menu (Unchanged) ---
        function goToMenu() {
            currentGameState = GAME_STATE.MENU;
            showOverlay(mainMenuElement);
            // Optional: Reset camera to default menu position
            camera.position.set(0, 15, 12);
            camera.lookAt(0, 0, 0);
            // Ensure animation loop is running if it was stopped
            if (!animationFrameId) animate();
        }

        // --- Clear Game Objects (Helper Function - Unchanged) ---
        function clearGameObjects() {
            // Remove Player
            if (player) scene.remove(player);
            player = null;
            playerBoundingBox = null;

            // Remove Lanes
            lanes.forEach(lane => scene.remove(lane.mesh));
            lanes = [];

             // Remove Walls
            wallSegments.forEach(wall => { scene.remove(wall.left); scene.remove(wall.right); });
            wallSegments = [];

            // Remove Obstacles
            obstacles.forEach(obstacle => scene.remove(obstacle.mesh));
            obstacles = [];

            // Remove Scenery
            scenery.forEach(item => scene.remove(item));
            scenery = [];

             // Remove Safe Spots
            safeSpots.forEach(spot => scene.remove(spot));
            safeSpots = [];

            // Reset score display
            score = 0;
            if(infoElement) infoElement.innerText = `Score: ${score}`;
        }


        // --- Resize Handler (Unchanged) ---
        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // --- Start the application ---
        document.addEventListener('DOMContentLoaded', (event) => {
            console.log("DOM fully loaded and parsed");
            init(); // Initialize everything
        });

    </script>
</body>
</html>

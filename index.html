<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Office Crossing Challenge - Large Scale & Colorful</title> {/* Updated Title */}
    <style>
        /* --- ADJUSTED --- Colors and Styles */
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            /* New sky blue gradient background */
            background: linear-gradient(to bottom, #87CEEB, #B0E0E6); /* SkyBlue to PowderBlue */
            color: #333;
            height: 100vh;
        }
        canvas { display: block; }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; flex-direction: column; background-color: rgba(0, 0, 0, 0.75); /* Slightly darker overlay */ color: white; z-index: 100; padding: 20px; box-sizing: border-box; text-align: center; }
        .hidden { display: none; }
        /* New overlay content background color */
        .overlay-content { background-color: rgba(40, 60, 80, 0.9); /* Dark blue-grey */ padding: 30px 40px; border-radius: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.4); max-width: 90%; width: 450px; /* Slightly wider */ }
        .overlay h2 { margin-top: 0; margin-bottom: 20px; border-bottom: 1px solid rgba(255,255,255,0.5); padding-bottom: 10px; color: #FFD700; /* Keep gold headings */ }
        /* New button colors */
        .overlay button { display: block; width: 80%; margin: 15px auto; padding: 12px 20px; font-size: 18px; cursor: pointer; border: none; border-radius: 8px; background-color: #4682B4; /* SteelBlue */ color: white; transition: background-color 0.3s, transform 0.1s; box-shadow: 0 4px 6px rgba(0,0,0,0.2); }
        .overlay button:hover { background-color: #5A9BD5; /* Lighter SteelBlue */ }
        .overlay button:active { transform: scale(0.95); background-color: #41729F; /* Darker SteelBlue */ }
        #mainMenu .character-selection { margin-bottom: 20px; padding: 10px; background-color: rgba(255,255,255,0.1); border-radius: 8px; }
        #mainMenu .character-selection h3 { margin-top: 0; margin-bottom: 10px; font-size: 16px; }
        #mainMenu .char-button { display: inline-block; width: auto; padding: 8px 15px; margin: 5px; font-size: 14px; border: 2px solid transparent; background-color: #6c757d; /* Greyish button */ }
        #mainMenu .char-button.selected { border-color: #FFD700; background-color: #4682B4; /* SteelBlue selected */ }
        #scoreboardScreen ol { margin: 0 0 15px 0; padding: 0 0 0 25px; list-style-position: outside; max-height: 150px; overflow-y: auto; }
        #scoreboardScreen li { margin-bottom: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 16px; border-bottom: 1px dotted rgba(255, 255, 255, 0.2); padding-bottom: 4px; }
        #scoreboardScreen li:last-child { border-bottom: none; }
        #scoreboardScreen li span { display: inline-block; }
        #scoreboardScreen li .name { /* width: 150px; */ }
        #scoreboardScreen li .score { float: right; font-weight: bold; margin-left: 15px; }
        #scoreboardScreen .no-scores { text-align: center; font-style: italic; color: #ccc; margin-top: 10px;}
        #info { position: absolute; top: 10px; left: 10px; width: auto; text-align: left; z-index: 50; display: block; color: #000080; /* Navy Blue score text */ font-size: 24px; font-weight: bold; text-shadow: 1px 1px 1px #FFFFFF; /* White shadow for contrast */ background-color: rgba(255, 255, 255, 0.6); padding: 5px 10px; border-radius: 5px; }
        #gameOver { z-index: 101; }
        #gameOverReason { font-size: 24px; margin-bottom: 15px; font-style: italic; color: #ffdddd; }

    </style>
</head>
<body>
    <div id="info" class="hidden">Score: 0</div>
    <div id="mainMenu" class="overlay"> <div class="overlay-content"> <h2>Office Crossing Challenge</h2> <div class="character-selection"> <h3>Select Character</h3> <div id="characterButtons"></div> </div> <button id="startGameButton">Start Game</button> <button id="viewScoresButton">High Scores</button> </div> </div>
    <div id="scoreboardScreen" class="overlay hidden"> <div class="overlay-content"> <h2>High Scores</h2> <ol id="scoreList"></ol> <div id="noScoresMessage" class="no-scores" style="display: none;">No scores yet!</div> <button id="backToMenuButton">Back to Menu</button> </div> </div>
    <div id="gameOver" class="overlay hidden"> <div class="overlay-content"> <h2 id="gameOverReason">Deadline Missed!</h2> Final Score: <span id="finalScore">0</span><br> <button onclick="goToMenu()">Main Menu</button> </div> </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Game States ---
        const GAME_STATE = { MENU: 'menu', PLAYING: 'playing', GAME_OVER: 'game_over', SHOW_SCORES: 'show_scores' };
        let currentGameState = GAME_STATE.MENU;

        // --- Global Variables ---
        let scene, camera, renderer;
        let player, playerBoundingBox;
        let lanes = []; let obstacles = []; let score = 0; let scenery = [];
        // --- *** ADJUSTED *** Proportions ---
        let laneWidth = 6; // Increased lane width to accommodate large obstacles
        let laneLength = 80; // Increased lane length for wider feel
        let playerPosition = { x: 0, z: 0 }; let targetPlayerPosition = { x: 0, z: 0 };
        let isMoving = false; let moveDuration = 150; let moveStartTime = 0;
        let lastLaneZ = 0; let generationDistance = 20; let cleanupBuffer = 5;
        let clock = new THREE.Clock(); let textureLoader = new THREE.TextureLoader();
        const MAX_HIGH_SCORES = 3; let animationFrameId = null;
        let laneMaterials = {}; let wallMaterial; let sceneryMaterials = {};
        let lastMoveTime = 0; const MAX_IDLE_TIME = 5.0;

        // --- *** ADJUSTED *** Character Definition (Scaled up sizes) ---
        const CHARACTERS = [
             { name: 'Alon', imageUrl: 'Alon.png', width: 2.8, height: 3.36 }, // Doubled size
             { name: 'Sahar', imageUrl: 'Sahar.png', width: 2.8, height: 3.36 }, // Doubled size
             { name: 'Default', imageUrl: null, width: 2.2, height: 2.2 } // Doubled size
        ];
        let selectedCharacterIndex = 0; let characterTextures = {};

        // --- THEME Constants & Colors ---
        const LANE_TYPES = { CARPET: 'carpet', WALKWAY: 'walkway' };
        // Removed BACKGROUND_COLOR and FOG_COLOR (handled by CSS)
        // --- ADJUSTED --- Default player color
        const DEFAULT_PLAYER_COLOR = 0xADD8E6; // LightBlue
        const DEFAULT_OBSTACLE_COLOR = 0xff00ff; // Magenta (fallback)
        const SCENERY_COLORS = { DESK: 0xAF8F6D, PLANT_POT: 0xCD853F, PLANT_LEAF: 0x2E8B57 }; // Kept scenery colors

        // --- Obstacle Image Definitions ---
        const OBSTACLE_TYPES = { CC: 'cc', LIVE_CHANGE: 'live_change', ON_CALL: 'on_call' };
        const OBSTACLE_IMAGES = { [OBSTACLE_TYPES.CC]: 'CC.png', [OBSTACLE_TYPES.LIVE_CHANGE]: 'Live Change.png', [OBSTACLE_TYPES.ON_CALL]: 'On Call.png' };
        let obstacleTextures = {};

        // --- *** ADJUSTED *** Obstacle Size (Reverted to 5.0) ---
        const OBSTACLE_PLANE_WIDTH = 5.0; // Back to 5.0 as requested
        const OBSTACLE_PLANE_HEIGHT = 5.0; // Back to 5.0 as requested

        // --- DOM Elements ---
        let infoElement, mainMenuElement, scoreboardScreenElement, gameOverElement;
        let characterButtonsElement, startGameButton, viewScoresButton, backToMenuButton;
        let scoreListElement, noScoresMessageElement, finalScoreElement, gameOverReasonElement;

        // --- Texture Generation Functions (Unchanged) ---
        function createNoiseTexture(width, height, color1, color2, alpha = 1) { /* ... */ const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height; const ctx = canvas.getContext('2d'); ctx.fillStyle = color1; ctx.fillRect(0, 0, width, height); const imageData = ctx.getImageData(0, 0, width, height); const data = imageData.data; for (let i = 0; i < data.length; i += 4) { if (Math.random() > 0.85) { const shade = Math.random() * 50 + (color2 === '#000000' ? 0 : 205); data[i] = shade; data[i + 1] = shade; data[i + 2] = shade; } data[i + 3] = alpha * 255; } ctx.putImageData(imageData, 0, 0); const texture = new THREE.CanvasTexture(canvas); texture.wrapS = texture.wrapT = THREE.RepeatWrapping; return texture; }
        function createTileTexture(width, height, bgColor, lineColor, tileSize) { /* ... */ const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height; const ctx = canvas.getContext('2d'); ctx.fillStyle = bgColor; ctx.fillRect(0, 0, width, height); ctx.strokeStyle = lineColor; ctx.lineWidth = Math.max(1, Math.floor(width / 100)); ctx.beginPath(); for (let x = 0; x <= width; x += tileSize) { ctx.moveTo(x, 0); ctx.lineTo(x, height); } for (let y = 0; y <= height; y += tileSize) { ctx.moveTo(0, y); ctx.lineTo(width, y); } ctx.stroke(); const texture = new THREE.CanvasTexture(canvas); texture.wrapS = texture.wrapT = THREE.RepeatWrapping; return texture; }

        // --- Leaderboard Functions (Unchanged) ---
        function getHighScores() { /* ... */ const scoresJSON = localStorage.getItem('officeCrossingHighScores'); const scores = scoresJSON ? JSON.parse(scoresJSON) : []; scores.sort((a, b) => b.score - a.score); return scores; }
        function saveHighScores(scores) { /* ... */ scores.sort((a, b) => b.score - a.score); const topScores = scores.slice(0, MAX_HIGH_SCORES); localStorage.setItem('officeCrossingHighScores', JSON.stringify(topScores)); console.log("High scores saved:", topScores); }
        function displayHighScoresOnScreen() { /* ... */ const scores = getHighScores(); scoreListElement.innerHTML = ''; if (scores.length === 0) { noScoresMessageElement.style.display = 'block'; } else { noScoresMessageElement.style.display = 'none'; scores.forEach((scoreEntry) => { const li = document.createElement('li'); const displayName = scoreEntry.name.substring(0, 10); li.innerHTML = `<span class="name">${displayName}</span><span class="score">${scoreEntry.score}</span>`; scoreListElement.appendChild(li); }); } }

        // --- UI State Management (Unchanged) ---
        function showOverlay(overlayElement) { /* ... */ mainMenuElement.classList.add('hidden'); scoreboardScreenElement.classList.add('hidden'); gameOverElement.classList.add('hidden'); infoElement.classList.add('hidden'); if (overlayElement) { overlayElement.classList.remove('hidden'); } }

        // --- Character Selection (Unchanged) ---
        function selectCharacter(index) { /* ... */ if (index >= 0 && index < CHARACTERS.length) { selectedCharacterIndex = index; updateCharacterButtonSelection(); console.log(`Selected character: ${CHARACTERS[selectedCharacterIndex].name}`); } }
        function updateCharacterButtonSelection() { /* ... */ const buttons = characterButtonsElement.querySelectorAll('.char-button'); buttons.forEach((button, index) => { if (index === selectedCharacterIndex) button.classList.add('selected'); else button.classList.remove('selected'); }); }
        function populateCharacterButtons() { /* ... */ characterButtonsElement.innerHTML = ''; CHARACTERS.forEach((char, index) => { const button = document.createElement('button'); button.textContent = char.name; button.classList.add('char-button'); button.onclick = () => selectCharacter(index); characterButtonsElement.appendChild(button); }); updateCharacterButtonSelection(); }

        // --- Preload Assets & Materials ---
        function preloadAssets() {
            console.log("Preloading assets...");
            let maxAnisotropy = renderer ? renderer.capabilities.getMaxAnisotropy() : 1;

            // Load Character Textures (Unchanged logic)
            CHARACTERS.forEach((char, index) => { if (char.imageUrl) { characterTextures[index] = textureLoader.load(char.imageUrl, (texture) => { texture.magFilter = THREE.NearestFilter; texture.anisotropy = maxAnisotropy; texture.needsUpdate = true; console.log(`Texture loaded and filters applied for ${char.name}`); }, undefined, (err) => console.error(`Failed texture: ${char.name}`, err) ); } });

            // Load Obstacle Textures (Unchanged logic)
            for (const type in OBSTACLE_IMAGES) { const imageUrl = OBSTACLE_IMAGES[type]; obstacleTextures[type] = textureLoader.load(imageUrl, (texture) => { texture.magFilter = THREE.NearestFilter; texture.anisotropy = maxAnisotropy; texture.needsUpdate = true; console.log(`Texture loaded and filters applied for ${type}`); }, undefined, (err) => console.error(`Failed texture: ${type}`, err) ); }

            // --- *** ADJUSTED *** Lane Materials (New Colors) ---
            // Green Carpet
            const carpetTexture = createNoiseTexture(64, 64, '#90EE90', '#3CB371'); // LightGreen, MediumSeaGreen
            carpetTexture.repeat.set(8, 8); // Repeat more due to wider lanes
            laneMaterials[LANE_TYPES.CARPET] = new THREE.MeshStandardMaterial({ map: carpetTexture, roughness: 0.9, metalness: 0.05 });
            // Terracotta Walkway
            const walkwayTexture = createTileTexture(64, 64, '#E07A5F', '#D45D3D', 24); // Terracotta colors
            walkwayTexture.repeat.set(8, 8); // Repeat more
            laneMaterials[LANE_TYPES.WALKWAY] = new THREE.MeshStandardMaterial({ map: walkwayTexture, roughness: 0.4, metalness: 0.1 });

            // --- *** ADJUSTED *** Wall Material (New Color) ---
            // Using a solid warm color instead of grey texture
            wallMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFEBCD, // BlanchedAlmond
                roughness: 0.9,
                metalness: 0.0
            });

            // Scenery Materials (Unchanged)
            sceneryMaterials.desk = new THREE.MeshStandardMaterial({ color: SCENERY_COLORS.DESK, roughness: 0.8, metalness: 0.1 });
            sceneryMaterials.plantPot = new THREE.MeshStandardMaterial({ color: SCENERY_COLORS.PLANT_POT, roughness: 0.7, metalness: 0.1 });
            sceneryMaterials.plantLeaf = new THREE.MeshStandardMaterial({ color: SCENERY_COLORS.PLANT_LEAF, roughness: 0.8, metalness: 0.0 });

            console.log("Asset preloading & generation initiated.");
         }

        // --- Initialization ---
        function init() {
            // Get DOM Elements (Unchanged)
            infoElement = document.getElementById('info'); mainMenuElement = document.getElementById('mainMenu'); scoreboardScreenElement = document.getElementById('scoreboardScreen'); gameOverElement = document.getElementById('gameOver'); characterButtonsElement = document.getElementById('characterButtons'); startGameButton = document.getElementById('startGameButton'); viewScoresButton = document.getElementById('viewScoresButton'); backToMenuButton = document.getElementById('backToMenuButton'); scoreListElement = document.getElementById('scoreList'); noScoresMessageElement = document.getElementById('noScoresMessage'); finalScoreElement = document.getElementById('finalScore'); gameOverReasonElement = document.getElementById('gameOverReason');

            // Scene Setup
            scene = new THREE.Scene();
            // Removed scene.background and scene.fog - handled by CSS / no fog

            // --- *** ADJUSTED *** Camera Position ---
            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 12); // Pulled back and up for larger scale
            camera.lookAt(0, 0, 0); // Initial lookAt

            // Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // alpha: true allows CSS background to show
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;

            // Lighting Setup (Unchanged)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); scene.add(ambientLight);
            const hemiLight = new THREE.HemisphereLight( 0xE8E8FF, 0xB0B0B0, 0.6 ); scene.add( hemiLight );
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(20, 35, 25); // Adjusted light position slightly for scale
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 1; directionalLight.shadow.camera.far = 120; // Increased far plane
            directionalLight.shadow.camera.left = -60; directionalLight.shadow.camera.right = 60; // Increased shadow area
            directionalLight.shadow.camera.top = 60; directionalLight.shadow.camera.bottom = -60; // Increased shadow area
            directionalLight.shadow.bias = -0.002; scene.add(directionalLight);

            // Preload Assets
            preloadAssets();

            // --- *** ADJUSTED *** Wall Creation (Uses new laneLength) ---
            const wallHeight = 8; // Increased wall height
            const wallThickness = 1.0; // Increased wall thickness
            const wallLength = 400; // Increased wall length
            const wallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wallLength);
            const wallXOffset = laneLength / 2 + wallThickness / 2; // Uses updated laneLength
            const wallZCenter = -(generationDistance * laneWidth / 2); // Uses updated laneWidth
            const leftWall = new THREE.Mesh(wallGeometry, wallMaterial); // Use single material instance
            leftWall.position.set(-wallXOffset, wallHeight / 2, wallZCenter);
            leftWall.receiveShadow = true; scene.add(leftWall);
            const rightWall = new THREE.Mesh(wallGeometry, wallMaterial); // Use single material instance
            rightWall.position.set(wallXOffset, wallHeight / 2, wallZCenter);
            rightWall.receiveShadow = true; scene.add(rightWall);

            // UI Setup (Unchanged logic)
            if (characterButtonsElement) populateCharacterButtons(); else console.error("characterButtonsElement not found!");
            if (startGameButton) startGameButton.onclick = startGame; else console.error("startGameButton not found!");
            if (viewScoresButton) viewScoresButton.onclick = () => { displayHighScoresOnScreen(); currentGameState = GAME_STATE.SHOW_SCORES; showOverlay(scoreboardScreenElement); }; else console.error("viewScoresButton not found!");
            if (backToMenuButton) backToMenuButton.onclick = goToMenu; else console.error("backToMenuButton not found!");

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);

            // Initial State
            goToMenu();
            animate(); // Start animation loop
         }

        // --- Game Start Logic (Unchanged logic, uses new camera pos) ---
        function startGame() { /* ... */ console.log("Starting game..."); score = 0; playerPosition = { x: 0, z: 0 }; targetPlayerPosition = { x: 0, z: 0 }; lastLaneZ = 0; isMoving = false; infoElement.innerText = `Score: ${score}`; lastMoveTime = clock.elapsedTime; clearGameObjects(); createPlayer(); createLane(LANE_TYPES.CARPET, 0); for (let i = 1; i < generationDistance; i++) generateLane(); camera.position.set(0, 15, 12); camera.lookAt(0, 0, 0); currentGameState = GAME_STATE.PLAYING; showOverlay(null); infoElement.classList.remove('hidden'); if (!clock.running) clock.start(); if (!animationFrameId) animate(); }

        // --- Clear Game Objects (Unchanged) ---
        function clearGameObjects() { /* ... */ console.log("Clearing game objects..."); for (let i = obstacles.length - 1; i >= 0; i--) if (obstacles[i].mesh.parent) scene.remove(obstacles[i].mesh); obstacles = []; for (let i = lanes.length - 1; i >= 0; i--) if (lanes[i].mesh.parent) scene.remove(lanes[i].mesh); lanes = []; for (let i = scenery.length - 1; i >= 0; i--) if (scenery[i].parent) scene.remove(scenery[i]); scenery = []; if (player && player.parent) scene.remove(player); player = null; playerBoundingBox = null; }

        // --- Create Player (Uses adjusted character sizes) ---
        function createPlayer() {
            const character = CHARACTERS[selectedCharacterIndex];
            // Use updated playerW/H from CHARACTERS array
            const playerW = character.width;
            const playerH = character.height;
            const playerBaseY = playerH / 2;
            let playerMaterial, playerGeometry;

            if (character.imageUrl && characterTextures[selectedCharacterIndex]) {
                playerGeometry = new THREE.PlaneGeometry(playerW, playerH);
                playerMaterial = new THREE.MeshBasicMaterial({ map: characterTextures[selectedCharacterIndex], transparent: true, side: THREE.DoubleSide }); // DoubleSide might be needed for planes
                console.log(`Using texture (Basic) for ${character.name}`);
            } else {
                playerGeometry = new THREE.BoxGeometry(playerW, playerH, playerW * 0.8); // Make default cube slightly thinner
                playerMaterial = new THREE.MeshStandardMaterial({ color: DEFAULT_PLAYER_COLOR, roughness: 0.6 });
                console.log(`Using default cube for ${character.name}`);
            }
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(playerPosition.x, playerBaseY, playerPosition.z);
            player.castShadow = true; player.receiveShadow = false; scene.add(player);
            // Adjust bounding box calculation slightly for plane geometry if used
            if (player.geometry.type === 'PlaneGeometry') {
                 playerBoundingBox = new THREE.Box3().setFromCenterAndSize(
                    player.position,
                    new THREE.Vector3(playerW, playerH, 0.5) // Give plane a small depth for collision
                 );
            } else {
                playerBoundingBox = new THREE.Box3().setFromObject(player);
            }
         }

        // --- Lane Generation Functions (Uses new laneWidth/Length) ---
        function createLane(type, zPos) {
            // Use updated laneLength and laneWidth
            const laneGeometry = new THREE.PlaneGeometry(laneLength, laneWidth);
            const laneMaterial = laneMaterials[type] || new THREE.MeshStandardMaterial({color: 0xff00ff});
            let laneData = { mesh: null, type: type, z: zPos, obstacles: [] };
            const laneMesh = new THREE.Mesh(laneGeometry, laneMaterial);
            laneMesh.rotation.x = -Math.PI / 2;
            laneMesh.position.set(0, 0, zPos);
            laneMesh.receiveShadow = true;
            scene.add(laneMesh);
            laneData.mesh = laneMesh;
            lanes.push(laneData);
            // Add obstacles/scenery based on type
            if (type === LANE_TYPES.WALKWAY && zPos < -laneWidth) { // Don't spawn on first few lanes
                 addObstaclesToLane(laneData);
            } else if (type === LANE_TYPES.CARPET) {
                const sceneryChance = 0.20; // Slightly higher chance for scenery on wider lanes
                if (Math.random() < sceneryChance) addSceneryToLane(laneData);
            }
            lastLaneZ = zPos; // Update last generated Z
            return laneData;
        }
        function generateLane() {
            // Use updated laneWidth
            const nextZ = lastLaneZ - laneWidth;
            // Keep walkway probability logic
            const probabilityOfWalkway = Math.max(0.55, Math.min(0.9, 0.55 + Math.abs(nextZ / (70 * (laneWidth/2) )))); // Adjust divisor based on new width
            const laneType = Math.random() < probabilityOfWalkway ? LANE_TYPES.WALKWAY : LANE_TYPES.CARPET;
            createLane(laneType, nextZ);
        }
        // --- *** ADJUSTED *** Scenery Generation (Scaled up sizes) ---
        function addSceneryToLane(laneData) {
             const sceneryType = Math.random() < 0.6 ? 'desk' : 'plant';
             let sceneryMesh;
             const side = Math.random() < 0.5 ? -1 : 1;
             // Adjust X offset based on new laneLength
             const xOffset = (laneLength / 3) + (Math.random() * laneLength / 4); // Place further out
             const sceneryX = xOffset * side;
             // Keep Z offset logic relative to lane width
             const sceneryZ = laneData.z + (Math.random() - 0.5) * laneWidth * 0.8;

             if (sceneryType === 'desk') {
                 // Increased desk size
                 const deskHeight = 1.2; // Was 0.8
                 const deskGeo = new THREE.BoxGeometry(2.5, deskHeight, 1.2); // Was 1.5, deskHeight, 0.8
                 sceneryMesh = new THREE.Mesh(deskGeo, sceneryMaterials.desk);
                 sceneryMesh.position.set(sceneryX, deskHeight / 2, sceneryZ);
             } else { // Plant
                 // Increased plant size
                 const potHeight = 0.8; // Was 0.5
                 const potRadius = 0.5; // Was 0.3
                 const potGeo = new THREE.CylinderGeometry(potRadius * 0.8, potRadius, potHeight, 12); // Increased segments
                 const potMesh = new THREE.Mesh(potGeo, sceneryMaterials.plantPot);
                 potMesh.position.set(sceneryX, potHeight / 2, sceneryZ);

                 const leafHeight = 1.0; // Was 0.6
                 const leafGeo = new THREE.ConeGeometry(potRadius * 1.2, leafHeight, 8); // Increased segments
                 const leafMesh = new THREE.Mesh(leafGeo, sceneryMaterials.plantLeaf);
                 leafMesh.position.set(sceneryX, potHeight + leafHeight / 2, sceneryZ);

                 sceneryMesh = new THREE.Group(); // Group pot and leaves
                 sceneryMesh.add(potMesh);
                 sceneryMesh.add(leafMesh);
             }
             sceneryMesh.castShadow = true;
             sceneryMesh.receiveShadow = true;
             scene.add(sceneryMesh);
             scenery.push(sceneryMesh); // Add to scenery array for cleanup
         }

        // --- Obstacle Generation (Uses reverted 5.0 size, adjusted density/spacing) ---
        function addObstaclesToLane(laneData) {
             // Keep adjusted density logic
             const maxObstacles = Math.min(3, 1 + Math.floor(score / 15));
             const numObstacles = Math.floor(Math.random() * maxObstacles) + 1;

             const speedMultiplier = 1 + Math.min(1.5, score / 80);
             const baseSpeed = (0.08 + Math.random() * 0.10) * speedMultiplier; // Slightly faster base speed for wider lanes
             const speed = baseSpeed * (Math.random() < 0.5 ? 1 : -1);
             const direction = Math.sign(speed);
             // Use updated laneLength for start edge
             const startEdge = (laneLength / 2 + 5) * direction * -1; // Start further off screen
             // --- ADJUSTED --- Spacing based on large obstacle size
             const minSpacing = OBSTACLE_PLANE_WIDTH + 2.0; // Min space = obstacle width + buffer
             const totalSpacingNeeded = (numObstacles -1) * minSpacing;
             // Use updated laneLength for spacing pool
             const randomSpacingPool = Math.max(0, laneLength - totalSpacingNeeded - OBSTACLE_PLANE_WIDTH * numObstacles); // Available space
             let currentX = startEdge;
             const availableObstacleTypes = Object.keys(OBSTACLE_TYPES);

             for (let i = 0; i < numObstacles; i++) {
                 const randomTypeKey = availableObstacleTypes[Math.floor(Math.random() * availableObstacleTypes.length)];
                 const obstacleType = OBSTACLE_TYPES[randomTypeKey];
                 const obstacleTexture = obstacleTextures[obstacleType];

                 // --- Use reverted W/H constants ---
                 const obstacleW = OBSTACLE_PLANE_WIDTH; // 5.0
                 const obstacleH = OBSTACLE_PLANE_HEIGHT; // 5.0
                 const obstacleYPosition = obstacleH / 2;

                 const obstacleGeometry = new THREE.PlaneGeometry(obstacleW, obstacleH);
                 const obstacleMaterial = new THREE.MeshBasicMaterial({
                     map: obstacleTexture || null,
                     color: obstacleTexture ? 0xffffff : DEFAULT_OBSTACLE_COLOR,
                     transparent: true,
                     side: THREE.DoubleSide // Important for planes
                 });
                 const obstacleMesh = new THREE.Mesh(obstacleGeometry, obstacleMaterial);

                 // Position obstacles with adjusted minimum spacing
                 if (i > 0) {
                     const spacingToAdd = minSpacing + (numObstacles > 1 ? Math.random() * (randomSpacingPool / (numObstacles - 1)) : 0);
                     currentX -= spacingToAdd * direction;
                 } else {
                     // Adjust starting position slightly for first obstacle if needed
                     currentX -= (Math.random() * (randomSpacingPool / numObstacles)) * direction;
                 }

                 obstacleMesh.position.set(currentX, obstacleYPosition, laneData.z);
                 obstacleMesh.castShadow = true;
                 obstacleMesh.receiveShadow = false;
                 scene.add(obstacleMesh);

                 // Bounding box for collision (give plane depth)
                 const obstacleBoundingBox = new THREE.Box3().setFromCenterAndSize(
                    obstacleMesh.position,
                    new THREE.Vector3(obstacleW, obstacleH, 0.5) // Use small depth
                 );
                 const obstacleData = {
                     mesh: obstacleMesh,
                     boundingBox: obstacleBoundingBox,
                     speed: speed,
                     direction: direction,
                     laneZ: laneData.z,
                     type: obstacleType
                 };
                 obstacles.push(obstacleData);
                 laneData.obstacles.push(obstacleData);
             }
         }

        // --- Game Loop (Unchanged logic) ---
        function animate() { /* ... */ animationFrameId = requestAnimationFrame(animate); const deltaTime = clock.getDelta(); if (currentGameState === GAME_STATE.PLAYING && !isMoving) { const idleTime = clock.elapsedTime - lastMoveTime; if (idleTime > MAX_IDLE_TIME) { console.log("Idle time exceeded!"); triggerGameOver("idle"); } } if (currentGameState === GAME_STATE.PLAYING) { movePlayerVisually(deltaTime); moveObstacles(); checkCollisions(); updateCamera(); if (player && player.position.z < lastLaneZ + (generationDistance * laneWidth)) generateLane(); cleanupEnvironment(); } else if (currentGameState === GAME_STATE.GAME_OVER) { if (player && player.scale.x > 0.01) player.scale.multiplyScalar(0.9); else if (player) player.scale.set(0,0,0); } renderer.render(scene, camera); }

        // --- Player Movement (Uses adjusted character sizes & hop) ---
        function movePlayerVisually(deltaTime) {
             if (!player || !isMoving) return;
             const character = CHARACTERS[selectedCharacterIndex];
             const playerBaseY = character.height / 2; // Use updated height
             const elapsedTime = clock.elapsedTime * 1000 - moveStartTime;
             let progress = Math.min(1.0, elapsedTime / moveDuration);
             const easedProgress = progress * (2 - progress); // Ease out quad

             const startVec = new THREE.Vector3(playerPosition.x, playerBaseY, playerPosition.z);
             const endVec = new THREE.Vector3(targetPlayerPosition.x, playerBaseY, targetPlayerPosition.z);

             player.position.lerpVectors(startVec, endVec, easedProgress);

             const hopHeight = 1.0; // Increased hop height for larger player
             player.position.y = playerBaseY + Math.sin(progress * Math.PI) * hopHeight;

             if (progress >= 1.0) {
                 player.position.copy(endVec);
                 player.position.y = playerBaseY;
                 isMoving = false;
                 playerPosition.x = targetPlayerPosition.x;
                 playerPosition.z = targetPlayerPosition.z;
                 // Update bounding box after move
                 if (player) {
                     if (player.geometry.type === 'PlaneGeometry') {
                         playerBoundingBox.setFromCenterAndSize(player.position, new THREE.Vector3(character.width, character.height, 0.5));
                     } else {
                         playerBoundingBox.setFromObject(player);
                     }
                 }
             }
         }

        // --- Other Functions (Obstacle Move, Camera, Collision, Cleanup, Controls, State, Util) ---
        // --- *** ADJUSTED *** Obstacle Move (Uses new laneLength) ---
        function moveObstacles() {
             const wrapEdge = laneLength / 2 + 5; // Use updated laneLength, increased buffer
             obstacles.forEach(obstacle => {
                 let currentSpeed = obstacle.speed;
                 obstacle.mesh.position.x += currentSpeed;
                 // Wrap around logic
                 if (obstacle.direction > 0 && obstacle.mesh.position.x > wrapEdge) {
                     obstacle.mesh.position.x = -wrapEdge;
                 } else if (obstacle.direction < 0 && obstacle.mesh.position.x < -wrapEdge) {
                     obstacle.mesh.position.x = wrapEdge;
                 }
                 // Update bounding box position
                 obstacle.boundingBox.setFromCenterAndSize(
                     obstacle.mesh.position,
                     new THREE.Vector3(OBSTACLE_PLANE_WIDTH, OBSTACLE_PLANE_HEIGHT, 0.5)
                 );
             });
         }
        // --- *** ADJUSTED *** Camera Update (Smoother follow for larger scale) ---
        function updateCamera() {
             if (!player) return;
             // Target position slightly higher and further back
             const targetCameraPosition = new THREE.Vector3( player.position.x, camera.position.y, player.position.z + 10 ); // Was +7
             // Slower lerp for smoother feel
             camera.position.lerp(targetCameraPosition, 0.04); // Was 0.06

             // Target lookAt adjusted for player height and distance
             const targetLookAt = new THREE.Vector3( player.position.x, player.position.y * 0.5, player.position.z - 8 ); // Was -6, look lower
             const currentLookAt = new THREE.Vector3();
             camera.getWorldDirection(currentLookAt).multiplyScalar(15).add(camera.position); // Look further ahead
             currentLookAt.lerp(targetLookAt, 0.05); // Slower lookAt lerp
             camera.lookAt(currentLookAt);
         }
        // Collision Check (Uses updated bounding boxes) - Logic remains similar
        function checkCollisions() {
             if (!player || isMoving || currentGameState !== GAME_STATE.PLAYING) { return; }
             // Ensure player bounding box is up-to-date
             if (player.geometry.type === 'PlaneGeometry') {
                 const character = CHARACTERS[selectedCharacterIndex];
                 playerBoundingBox.setFromCenterAndSize(player.position, new THREE.Vector3(character.width, character.height, 0.5));
             } else {
                 playerBoundingBox.setFromObject(player);
             }

             obstacles.forEach(obstacle => {
                 // Check Z proximity first for minor optimization
                 if (Math.abs(player.position.z - obstacle.laneZ) < laneWidth / 2) {
                     // Check intersection
                     if (playerBoundingBox.intersectsBox(obstacle.boundingBox)) {
                         console.log("Collision Detected!");
                         triggerGameOver("collision");
                     }
                 }
             });
         }
        // Cleanup (Uses updated laneWidth) - Logic remains similar
        function cleanupEnvironment() {
             const cleanupThresholdZ = (player ? player.position.z : 0) + (cleanupBuffer * laneWidth); // Uses updated laneWidth
             lanes = lanes.filter(lane => { if (lane.z < cleanupThresholdZ) return true; else { lane.obstacles.forEach(obstacle => { const index = obstacles.indexOf(obstacle); if (index > -1) obstacles.splice(index, 1); if (obstacle.mesh.parent) scene.remove(obstacle.mesh); }); if (lane.mesh.parent) scene.remove(lane.mesh); return false; } });
             obstacles = obstacles.filter(obstacle => { if (obstacle.laneZ < cleanupThresholdZ) return true; else { if (obstacle.mesh.parent) scene.remove(obstacle.mesh); return false; } });
             scenery = scenery.filter(item => { if (item.position.z < cleanupThresholdZ) return true; else { if (item.parent) scene.remove(item); return false; } });
         }
        // Controls (Uses updated laneWidth/Length) - Logic remains similar
        function onKeyDown(event) {
             if (currentGameState !== GAME_STATE.PLAYING || isMoving) return;
             let moved = false;
             const currentX = playerPosition.x;
             const currentZ = playerPosition.z;
             // Use updated laneWidth for movement distance
             const moveAmount = laneWidth;

             switch (event.key) {
                 case 'ArrowUp': case 'w':
                     targetPlayerPosition.z = currentZ - moveAmount;
                     targetPlayerPosition.x = currentX;
                     score++; infoElement.innerText = `Score: ${score}`; moved = true; break;
                 case 'ArrowLeft': case 'a':
                     targetPlayerPosition.x = currentX - moveAmount;
                     targetPlayerPosition.z = currentZ; moved = true; break;
                 case 'ArrowRight': case 'd':
                     targetPlayerPosition.x = currentX + moveAmount;
                     targetPlayerPosition.z = currentZ; moved = true; break;
                 case 'ArrowDown': case 's':
                     targetPlayerPosition.z = currentZ + moveAmount;
                     targetPlayerPosition.x = currentX; moved = true; break;
             }
             // Check boundaries using updated laneLength
             const nextX = targetPlayerPosition.x;
             const wallBoundary = laneLength / 2 - player.geometry.parameters.width / 2; // Adjust boundary for player width
             if (moved && (nextX > wallBoundary || nextX < -wallBoundary)) {
                 moved = false; // Prevent moving past walls
                 targetPlayerPosition.x = currentX;
                 targetPlayerPosition.z = currentZ;
             }
             if (moved) {
                 isMoving = true;
                 moveStartTime = clock.elapsedTime * 1000;
                 lastMoveTime = clock.elapsedTime;
             }
         }
        // Game Over, Menu, Resize (Unchanged logic)
        function triggerGameOver(reason = "collision") { /* ... */ if (currentGameState !== GAME_STATE.PLAYING) return; currentGameState = GAME_STATE.GAME_OVER; console.log(`Game Over! Score: ${score}, Reason: ${reason}`); finalScoreElement.innerText = score; if (reason === "idle") { gameOverReasonElement.innerText = "Took too long!"; } else { gameOverReasonElement.innerText = "Deadline Missed!"; } showOverlay(gameOverElement); const highScores = getHighScores(); const scoreNeeded = highScores.length < MAX_HIGH_SCORES ? 0 : highScores[MAX_HIGH_SCORES - 1].score; if (score > 0 && score >= scoreNeeded) { const characterName = CHARACTERS[selectedCharacterIndex].name; console.log(`New Top 3 Score with character: ${characterName}`); highScores.push({ name: characterName, score: score }); saveHighScores(highScores); console.log("New high score saved!"); } }
        function goToMenu() { /* ... */ currentGameState = GAME_STATE.MENU; showOverlay(mainMenuElement); }
        function onWindowResize() { /* ... */ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        // --- Start the application ---
        document.addEventListener('DOMContentLoaded', (event) => {
            console.log("DOM fully loaded and parsed");
            init();
        });

    </script>
</body>
</html>

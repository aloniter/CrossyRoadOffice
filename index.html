<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Office Crossing Challenge - Firebase Edition!</title>
    <style>
        /* Basic styling for the game elements */
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            font-family: sans-serif;
            background: linear-gradient(to bottom, #87CEEB, #B0E0E6); /* Light blue gradient background */
            color: #333;
            height: 100vh; /* Full viewport height */
        }
        canvas {
            display: block; /* Remove extra space below canvas */
        }
        /* Styling for overlay menus (Main Menu, Scoreboard, Game Over) */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background-color: rgba(0, 0, 0, 0.75); /* Semi-transparent black background */
            color: white;
            z-index: 100; /* Ensure overlays are on top */
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
        }
        .hidden {
            display: none; /* Class to hide overlays */
        }
        .overlay-content {
            background-color: rgba(40, 60, 80, 0.9); /* Darker, slightly transparent box for content */
            padding: 30px 40px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4); /* Drop shadow */
            max-width: 90%;
            width: 450px; /* Fixed width for the content box */
        }
        .overlay h2 {
            margin-top: 0;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.5); /* Separator line */
            padding-bottom: 10px;
            color: #FFD700; /* Gold color for headings */
        }
        .overlay button {
            display: block;
            width: 80%;
            margin: 15px auto; /* Center buttons */
            padding: 12px 20px;
            font-size: 18px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background-color: #4682B4; /* Steel blue button */
            color: white;
            transition: background-color 0.3s, transform 0.1s; /* Smooth transitions */
            box-shadow: 0 4px 6px rgba(0,0,0,0.2); /* Button shadow */
        }
        .overlay button:hover {
            background-color: #5A9BD5; /* Lighter blue on hover */
        }
        .overlay button:active {
            transform: scale(0.95); /* Slight shrink effect on click */
            background-color: #41729F; /* Darker blue on click */
        }
        /* Character Selection Specific Styles */
        #mainMenu .character-selection {
            margin-bottom: 20px;
            padding: 10px;
            background-color: rgba(255,255,255,0.1); /* Slightly lighter background for selection area */
            border-radius: 8px;
            max-height: 250px; /* Limit height and allow scrolling */
            overflow-y: auto;
        }
        #mainMenu .character-selection h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 16px;
        }
        #mainMenu .char-button {
            display: inline-block; /* Allow buttons side-by-side */
            width: auto; /* Fit content */
            padding: 8px 15px;
            margin: 5px;
            font-size: 14px;
            border: 2px solid transparent; /* Border for selection indicator */
            background-color: #6c757d; /* Grey button */
        }
        #mainMenu .char-button.selected {
            border-color: #FFD700; /* Gold border for selected character */
            background-color: #4682B4; /* Blue background for selected */
        }
        /* Scoreboard Specific Styles */
        #scoreboardScreen ol {
            margin: 0 0 15px 0;
            padding: 0 0 0 25px; /* Indent list items */
            list-style-position: outside;
            max-height: 150px; /* Limit height and allow scrolling */
            overflow-y: auto;
        }
        #scoreboardScreen li {
            margin-bottom: 8px;
            white-space: nowrap; /* Prevent wrapping */
            overflow: hidden; /* Hide overflow */
            text-overflow: ellipsis; /* Add ... for long names */
            font-size: 16px;
            border-bottom: 1px dotted rgba(255, 255, 255, 0.2); /* Dotted separator */
            padding-bottom: 4px;
        }
        #scoreboardScreen li:last-child {
            border-bottom: none; /* Remove border from last item */
        }
        #scoreboardScreen li span {
            display: inline-block; /* Needed for positioning */
        }
        #scoreboardScreen li .score {
            float: right; /* Align score to the right */
            font-weight: bold;
            margin-left: 15px;
        }
        #scoreboardScreen .no-scores {
            text-align: center;
            font-style: italic;
            color: #ccc; /* Lighter color for message */
            margin-top: 10px;
        }
        /* In-Game Score Display */
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            width: auto;
            text-align: left;
            z-index: 50; /* Below overlays */
            display: block;
            color: #000080; /* Navy blue text */
            font-size: 24px;
            font-weight: bold;
            text-shadow: 1px 1px 1px #FFFFFF; /* White text shadow for readability */
            background-color: rgba(255, 255, 255, 0.6); /* Semi-transparent white background */
            padding: 5px 10px;
            border-radius: 5px;
        }
        /* Game Over Specific Styles */
        #gameOver {
            z-index: 101; /* Ensure Game Over is on top if needed */
        }
        #gameOverReason {
            font-size: 24px;
            margin-bottom: 15px;
            font-style: italic;
            color: #ffdddd; /* Light red color for the reason */
        }
    </style>
</head>
<body>
    <div id="info" class="hidden">Score: 0</div>

    <div id="mainMenu" class="overlay">
        <div class="overlay-content">
            <h2>Ops & QA Crossing Challenge</h2>
            <div class="character-selection">
                <h3>Select Character</h3>
                <div id="characterButtons"></div> </div>
            <button id="startGameButton">Start Game</button>
            <button id="viewScoresButton">High Scores</button>
        </div>
    </div>

    <div id="scoreboardScreen" class="overlay hidden">
        <div class="overlay-content">
            <h2>High Scores</h2>
            <ol id="scoreList"></ol> <div id="noScoresMessage" class="no-scores" style="display: none;">Loading scores...</div>
            <button id="backToMenuButton">Back to Menu</button>
        </div>
    </div>

    <div id="gameOver" class="overlay hidden">
        <div class="overlay-content">
            <h2 id="gameOverReason">You lost, go back to work!</h2>
            Final Score: <span id="finalScore">0</span><br>
            <button onclick="goToMenu()">Main Menu</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-firestore-compat.js"></script>

    <script>
        // --- Firebase Configuration ---
        // IMPORTANT: Replace with your actual Firebase project configuration!
        const firebaseConfig = {
            apiKey: "AIzaSyCEVtcw6InjPAtT6qRDnMNNciNAVhMIBhM", // Keep this secure if possible, consider environment variables for real apps
            authDomain: "office-crossing-game.firebaseapp.com",
            projectId: "office-crossing-game",
            storageBucket: "office-crossing-game.firebasestorage.app",
            messagingSenderId: "1060039127140",
            appId: "1:1060039127140:web:d7e01f6f64e97b4fcb6f71"
        };

        // --- Initialize Firebase ---
        try {
            firebase.initializeApp(firebaseConfig);
        } catch (e) {
            console.error("Firebase initialization failed:", e);
            alert("Could not connect to Firebase. High scores may not work.");
        }
        const db = firebase.firestore(); // Get a Firestore instance
        const highScoresCollection = db.collection('highscores'); // Reference to the 'highscores' collection

        // --- Game States ---
        const GAME_STATE = { MENU: 'menu', PLAYING: 'playing', GAME_OVER: 'game_over', SHOW_SCORES: 'show_scores' };
        let currentGameState = GAME_STATE.MENU;

        // --- Global Game Variables ---
        let scene, camera, renderer; // Three.js core components
        let player, playerBoundingBox; // Player object and its collision box
        let lanes = []; // Array to hold lane data
        let obstacles = []; // Array to hold obstacle data
        let score = 0; // Current game score
        let scenery = []; // Array for decorative scenery objects
        let safeSpots = []; // Array for safe spots on water lanes
        let wallSegments = []; // Array for the side walls
        let laneWidth = 6; // Width of each lane
        let laneLength = 80; // Length of the visible lane area (affects wall placement)
        let playerPosition = { x: 0, z: 0 }; // Logical position of the player
        let targetPlayerPosition = { x: 0, z: 0 }; // Target position for smooth movement
        let isMoving = false; // Flag to indicate if the player is currently animating a move
        let moveDuration = 150; // Duration of player move animation in milliseconds
        let moveStartTime = 0; // Timestamp when the current move started
        let lastLaneZ = 0; // Z-position of the furthest generated lane
        let generationDistance = 20; // How many lanes ahead to generate
        let cleanupBuffer = 5; // How many lanes behind the player to keep before removing
        let clock = new THREE.Clock(); // Three.js clock for delta time
        let textureLoader = new THREE.TextureLoader(); // For loading image textures
        const MAX_HIGH_SCORES = 3; // Number of high scores to store and display
        let animationFrameId = null; // ID for the requestAnimationFrame loop
        let laneMaterials = {}; // Cache for lane materials
        let wallMaterial; // Material for side walls
        let sceneryMaterials = {}; // Cache for scenery materials
        let lastMoveTime = 0; // Timestamp of the last player move (for idle check)
        const MAX_IDLE_TIME = 5.0; // Maximum time (seconds) player can be idle before game over
        let directionalLight; // Main light source for shadows

        // --- Wall Constants ---
        const WALL_HEIGHT = 8;
        const WALL_THICKNESS = 1.0;

        // --- Character Definitions ---
        // Add or remove characters here. Ensure image paths are correct relative to the HTML file.
        const CHARACTERS = [
             { name: 'Alon', imageUrl: 'Alon.png', width: 2.8, height: 3.36 },
             { name: 'Sahar', imageUrl: 'Sahar.png', width: 2.8, height: 3.36 },
             { name: 'Mor', imageUrl: 'Mor.png', width: 2.8, height: 3.36 },
             { name: 'Lin', imageUrl: 'Lin.png', width: 2.8, height: 3.36 },
             { name: 'Asaf', imageUrl: 'Asaf.png', width: 2.8, height: 3.36 },
             { name: 'Tal', imageUrl: 'Tal.png', width: 2.8, height: 3.36 },
             { name: 'Ron', imageUrl: 'Ron.png', width: 2.8, height: 3.36 },
             { name: 'Hadar', imageUrl: 'Hadar.png', width: 2.8, height: 3.36 },
             { name: 'Adi', imageUrl: 'Adi.png', width: 2.8, height: 3.36 },
             { name: 'Alex', imageUrl: 'Alex.png', width: 2.8, height: 3.36 },
             { name: 'Amit', imageUrl: 'Amit.png', width: 2.8, height: 3.36 },
             { name: 'Anna', imageUrl: 'Anna.png', width: 2.8, height: 3.36 },
             { name: 'May Boss', imageUrl: 'May Boss.png', width: 2.8, height: 3.36 },
             { name: 'May QA', imageUrl: 'May QA.png', width: 2.8, height: 3.36 },
             { name: 'Ofek', imageUrl: 'Ofek.png', width: 2.8, height: 3.36 },
             { name: 'Default', imageUrl: null, width: 2.2, height: 2.2 } // Fallback if images fail
        ];
        let selectedCharacterIndex = 0; // Index of the currently selected character
        let characterTextures = {}; // Cache for loaded character textures

        // --- Theme Constants & Colors ---
        const LANE_TYPES = { CARPET: 'carpet', WALKWAY: 'walkway', WATER: 'water' };
        const DEFAULT_PLAYER_COLOR = 0xADD8E6; // Light blue for default player
        const DEFAULT_OBSTACLE_COLOR = 0xff00ff; // Magenta for default obstacle
        const SCENERY_COLORS = { DESK: 0xAF8F6D, PLANT_POT: 0xCD853F, PLANT_LEAF: 0x2E8B57 };
        const SAFE_SPOT_COLOR = 0x90EE90; // Light green for safe spots on water
        const WATER_COLOR = 0x1E90FF; // Dodger blue for water

        // --- Obstacle Definitions ---
        // Add or remove obstacle types here. Ensure image paths are correct.
        const OBSTACLE_TYPES = { CC: 'cc', LIVE_CHANGE: 'live_change', ON_CALL: 'on_call' };
        const OBSTACLE_IMAGES = {
            [OBSTACLE_TYPES.CC]: { right: 'CC.png', left: 'CC R.png' },
            [OBSTACLE_TYPES.LIVE_CHANGE]: { right: 'Live Change.png', left: 'Live Change R.png' },
            [OBSTACLE_TYPES.ON_CALL]: { right: 'On Call.png', left: 'On Call R.png' }
        };
        let obstacleTextures = {}; // Cache for loaded obstacle textures
        const OBSTACLE_PLANE_WIDTH = 5.0; // Visual width of obstacle planes
        const OBSTACLE_PLANE_HEIGHT = 5.0; // Visual height of obstacle planes

        // --- DOM Element References ---
        let infoElement, mainMenuElement, scoreboardScreenElement, gameOverElement;
        let characterButtonsElement, startGameButton, viewScoresButton, backToMenuButton;
        let scoreListElement, noScoresMessageElement, finalScoreElement, gameOverReasonElement;

        // --- Texture Generation Functions (Procedural textures for variety) ---
        function createNoiseTexture(width, height, color1, color2, alpha = 1) {
            // Creates a simple noise texture programmatically
            const canvas = document.createElement('canvas');
            canvas.width = width; canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color1;
            ctx.fillRect(0, 0, width, height);
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                if (Math.random() > 0.85) { // Add random darker pixels
                    const shade = Math.random() * 50 + (color2 === '#000000' ? 0 : 205);
                    data[i] = shade; data[i + 1] = shade; data[i + 2] = shade;
                }
                data[i + 3] = alpha * 255; // Set alpha
            }
            ctx.putImageData(imageData, 0, 0);
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping; // Allow texture tiling
            return texture;
        }
        function createTileTexture(width, height, bgColor, lineColor, tileSize) {
            // Creates a simple tile pattern texture programmatically
            const canvas = document.createElement('canvas');
            canvas.width = width; canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, width, height);
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = Math.max(1, Math.floor(width / 100)); // Line thickness relative to texture size
            ctx.beginPath();
            for (let x = 0; x <= width; x += tileSize) { ctx.moveTo(x, 0); ctx.lineTo(x, height); } // Vertical lines
            for (let y = 0; y <= height; y += tileSize) { ctx.moveTo(0, y); ctx.lineTo(width, y); } // Horizontal lines
            ctx.stroke();
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping; // Allow texture tiling
            return texture;
        }

        // --- Firebase Leaderboard Functions ---

        /**
         * Fetches the top high scores from Firebase Firestore and displays them.
         * Uses async/await for cleaner asynchronous code.
         */
        async function fetchAndDisplayHighScores() {
            console.log("Fetching high scores from Firebase...");
            scoreListElement.innerHTML = ''; // Clear previous scores list
            noScoresMessageElement.textContent = 'Loading scores...'; // Show loading indicator
            noScoresMessageElement.style.display = 'block';

            try {
                // Query Firestore for documents in 'highscores' collection
                const querySnapshot = await highScoresCollection
                    .orderBy('score', 'desc') // Order by score, highest first
                    .limit(MAX_HIGH_SCORES)   // Limit to the top N scores
                    .get();                   // Execute the query

                const scores = [];
                querySnapshot.forEach((doc) => {
                    // Extract data from each document
                    scores.push(doc.data());
                });

                console.log("Scores fetched:", scores);

                if (scores.length === 0) {
                    // Display message if no scores are found
                    noScoresMessageElement.textContent = 'No scores yet!';
                    noScoresMessageElement.style.display = 'block';
                } else {
                    // Hide loading message and display scores
                    noScoresMessageElement.style.display = 'none';
                    scores.forEach((scoreEntry) => {
                        const li = document.createElement('li');
                        // Sanitize and shorten name display
                        const displayName = scoreEntry.name ? String(scoreEntry.name).substring(0, 15) : 'Anonymous';
                        // Use innerHTML carefully (ensure scoreEntry.score is a number)
                        li.innerHTML = `<span class="name">${displayName}</span><span class="score">${Number(scoreEntry.score) || 0}</span>`;
                        scoreListElement.appendChild(li);
                    });
                }
            } catch (error) {
                console.error("Error fetching high scores: ", error);
                noScoresMessageElement.textContent = 'Error loading scores.'; // Show error message
                noScoresMessageElement.style.display = 'block';
            }
        }

        /**
         * Saves a score to Firebase Firestore if it qualifies for the top list.
         * Manages the size of the high score list.
         * Uses async/await.
         * @param {string} playerName - The name of the player.
         * @param {number} newScore - The score achieved by the player.
         */
        async function saveScoreIfHighScore(playerName, newScore) {
            const nameToSave = playerName ? String(playerName).substring(0, 20) : 'Anonymous'; // Sanitize/limit name length
            const scoreToSave = Number(newScore) || 0; // Ensure score is a number

            console.log(`Checking if score ${scoreToSave} for ${nameToSave} is a high score...`);
            if (scoreToSave <= 0) {
                console.log("Score is 0 or less, not saving.");
                return; // Don't save zero or negative scores
            }

            try {
                // Get current top scores to determine if the new score is high enough
                const querySnapshot = await highScoresCollection
                    .orderBy('score', 'desc')
                    .limit(MAX_HIGH_SCORES)
                    .get();

                const currentTopScores = [];
                querySnapshot.forEach(doc => currentTopScores.push({ id: doc.id, ...doc.data() }));

                const lowestTopScore = currentTopScores.length > 0 ? (Number(currentTopScores[currentTopScores.length - 1].score) || 0) : 0;
                const isHighScore = scoreToSave > lowestTopScore || currentTopScores.length < MAX_HIGH_SCORES;

                if (isHighScore) {
                    console.log(`New high score! Saving ${nameToSave}: ${scoreToSave}`);
                    // Add the new high score document
                    await highScoresCollection.add({
                        name: nameToSave,
                        score: scoreToSave,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp() // Optional: record time
                    });
                    console.log("New score added to Firestore.");

                    // --- Pruning Logic: Keep only the top MAX_HIGH_SCORES ---
                    // After adding, check if we exceed the limit and remove the lowest score(s).
                    // This is slightly less efficient than checking before adding but simpler to implement.
                    const allScoresSnapshot = await highScoresCollection
                        .orderBy('score', 'desc') // Get all scores, highest first
                        .get();

                    if (allScoresSnapshot.size > MAX_HIGH_SCORES) {
                        const scoresToDelete = allScoresSnapshot.docs.slice(MAX_HIGH_SCORES); // Get documents beyond the limit
                        const batch = db.batch(); // Use a batch for efficient deletion
                        scoresToDelete.forEach(doc => {
                            console.log(`Pruning score ${doc.data().score} (ID: ${doc.id})`);
                            batch.delete(doc.ref);
                        });
                        await batch.commit(); // Execute the batch delete
                        console.log(`${scoresToDelete.length} lowest score(s) pruned.`);
                    }
                } else {
                    console.log("Score is not high enough to make the leaderboard.");
                }
            } catch (error) {
                console.error("Error saving high score: ", error);
                // Optionally inform the user about the error
            }
        }


        // --- UI State Management ---
        function showOverlay(overlayElement) {
            // Hides all overlays then shows the specified one
            mainMenuElement.classList.add('hidden');
            scoreboardScreenElement.classList.add('hidden');
            gameOverElement.classList.add('hidden');
            infoElement.classList.add('hidden'); // Hide in-game score too
            if (overlayElement) {
                overlayElement.classList.remove('hidden');
            }
        }

        // --- Character Selection Logic ---
        function selectCharacter(index) {
            // Updates the selected character index and UI
            if (index >= 0 && index < CHARACTERS.length) {
                selectedCharacterIndex = index;
                updateCharacterButtonSelection();
                console.log(`Selected character: ${CHARACTERS[selectedCharacterIndex].name}`);
            }
        }
        function updateCharacterButtonSelection() {
            // Updates the visual style of character buttons based on selection
            const buttons = characterButtonsElement.querySelectorAll('.char-button');
            buttons.forEach((button, index) => {
                if (index === selectedCharacterIndex) button.classList.add('selected');
                else button.classList.remove('selected');
            });
        }
        function populateCharacterButtons() {
            // Creates buttons for each character defined in CHARACTERS array
             characterButtonsElement.innerHTML = ''; // Clear existing buttons
             CHARACTERS.forEach((char, index) => {
                 const button = document.createElement('button');
                 button.textContent = char.name;
                 button.classList.add('char-button');
                 button.onclick = () => selectCharacter(index); // Set click handler
                 characterButtonsElement.appendChild(button);
             });
             updateCharacterButtonSelection(); // Set initial selection style
        }

        // --- Preload Assets & Generate Materials ---
        function preloadAssets() {
            // Loads textures and creates materials before the game starts
            console.log("Preloading assets...");
            let maxAnisotropy = renderer ? renderer.capabilities.getMaxAnisotropy() : 1; // For sharper textures at angles

            // Load character textures
            CHARACTERS.forEach((char, index) => {
                if (char.imageUrl) {
                    characterTextures[index] = textureLoader.load(
                        char.imageUrl,
                        (texture) => { // Success callback
                         texture.magFilter = THREE.NearestFilter; // Pixelated look if desired, or LinearFilter
                         texture.anisotropy = maxAnisotropy;
                         texture.needsUpdate = true;
                        },
                        undefined, // Progress callback (optional)
                        (err) => console.error(`Failed to load character texture: ${char.name} (${char.imageUrl})`, err) // Error callback
                    );
                }
             });

             // Load obstacle textures
             obstacleTextures = {};
             for (const typeKey in OBSTACLE_IMAGES) {
                const images = OBSTACLE_IMAGES[typeKey];
                obstacleTextures[typeKey] = {};
                const loadCallback = (texture) => { texture.magFilter = THREE.NearestFilter; texture.anisotropy = maxAnisotropy; texture.needsUpdate = true; };
                const errorCallback = (imgUrl) => (err) => console.error(`Failed to load obstacle texture: ${typeKey} (${imgUrl})`, err);

                if (images.right) {
                    obstacleTextures[typeKey].right = textureLoader.load(images.right, loadCallback, undefined, errorCallback(images.right));
                } else { console.warn(`Missing right image for obstacle type: ${typeKey}`); }

                if (images.left) {
                    obstacleTextures[typeKey].left = textureLoader.load(images.left, loadCallback, undefined, errorCallback(images.left));
                } else { // Fallback to right image if left is missing
                    console.warn(`Missing left image for obstacle type: ${typeKey}, using right image.`);
                    obstacleTextures[typeKey].left = obstacleTextures[typeKey].right;
                }
            }

            // Generate procedural lane materials
            const carpetTexture = createNoiseTexture(64, 64, '#90EE90', '#3CB371'); // Light green carpet
            carpetTexture.repeat.set(8, 8); // Tile the texture
            laneMaterials[LANE_TYPES.CARPET] = new THREE.MeshStandardMaterial({ map: carpetTexture, roughness: 0.9, metalness: 0.05 });

            const walkwayTexture = createTileTexture(64, 64, '#E07A5F', '#D45D3D', 24); // Terracotta tile walkway
            walkwayTexture.repeat.set(8, 8);
            laneMaterials[LANE_TYPES.WALKWAY] = new THREE.MeshStandardMaterial({ map: walkwayTexture, roughness: 0.4, metalness: 0.1 });

            laneMaterials[LANE_TYPES.WATER] = new THREE.MeshStandardMaterial({ color: WATER_COLOR, roughness: 0.2, metalness: 0.1, transparent: true, opacity: 0.85 });

            // Wall material
            wallMaterial = new THREE.MeshStandardMaterial({ color: 0xFFEBCD, roughness: 0.9, metalness: 0.0 }); // Blanched Almond color

            // Scenery materials
            sceneryMaterials.desk = new THREE.MeshStandardMaterial({ color: SCENERY_COLORS.DESK, roughness: 0.8, metalness: 0.1 });
            sceneryMaterials.plantPot = new THREE.MeshStandardMaterial({ color: SCENERY_COLORS.PLANT_POT, roughness: 0.7, metalness: 0.1 });
            sceneryMaterials.plantLeaf = new THREE.MeshStandardMaterial({ color: SCENERY_COLORS.PLANT_LEAF, roughness: 0.8, metalness: 0.0 });
            sceneryMaterials.safeSpot = new THREE.MeshStandardMaterial({ color: SAFE_SPOT_COLOR, roughness: 0.9, metalness: 0.0 });

            console.log("Asset preloading & generation initiated.");
        }

        // --- Initialization Function ---
        function init() {
            // Get references to all necessary DOM elements
            infoElement = document.getElementById('info');
            mainMenuElement = document.getElementById('mainMenu');
            scoreboardScreenElement = document.getElementById('scoreboardScreen');
            gameOverElement = document.getElementById('gameOver');
            characterButtonsElement = document.getElementById('characterButtons');
            startGameButton = document.getElementById('startGameButton');
            viewScoresButton = document.getElementById('viewScoresButton');
            backToMenuButton = document.getElementById('backToMenuButton');
            scoreListElement = document.getElementById('scoreList');
            noScoresMessageElement = document.getElementById('noScoresMessage');
            finalScoreElement = document.getElementById('finalScore');
            gameOverReasonElement = document.getElementById('gameOverReason');

            // Basic Three.js setup: Scene, Camera, Renderer
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 12); // Initial camera position (slightly elevated, behind player)
            camera.lookAt(0, 0, 0); // Look towards the center

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // Enable anti-aliasing and transparency
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Enable shadows
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
            document.body.appendChild(renderer.domElement); // Add canvas to the page

            // Lighting setup
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // Better color grading
            renderer.toneMappingExposure = 1.0;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // Soft ambient light
            scene.add(ambientLight);
            const hemiLight = new THREE.HemisphereLight( 0xE8E8FF, 0xB0B0B0, 0.6 ); // Light from sky and ground
            scene.add( hemiLight );

            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Main light source for shadows
            directionalLight.position.set(20, 35, 25); // Position the light
            directionalLight.castShadow = true;
            // Configure shadow properties
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 1;
            directionalLight.shadow.camera.far = 500;
            const initialShadowSize = laneLength / 2 + 10; // Area covered by shadow
            directionalLight.shadow.camera.left = -initialShadowSize;
            directionalLight.shadow.camera.right = initialShadowSize;
            directionalLight.shadow.camera.top = initialShadowSize;
            directionalLight.shadow.camera.bottom = -initialShadowSize;
            directionalLight.shadow.bias = -0.005; // Adjust to prevent shadow acne
            scene.add(directionalLight);
            scene.add(directionalLight.target); // Add target for the light to look at (updated in animate)

            // Preload assets and populate UI elements
            preloadAssets();
            if (characterButtonsElement) populateCharacterButtons();
            else console.error("characterButtonsElement not found!");

            // Add event listeners to buttons
            if (startGameButton) startGameButton.onclick = startGame;
            else console.error("startGameButton not found!");

            if (viewScoresButton) {
                viewScoresButton.onclick = () => {
                    currentGameState = GAME_STATE.SHOW_SCORES;
                    showOverlay(scoreboardScreenElement);
                    fetchAndDisplayHighScores(); // Fetch scores when the screen is shown
                };
            } else { console.error("viewScoresButton not found!"); }

            if (backToMenuButton) backToMenuButton.onclick = goToMenu;
            else console.error("backToMenuButton not found!");

            // Add global event listeners
            window.addEventListener('resize', onWindowResize, false); // Handle window resizing
            document.addEventListener('keydown', onKeyDown, false); // Handle keyboard input

            // Start in the main menu
            goToMenu();

            // Start the animation loop
            animate();
        }

        // --- Game Start Logic ---
        function startGame() {
            console.log("Starting game...");
            // Reset game state variables
            score = 0;
            playerPosition = { x: 0, z: 0 };
            targetPlayerPosition = { x: 0, z: 0 };
            lastLaneZ = 0;
            isMoving = false;
            infoElement.innerText = `Score: ${score}`;
            lastMoveTime = clock.elapsedTime; // Reset idle timer

            // Clear previous game objects
            clearGameObjects();

            // Create initial game elements
            createPlayer();
            createLane(LANE_TYPES.CARPET, 0); // Start on a safe carpet lane
            // Generate initial lanes ahead
            for (let i = 1; i < generationDistance; i++) {
                generateLane();
            }

            // Reset camera position and lookAt
            camera.position.set(0, 15, 12);
            camera.lookAt(0, 0, 0);

            // Set game state and UI
            currentGameState = GAME_STATE.PLAYING;
            showOverlay(null); // Hide all overlays
            infoElement.classList.remove('hidden'); // Show score display

            // Ensure clock and animation loop are running
            if (!clock.running) clock.start();
            if (!animationFrameId) animate(); // Restart animation loop if stopped
        }

        // --- Clear Game Objects ---
        function clearGameObjects() {
            // Removes all dynamic game objects (lanes, obstacles, player, etc.) from the scene
            console.log("Clearing game objects...");

            // Remove obstacles (and from lanes array)
            for (let i = obstacles.length - 1; i >= 0; i--) {
                if (obstacles[i].mesh.parent) scene.remove(obstacles[i].mesh);
            }
            obstacles = [];

            // Remove lanes (and their associated obstacles/safe spots)
            for (let i = lanes.length - 1; i >= 0; i--) {
                if (lanes[i].mesh.parent) scene.remove(lanes[i].mesh);
                // Ensure associated objects are also removed if not handled elsewhere
                 lanes[i].obstacles.forEach(o => { if(o.mesh.parent) scene.remove(o.mesh); });
                 lanes[i].safeSpots.forEach(s => { if(s.mesh.parent) scene.remove(s.mesh); });
            }
            lanes = [];

            // Remove scenery
            for (let i = scenery.length - 1; i >= 0; i--) {
                if (scenery[i].parent) scene.remove(scenery[i]);
            }
            scenery = [];

            // Remove safe spots (also potentially referenced in lanes, ensure removal)
             for (let i = safeSpots.length - 1; i >= 0; i--) {
                 if (safeSpots[i].mesh.parent) scene.remove(safeSpots[i].mesh);
             }
             safeSpots = [];

            // Remove wall segments
            for (let i = wallSegments.length - 1; i >= 0; i--) {
                if (wallSegments[i].mesh.parent) scene.remove(wallSegments[i].mesh);
            }
            wallSegments = [];

            // Remove player
            if (player && player.parent) scene.remove(player);
            player = null;
            playerBoundingBox = null;
        }

        // --- Create Player ---
        function createPlayer() {
            // Creates the player mesh based on the selected character
            const character = CHARACTERS[selectedCharacterIndex];
            const playerW = character.width;
            const playerH = character.height;
            const playerBaseY = playerH / 2; // Position pivot at the bottom center
            let playerMaterial, playerGeometry;

            // Use image texture if available, otherwise use a colored box
            if (character.imageUrl && characterTextures[selectedCharacterIndex]) {
                playerGeometry = new THREE.PlaneGeometry(playerW, playerH); // Use a plane for image textures
                playerMaterial = new THREE.MeshBasicMaterial({ // Basic material doesn't need light
                    map: characterTextures[selectedCharacterIndex],
                    transparent: true, // Allow transparency from PNG
                    side: THREE.DoubleSide // Visible from both sides
                });
            } else { // Fallback to a colored box
                playerGeometry = new THREE.BoxGeometry(playerW, playerH, playerW * 0.8); // Slightly thinner box
                playerMaterial = new THREE.MeshStandardMaterial({ color: DEFAULT_PLAYER_COLOR, roughness: 0.6 });
            }

            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(playerPosition.x, playerBaseY, playerPosition.z);
            player.castShadow = true; // Player casts shadows
            player.receiveShadow = false; // Player doesn't receive shadows on itself (usually)
            scene.add(player);

            // Create the bounding box for collision detection
            // Adjust size slightly for plane geometry to give it some depth for checks
            if (player.geometry.type === 'PlaneGeometry') {
                playerBoundingBox = new THREE.Box3().setFromCenterAndSize(
                    player.position,
                    new THREE.Vector3(playerW, playerH, 0.5) // Give plane a small depth for collision
                );
            } else {
                playerBoundingBox = new THREE.Box3().setFromObject(player);
            }
        }

        // --- Lane Generation Functions ---
        function createLane(type, zPos) {
            // Creates a single lane segment (plane) and adds it to the scene
            const laneGeometry = new THREE.PlaneGeometry(laneLength, laneWidth);
            const laneMaterial = laneMaterials[type] || new THREE.MeshStandardMaterial({color: 0xff00ff}); // Fallback material
            let laneData = { mesh: null, type: type, z: zPos, obstacles: [], safeSpots: [] }; // Store lane info

            const laneMesh = new THREE.Mesh(laneGeometry, laneMaterial);
            laneMesh.rotation.x = -Math.PI / 2; // Rotate plane to be horizontal
            laneMesh.position.set(0, 0, zPos); // Position along Z axis
            laneMesh.receiveShadow = true; // Lanes receive shadows
            scene.add(laneMesh);

            laneData.mesh = laneMesh;
            lanes.push(laneData); // Add to the global lanes array

            // Add obstacles, scenery, or safe spots based on lane type
            if (type === LANE_TYPES.WALKWAY && zPos < -laneWidth) { // Don't spawn obstacles on first few lanes
                addObstaclesToLane(laneData);
            } else if (type === LANE_TYPES.CARPET) {
                const sceneryChance = 0.20; // 20% chance of scenery on carpet lanes
                if (Math.random() < sceneryChance) addSceneryToLane(laneData);
            } else if (type === LANE_TYPES.WATER) {
                addSafeSpotsToLane(laneData); // Add floating safe spots to water lanes
            }

            // Add wall segments on both sides of the new lane
            createWallSegment(zPos, -1); // Left side
            createWallSegment(zPos, 1);  // Right side

            lastLaneZ = zPos; // Update the position of the furthest lane
            return laneData;
        }
        function generateLane() {
            // Determines the type of the next lane and creates it
            const nextZ = lastLaneZ - laneWidth; // Calculate Z position for the new lane
            let laneType;
            const canSpawnWater = score >= 40; // Water starts appearing after score 40
            const waterProbability = 0.15; // 15% chance of water lane if score is high enough
            let previousLaneType = lanes.length > 0 ? lanes[lanes.length - 1].type : null;

            // Logic to determine lane type
            if (canSpawnWater && Math.random() < waterProbability && previousLaneType !== LANE_TYPES.WATER) {
                laneType = LANE_TYPES.WATER; // Spawn water if conditions met
            } else {
                // Increase probability of walkway (obstacles) as game progresses
                const probabilityOfWalkway = Math.max(0.55, Math.min(0.9, 0.55 + Math.abs(nextZ / (70 * (laneWidth/2) ))));
                laneType = Math.random() < probabilityOfWalkway ? LANE_TYPES.WALKWAY : LANE_TYPES.CARPET;
            }

            createLane(laneType, nextZ); // Create the lane with the determined type and position
        }
        function addSafeSpotsToLane(laneData) {
            // Adds floating safe spots (lily pads/platforms) to water lanes
            const numSpots = Math.floor(Math.random() * 3) + 2; // 2 to 4 safe spots per water lane
            const spotWidth = laneWidth * 0.8; // Size relative to lane width
            const spotDepth = laneWidth * 0.8;
            const spotHeight = 0.2; // Slightly elevated
            const spotGeometry = new THREE.BoxGeometry(spotWidth, spotHeight, spotDepth);
            const spotMaterial = sceneryMaterials.safeSpot;
            const possiblePositions = []; // Potential X positions for spots

            const halfPlayerWidthApprox = (CHARACTERS[selectedCharacterIndex].width / 2) || 1.1;

            // Generate possible X positions, avoiding edges slightly
            for (let x = -laneLength / 2 + spotWidth / 2; x <= laneLength / 2 - spotWidth / 2; x += laneWidth) {
                 if (Math.abs(x) < laneLength / 2 - halfPlayerWidthApprox) { // Ensure player fits fully
                     possiblePositions.push(x);
                 }
            }

            possiblePositions.sort(() => 0.5 - Math.random()); // Shuffle positions

            // Select positions for the spots
            const spotPositionsX = possiblePositions.slice(0, numSpots);

            // Ensure a safe spot at x=0 on the first water lane if possible
             if (laneData.z === 0 && !spotPositionsX.includes(0)) {
                 if (spotPositionsX.length < possiblePositions.length && spotPositionsX.length > 0) {
                     spotPositionsX.pop(); // Remove one random spot
                     spotPositionsX.push(0); // Add spot at center
                 } else if (spotPositionsX.length === 0) {
                     spotPositionsX.push(0); // Add spot at center if none were chosen
                 }
             }

            // Create and add spot meshes
            spotPositionsX.forEach(posX => {
                const spotMesh = new THREE.Mesh(spotGeometry, spotMaterial);
                spotMesh.position.set(posX, spotHeight / 2, laneData.z); // Position slightly above water
                spotMesh.castShadow = true;
                spotMesh.receiveShadow = true;
                scene.add(spotMesh);
                const spotBox = new THREE.Box3().setFromObject(spotMesh); // Bounding box for collision
                const spotData = { mesh: spotMesh, x: posX, z: laneData.z, boundingBox: spotBox };
                laneData.safeSpots.push(spotData); // Add to lane's data
                safeSpots.push(spotData); // Add to global safe spots array
            });
        }
        function createWallSegment(zPos, side) {
            // Creates a segment of the side wall for a given lane
            const wallSegmentGeometry = new THREE.BoxGeometry(WALL_THICKNESS, WALL_HEIGHT, laneWidth);
            const wallX = side * (laneLength / 2 + WALL_THICKNESS / 2); // Position at the edge of the lane area
            const wallY = WALL_HEIGHT / 2; // Center vertically
            const wallSegmentMesh = new THREE.Mesh(wallSegmentGeometry, wallMaterial);
            wallSegmentMesh.position.set(wallX, wallY, zPos);
            wallSegmentMesh.receiveShadow = true; // Walls receive shadows
            scene.add(wallSegmentMesh);
            wallSegments.push({ mesh: wallSegmentMesh, z: zPos }); // Add to wall segments array
        }
        function addSceneryToLane(laneData) {
            // Adds decorative scenery (desks, plants) to carpet lanes
            const sceneryType = Math.random() < 0.6 ? 'desk' : 'plant'; // 60% chance desk, 40% plant
            let sceneryMesh;
            const side = Math.random() < 0.5 ? -1 : 1; // Randomly place on left or right side
            // Calculate position away from the center path
            const xOffset = (laneLength / 3) + (Math.random() * laneLength / 4);
            const sceneryX = xOffset * side;
            const sceneryZ = laneData.z + (Math.random() - 0.5) * laneWidth * 0.8; // Random Z within the lane

            // Create desk or plant mesh
            if (sceneryType === 'desk') {
                const deskHeight = 1.2;
                const deskGeo = new THREE.BoxGeometry(2.5, deskHeight, 1.2);
                sceneryMesh = new THREE.Mesh(deskGeo, sceneryMaterials.desk);
                sceneryMesh.position.set(sceneryX, deskHeight / 2, sceneryZ);
            } else { // Plant
                const potHeight = 0.8;
                const potRadius = 0.5;
                const potGeo = new THREE.CylinderGeometry(potRadius * 0.8, potRadius, potHeight, 12);
                const potMesh = new THREE.Mesh(potGeo, sceneryMaterials.plantPot);
                potMesh.position.set(sceneryX, potHeight / 2, sceneryZ);

                const leafHeight = 1.0;
                const leafGeo = new THREE.ConeGeometry(potRadius * 1.2, leafHeight, 8); // Simple cone for leaves
                const leafMesh = new THREE.Mesh(leafGeo, sceneryMaterials.plantLeaf);
                leafMesh.position.set(sceneryX, potHeight + leafHeight / 2, sceneryZ);

                sceneryMesh = new THREE.Group(); // Group pot and leaves
                sceneryMesh.add(potMesh);
                sceneryMesh.add(leafMesh);
            }
            sceneryMesh.castShadow = true;
            sceneryMesh.receiveShadow = true;
            scene.add(sceneryMesh);
            scenery.push(sceneryMesh); // Add to global scenery array
        }
        function addObstaclesToLane(laneData) {
            // Adds moving obstacles (cars/trains) to walkway lanes
            const maxObstacles = Math.min(3, 1 + Math.floor(score / 15)); // More obstacles as score increases
            const numObstacles = Math.floor(Math.random() * maxObstacles) + 1; // 1 to maxObstacles
            const speedMultiplier = 1 + Math.min(1.5, score / 80); // Speed increases with score
            const baseSpeed = (0.08 + Math.random() * 0.10) * speedMultiplier;
            const speed = baseSpeed * (Math.random() < 0.5 ? 1 : -1); // Random direction and speed
            const direction = Math.sign(speed);
            const startEdge = (laneLength / 2 + 5) * direction * -1; // Start position off-screen

            // Calculate spacing between obstacles
            const minSpacing = OBSTACLE_PLANE_WIDTH + 2.0; // Minimum gap between obstacles
            const totalSpacingNeeded = (numObstacles -1) * minSpacing;
            const randomSpacingPool = Math.max(0, laneLength - totalSpacingNeeded - OBSTACLE_PLANE_WIDTH * numObstacles); // Extra space to distribute randomly
            let currentX = startEdge;

            const availableObstacleTypes = Object.keys(OBSTACLE_TYPES);

            // Create each obstacle
            for (let i = 0; i < numObstacles; i++) {
                // Select random obstacle type and texture
                const randomTypeKey = availableObstacleTypes[Math.floor(Math.random() * availableObstacleTypes.length)];
                const obstacleType = OBSTACLE_TYPES[randomTypeKey];
                const textureSet = obstacleTextures[obstacleType];
                let textureToUse = null;
                if (textureSet) {
                    textureToUse = direction < 0 ? textureSet.left : textureSet.right; // Use directional texture
                    if (!textureToUse) { textureToUse = textureSet.right || textureSet.left; } // Fallback if one is missing
                }

                // Create obstacle mesh (plane)
                const obstacleW = OBSTACLE_PLANE_WIDTH;
                const obstacleH = OBSTACLE_PLANE_HEIGHT;
                const obstacleYPosition = obstacleH / 2; // Pivot at bottom center
                const obstacleGeometry = new THREE.PlaneGeometry(obstacleW, obstacleH);
                const obstacleMaterial = new THREE.MeshBasicMaterial({
                    map: textureToUse || null, // Use texture if loaded
                    color: textureToUse ? 0xffffff : DEFAULT_OBSTACLE_COLOR, // Use white color with texture, fallback color otherwise
                    transparent: true,
                    side: THREE.DoubleSide
                });
                const obstacleMesh = new THREE.Mesh(obstacleGeometry, obstacleMaterial);

                // Calculate position with spacing
                if (i > 0) {
                    const spacingToAdd = minSpacing + (numObstacles > 1 ? Math.random() * (randomSpacingPool / (numObstacles - 1)) : 0);
                    currentX -= spacingToAdd * direction; // Move along X based on direction
                } else { // First obstacle random offset
                    currentX -= (Math.random() * (randomSpacingPool / numObstacles)) * direction;
                }
                obstacleMesh.position.set(currentX, obstacleYPosition, laneData.z);
                obstacleMesh.castShadow = true;
                obstacleMesh.receiveShadow = false;
                scene.add(obstacleMesh);

                // Create bounding box for collision
                const obstacleBoundingBox = new THREE.Box3().setFromCenterAndSize(
                    obstacleMesh.position,
                    new THREE.Vector3(obstacleW, obstacleH, 0.5) // Give plane depth for collision
                );

                // Store obstacle data
                const obstacleData = {
                    mesh: obstacleMesh,
                    boundingBox: obstacleBoundingBox,
                    speed: speed,
                    direction: direction,
                    laneZ: laneData.z,
                    type: obstacleType
                };
                obstacles.push(obstacleData); // Add to global obstacles array
                laneData.obstacles.push(obstacleData); // Add reference to lane's data
            }
        }

        // --- Game Loop ---
        function animate() {
            // Main game loop, called every frame
            animationFrameId = requestAnimationFrame(animate); // Request next frame
            const deltaTime = clock.getDelta(); // Time since last frame

            // Idle Check
            if (currentGameState === GAME_STATE.PLAYING && !isMoving) {
                const idleTime = clock.elapsedTime - lastMoveTime;
                if (idleTime > MAX_IDLE_TIME) {
                    console.log("Idle time exceeded!");
                    triggerGameOver("idle"); // End game if player is idle too long
                }
            }

            // Update game state only when playing
            if (currentGameState === GAME_STATE.PLAYING) {
                movePlayerVisually(deltaTime); // Smoothly animate player movement
                moveObstacles(); // Move obstacles across lanes
                checkCollisions(); // Check for player-obstacle collisions
                updateCamera(); // Adjust camera to follow player
                updateShadowCamera(); // Adjust shadow camera frustum
                // Generate new lanes if player is close to the edge
                if (player && player.position.z < lastLaneZ + (generationDistance * laneWidth)) {
                    generateLane();
                }
                cleanupEnvironment(); // Remove objects far behind the player
            } else if (currentGameState === GAME_STATE.GAME_OVER) {
                // Optional: Add game over animation (e.g., shrink player)
                 if (player && player.scale.x > 0.01) {
                     player.scale.multiplyScalar(0.9); // Simple shrink effect
                 } else if (player) {
                     player.scale.set(0,0,0); // Ensure player is fully shrunk
                 }
            }

            // Render the scene
            renderer.render(scene, camera);
        }

        // --- Player Movement Visual Interpolation ---
        function movePlayerVisually(deltaTime) {
            // Smoothly interpolates player mesh position towards targetPosition
            if (!player || !isMoving) return; // Only run if player exists and is moving

            const character = CHARACTERS[selectedCharacterIndex];
            const playerBaseY = character.height / 2; // Base Y position
            const elapsedTime = clock.elapsedTime * 1000 - moveStartTime; // Time since move started
            let progress = Math.min(1.0, elapsedTime / moveDuration); // Movement progress (0 to 1)
            const easedProgress = progress * (2 - progress); // Ease-out interpolation (starts fast, ends slow)

            // Interpolate position
            const startVec = new THREE.Vector3(playerPosition.x, playerBaseY, playerPosition.z);
            const endVec = new THREE.Vector3(targetPlayerPosition.x, playerBaseY, targetPlayerPosition.z);
            player.position.lerpVectors(startVec, endVec, easedProgress);

            // Add a hop effect
            const hopHeight = 1.0;
            player.position.y = playerBaseY + Math.sin(progress * Math.PI) * hopHeight;

            // When movement finishes
            if (progress >= 1.0) {
                player.position.copy(endVec); // Snap to final position
                player.position.y = playerBaseY; // Reset Y position
                isMoving = false; // Stop moving flag
                playerPosition.x = targetPlayerPosition.x; // Update logical position
                playerPosition.z = targetPlayerPosition.z;

                // Update bounding box after move completes
                if (player) {
                    if (player.geometry.type === 'PlaneGeometry') {
                        playerBoundingBox.setFromCenterAndSize(player.position, new THREE.Vector3(character.width, character.height, 0.5));
                    } else {
                        playerBoundingBox.setFromObject(player);
                    }
                }
            }
        }

        // --- Obstacle Movement ---
        function moveObstacles() {
            // Moves obstacles horizontally and wraps them around
            const wrapEdge = laneLength / 2 + 5; // Position where obstacles wrap
            obstacles.forEach(obstacle => {
                let currentSpeed = obstacle.speed; // Could adjust speed here if needed
                obstacle.mesh.position.x += currentSpeed;

                // Wrap obstacle around if it goes off-screen
                if (obstacle.direction > 0 && obstacle.mesh.position.x > wrapEdge) {
                    obstacle.mesh.position.x = -wrapEdge; // Wrap from right to left
                } else if (obstacle.direction < 0 && obstacle.mesh.position.x < -wrapEdge) {
                    obstacle.mesh.position.x = wrapEdge; // Wrap from left to right
                }

                // Update bounding box position
                obstacle.boundingBox.setFromCenterAndSize(
                    obstacle.mesh.position,
                    new THREE.Vector3(OBSTACLE_PLANE_WIDTH, OBSTACLE_PLANE_HEIGHT, 0.5)
                );
            });
        }

        // --- Camera Update ---
        function updateCamera() {
            // Makes the camera follow the player smoothly
            if (!player) return;

            // Target position slightly behind and above the player
            const targetCameraPosition = new THREE.Vector3(
                player.position.x,
                camera.position.y, // Keep camera height constant (or adjust dynamically)
                player.position.z + 10 // Distance behind player
            );
            // Smoothly interpolate camera position
            camera.position.lerp(targetCameraPosition, 0.04); // Adjust lerp factor for follow speed

            // Target lookAt point slightly ahead of the player
            const targetLookAt = new THREE.Vector3(
                player.position.x,
                player.position.y * 0.5, // Look slightly down towards player's feet/mid
                player.position.z - 8 // Point further down the path
            );
            // Smoothly interpolate lookAt direction (more complex but smoother)
            const currentLookAt = new THREE.Vector3();
            camera.getWorldDirection(currentLookAt).multiplyScalar(15).add(camera.position); // Get current lookAt point
            currentLookAt.lerp(targetLookAt, 0.05); // Interpolate towards target lookAt
            camera.lookAt(currentLookAt);
        }

        // --- Shadow Camera Update ---
        function updateShadowCamera() {
            // Adjusts the directional light's shadow camera frustum to follow the player
            // This optimizes shadow rendering by focusing the shadow map area
            if (!player || !directionalLight || !directionalLight.shadow) return;

            const shadowCam = directionalLight.shadow.camera;
            const shadowSizeH = laneLength / 2 + 10; // Horizontal size of shadow area
            const shadowSizeV = 200; // Vertical size (depth) of shadow area (needs to be large enough)

            // Center the shadow camera horizontally on the player
            shadowCam.left = player.position.x - shadowSizeH;
            shadowCam.right = player.position.x + shadowSizeH;
            // Center the shadow camera vertically around the player's Z position
            shadowCam.top = player.position.z + shadowSizeV / 2;
            shadowCam.bottom = player.position.z - shadowSizeV / 2;

            shadowCam.updateProjectionMatrix(); // Apply changes

            // Update the light's target to be near the player
            if (directionalLight.target) {
                const targetPosX = player.position.x;
                const targetPosZ = player.position.z - 15; // Target slightly ahead of player
                directionalLight.target.position.set(targetPosX, 0, targetPosZ);
            }
        }


        // --- Collision Detection ---
        function checkCollisions() {
            // Checks for collisions between the player and obstacles or water
            if (!player || isMoving || currentGameState !== GAME_STATE.PLAYING) {
                return; // Don't check collisions if player doesn't exist, is moving, or game not playing
            }

            // Ensure player bounding box is up-to-date (might be redundant if updated after move)
            if (player.geometry.type === 'PlaneGeometry') {
                const character = CHARACTERS[selectedCharacterIndex];
                playerBoundingBox.setFromCenterAndSize(player.position, new THREE.Vector3(character.width, character.height, 0.5));
            } else {
                playerBoundingBox.setFromObject(player);
            }

            // Check collision with obstacles
            obstacles.forEach(obstacle => {
                // Broad phase check: only check obstacles on the same lane (or adjacent if needed)
                if (Math.abs(player.position.z - obstacle.laneZ) < laneWidth / 2) {
                    // Narrow phase check: bounding box intersection
                    if (playerBoundingBox.intersectsBox(obstacle.boundingBox)) {
                        console.log("Collision Detected with obstacle!");
                        triggerGameOver("collision"); // Game over on obstacle collision
                    }
                }
            });

            // Water collision is checked *before* moving in onKeyDown
        }

        // --- Water Collision Check ---
        function checkWaterCollision(targetZ, targetX) {
            // Checks if the target position (where player intends to move) is on water without a safe spot
             const targetLane = lanes.find(lane => Math.abs(lane.z - targetZ) < 0.1); // Find the lane at the target Z

             if (targetLane && targetLane.type === LANE_TYPES.WATER) {
                 // If it's a water lane, check if the target position overlaps with any safe spot
                 const playerChar = CHARACTERS[selectedCharacterIndex];
                 const playerW = playerChar.width;
                 const playerH = playerChar.height;
                 // Create a temporary bounding box for the player at the target position
                 const targetCenter = new THREE.Vector3(targetX, playerH / 2, targetZ);
                 const targetSize = new THREE.Vector3(playerW, playerH, 0.5); // Use plane dimensions
                 const targetPlayerBox = new THREE.Box3().setFromCenterAndSize(targetCenter, targetSize);

                 let isSafe = false;
                 // Check intersection with all safe spots on that lane
                 targetLane.safeSpots.forEach(spot => {
                     if (spot.boundingBox && targetPlayerBox.intersectsBox(spot.boundingBox)) {
                         isSafe = true; // Found an overlapping safe spot
                     }
                 });

                 if (!isSafe) {
                     // If no safe spot is found at the target location on water
                     console.log("Attempted move into water!");
                     triggerGameOver("drowned"); // Game over
                     return false; // Indicate collision with water (move not allowed)
                 }
             }
             return true; // No water collision detected, move is allowed
        }


        // --- Environment Cleanup ---
        function cleanupEnvironment() {
            // Removes lanes, obstacles, scenery, etc., that are far behind the player
            const cleanupThresholdZ = (player ? player.position.z : 0) + (cleanupBuffer * laneWidth); // Z position threshold

            // Filter lanes
            lanes = lanes.filter(lane => {
                if (lane.z < cleanupThresholdZ) return true; // Keep lane
                else { // Remove lane and associated objects
                    // Remove obstacles associated with this lane from global array and scene
                    lane.obstacles.forEach(obstacle => {
                        const index = obstacles.indexOf(obstacle);
                        if (index > -1) obstacles.splice(index, 1);
                        if (obstacle.mesh.parent) scene.remove(obstacle.mesh);
                    });
                    // Remove safe spots associated with this lane
                    lane.safeSpots.forEach(spot => {
                        const index = safeSpots.indexOf(spot);
                        if (index > -1) safeSpots.splice(index, 1);
                        if (spot.mesh.parent) scene.remove(spot.mesh);
                    });
                    // Remove the lane mesh itself
                    if (lane.mesh.parent) scene.remove(lane.mesh);
                    return false; // Remove lane from array
                }
            });

            // Filter obstacles (might catch some missed if lane removal failed)
            obstacles = obstacles.filter(obstacle => {
                if (obstacle.laneZ < cleanupThresholdZ) return true;
                else { if (obstacle.mesh.parent) scene.remove(obstacle.mesh); return false; }
            });

            // Filter safe spots
            safeSpots = safeSpots.filter(spot => {
                if (spot.z < cleanupThresholdZ) return true;
                else { if (spot.mesh.parent) scene.remove(spot.mesh); return false; }
            });

            // Filter scenery
            scenery = scenery.filter(item => {
                // Get Z position (handling Groups vs Meshes)
                const itemZ = item.position ? item.position.z : (item.children.length > 0 ? item.children[0].position.z : cleanupThresholdZ - 1);
                if (itemZ < cleanupThresholdZ) return true;
                else { if (item.parent) scene.remove(item); return false; }
            });

            // Filter wall segments
            wallSegments = wallSegments.filter(segment => {
                if (segment.z < cleanupThresholdZ) return true;
                else { if (segment.mesh.parent) scene.remove(segment.mesh); return false; }
            });
        }

        // --- Keyboard Controls ---
        function onKeyDown(event) {
            // Handles player movement input
            if (currentGameState !== GAME_STATE.PLAYING || isMoving) return; // Ignore input if not playing or already moving

            let moved = false;
            const currentX = playerPosition.x;
            const currentZ = playerPosition.z;
            const moveAmount = laneWidth; // Move one lane width at a time
            let targetX = currentX;
            let targetZ = currentZ;
            let isForwardMove = false;

            // Determine target position based on key press
            switch (event.key) {
                case 'ArrowUp': case 'w':
                    targetZ = currentZ - moveAmount;
                    targetX = currentX;
                    moved = true; isForwardMove = true; break;
                case 'ArrowLeft': case 'a':
                    targetX = currentX - moveAmount;
                    targetZ = currentZ;
                    moved = true; break;
                case 'ArrowRight': case 'd':
                    targetX = currentX + moveAmount;
                    targetZ = currentZ;
                    moved = true; break;
                case 'ArrowDown': case 's': // Move back
                    targetZ = currentZ + moveAmount;
                    targetX = currentX;
                    moved = true; break;
            }

            if (moved) {
                let allowMove = true;
                const playerChar = CHARACTERS[selectedCharacterIndex];
                const playerW = playerChar.width;
                // Check horizontal boundaries (walls)
                const wallBoundary = laneLength / 2 - playerW / 2; // Max X position
                if (targetX > wallBoundary || targetX < -wallBoundary) {
                    console.log("Move blocked by wall.");
                    allowMove = false;
                }

                // Check for water collision *before* initiating the move
                if (allowMove) {
                    allowMove = checkWaterCollision(targetZ, targetX); // Returns false if move leads into water
                }

                // If move is allowed, initiate visual movement
                if (allowMove) {
                    targetPlayerPosition.x = targetX;
                    targetPlayerPosition.z = targetZ;
                    isMoving = true; // Start visual movement flag
                    moveStartTime = clock.elapsedTime * 1000; // Record start time for interpolation
                    lastMoveTime = clock.elapsedTime; // Update idle timer

                    // Increment score only on forward moves
                    if (isForwardMove) {
                        score++;
                        infoElement.innerText = `Score: ${score}`;
                    }
                } else {
                    // If move is not allowed, reset target to current position (no visual change)
                    targetPlayerPosition.x = currentX;
                    targetPlayerPosition.z = currentZ;
                }
            }
        }

        // --- Game Over Logic ---
        function triggerGameOver(reason = "collision") {
            // Handles the game over sequence
            if (currentGameState !== GAME_STATE.PLAYING) return; // Prevent multiple game overs

            currentGameState = GAME_STATE.GAME_OVER;
            console.log(`Game Over! Score: ${score}, Reason: ${reason}`);
            finalScoreElement.innerText = score; // Display final score

            // Set game over message based on reason
            if (reason === "idle") { gameOverReasonElement.innerText = "Took too long!"; }
            else if (reason === "drowned") { gameOverReasonElement.innerText = "Fell in the water cooler!"; }
            else { gameOverReasonElement.innerText = "You lost, go back to work!"; } // Default collision

            showOverlay(gameOverElement); // Show game over screen

            // --- Attempt to save score to Firebase ---
            const characterName = CHARACTERS[selectedCharacterIndex].name;
            saveScoreIfHighScore(characterName, score); // Call the Firebase save function
        }

        // --- Go To Menu ---
        function goToMenu() {
            // Switches game state to Menu and shows the main menu overlay
            currentGameState = GAME_STATE.MENU;
            showOverlay(mainMenuElement);
            // Optional: Reset camera to default menu view if needed
            // camera.position.set(0, 15, 12);
            // camera.lookAt(0, 0, 0);
        }

        // --- Window Resize Handler ---
        function onWindowResize() {
            // Updates camera aspect ratio and renderer size on window resize
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix(); // Important after changing aspect ratio
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Start the application ---
        // Use DOMContentLoaded to ensure the HTML is parsed before running init
        document.addEventListener('DOMContentLoaded', (event) => {
            console.log("DOM fully loaded and parsed");
            init(); // Initialize the game
        });

    </script>
</body>
</html>

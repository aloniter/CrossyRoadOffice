<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Office Crossing Challenge - Enhanced Look</title> {/* Updated Title */}
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #DDE2E6; /* Slightly adjusted BG */ color: #333; }
        canvas { display: block; }

        /* Overlays and UI styles remain the same as v10 */
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; flex-direction: column; background-color: rgba(0, 0, 0, 0.7); color: white; z-index: 100; padding: 20px; box-sizing: border-box; text-align: center; }
        .hidden { display: none; }
        .overlay-content { background-color: rgba(50, 50, 50, 0.9); padding: 30px 40px; border-radius: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.4); max-width: 90%; width: 400px; }
        .overlay h2 { margin-top: 0; margin-bottom: 20px; border-bottom: 1px solid rgba(255,255,255,0.5); padding-bottom: 10px; }
        .overlay button { display: block; width: 80%; margin: 15px auto; padding: 12px 20px; font-size: 18px; cursor: pointer; border: none; border-radius: 8px; background-color: #5DADE2; color: white; transition: background-color 0.3s, transform 0.1s; box-shadow: 0 4px 6px rgba(0,0,0,0.2); }
        .overlay button:hover { background-color: #3498DB; }
        .overlay button:active { transform: scale(0.95); background-color: #2E86C1; }
        #mainMenu .character-selection { margin-bottom: 20px; padding: 10px; background-color: rgba(255,255,255,0.1); border-radius: 8px; }
        #mainMenu .character-selection h3 { margin-top: 0; margin-bottom: 10px; font-size: 16px; }
        #mainMenu .char-button { display: inline-block; width: auto; padding: 8px 15px; margin: 5px; font-size: 14px; border: 2px solid transparent; }
        #mainMenu .char-button.selected { border-color: #FFD700; background-color: #3498DB; }
        #scoreboardScreen ol { margin: 0 0 15px 0; padding: 0 0 0 25px; list-style-position: outside; max-height: 150px; overflow-y: auto; }
        #scoreboardScreen li { margin-bottom: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 16px; border-bottom: 1px dotted rgba(255, 255, 255, 0.2); padding-bottom: 4px; }
        #scoreboardScreen li:last-child { border-bottom: none; }
        #scoreboardScreen li span { display: inline-block; }
        #scoreboardScreen li .name { /* width: 150px; */ }
        #scoreboardScreen li .score { float: right; font-weight: bold; margin-left: 15px; }
        #scoreboardScreen .no-scores { text-align: center; font-style: italic; color: #ccc; margin-top: 10px;}
        #info { position: absolute; top: 10px; left: 10px; width: auto; text-align: left; z-index: 50; display: block; color: #333; font-size: 24px; text-shadow: 1px 1px 2px #ccc; background-color: rgba(255, 255, 255, 0.6); padding: 5px 10px; border-radius: 5px; }
        #gameOver { z-index: 101; }

    </style>
</head>
<body>
    <div id="info" class="hidden">Score: 0</div>
    <div id="mainMenu" class="overlay"> <div class="overlay-content"> <h2>Office Crossing Challenge</h2> <div class="character-selection"> <h3>Select Character</h3> <div id="characterButtons"></div> </div> <button id="startGameButton">Start Game</button> <button id="viewScoresButton">High Scores</button> </div> </div>
    <div id="scoreboardScreen" class="overlay hidden"> <div class="overlay-content"> <h2>High Scores</h2> <ol id="scoreList"></ol> <div id="noScoresMessage" class="no-scores" style="display: none;">No scores yet!</div> <button id="backToMenuButton">Back to Menu</button> </div> </div>
    <div id="gameOver" class="overlay hidden"> <div class="overlay-content"> <h2>Deadline Missed!</h2> Final Score: <span id="finalScore">0</span><br> <button onclick="goToMenu()">Main Menu</button> </div> </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Game States ---
        const GAME_STATE = { MENU: 'menu', PLAYING: 'playing', GAME_OVER: 'game_over', SHOW_SCORES: 'show_scores' };
        let currentGameState = GAME_STATE.MENU;

        // --- Global Variables ---
        let scene, camera, renderer;
        let player, playerBoundingBox;
        let lanes = []; let obstacles = []; let score = 0;
        let laneWidth = 2; let laneLength = 50;
        let playerPosition = { x: 0, z: 0 }; let targetPlayerPosition = { x: 0, z: 0 };
        let isMoving = false; let moveDuration = 150; let moveStartTime = 0;
        let lastLaneZ = 0; let generationDistance = 20; let cleanupBuffer = 5;
        let clock = new THREE.Clock(); let textureLoader = new THREE.TextureLoader();
        const MAX_HIGH_SCORES = 3; let animationFrameId = null;
        let laneMaterials = {}; // Cache for lane materials
        let wallMaterial; // Single material for walls

        // --- Character Definition ---
        const CHARACTERS = [
             { name: 'Alon', imageUrl: 'https://i.postimg.cc/NMQFGG4Y/Alon.png', width: 1.0, height: 1.2 },
             { name: 'Sahar', imageUrl: 'Sahar.png', width: 1.0, height: 1.2 },
             { name: 'Default', imageUrl: null, width: 0.8, height: 0.8 }
        ];
        let selectedCharacterIndex = 0; let characterTextures = {};

        // --- THEME Constants ---
        const LANE_TYPES = { CARPET: 'carpet', WALKWAY: 'walkway' };
        // const CARPET_COLORS = [0xD2B48C, 0xAAAAAA, 0xBDB76B]; // Replaced by textures
        // const WALKWAY_COLOR = 0xCCCCCC; // Replaced by texture
        const WALL_COLOR = 0xF5F5F5; const BACKGROUND_COLOR = 0xDDE2E6; const FOG_COLOR = 0xDDE2E6; // Match BG
        const DEFAULT_PLAYER_COLOR = 0x808080;
        const DEFAULT_OBSTACLE_COLOR = 0xff00ff;

        // --- Obstacle Image Definitions ---
        const OBSTACLE_TYPES = { CC: 'cc', LIVE_CHANGE: 'live_change', ON_CALL: 'on_call' };
        const OBSTACLE_IMAGES = {
            [OBSTACLE_TYPES.CC]: 'CC.png',
            [OBSTACLE_TYPES.LIVE_CHANGE]: 'Live Change.png',
            [OBSTACLE_TYPES.ON_CALL]: 'On Call.png'
        };
        let obstacleTextures = {};
        const OBSTACLE_PLANE_WIDTH = 1.0; const OBSTACLE_PLANE_HEIGHT = 1.0;

        // --- DOM Elements ---
        const infoElement = document.getElementById('info'); /* ... and others ... */
        const mainMenuElement = document.getElementById('mainMenu'); const scoreboardScreenElement = document.getElementById('scoreboardScreen'); const gameOverElement = document.getElementById('gameOver');
        const characterButtonsElement = document.getElementById('characterButtons'); const startGameButton = document.getElementById('startGameButton'); const viewScoresButton = document.getElementById('viewScoresButton');
        const backToMenuButton = document.getElementById('backToMenuButton'); const scoreListElement = document.getElementById('scoreList'); const noScoresMessageElement = document.getElementById('noScoresMessage');
        const finalScoreElement = document.getElementById('finalScore');

        // --- NEW: Texture Generation Functions ---
        function createNoiseTexture(width, height, color1, color2, alpha = 1) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color1;
            ctx.fillRect(0, 0, width, height);
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                if (Math.random() > 0.85) { // Adjust density of noise
                    const shade = Math.random() * 50 + (color2 === '#000000' ? 0 : 205); // Darker or lighter noise
                    data[i] = shade;     // R
                    data[i + 1] = shade; // G
                    data[i + 2] = shade; // B
                }
                data[i + 3] = alpha * 255; // Alpha
            }
            ctx.putImageData(imageData, 0, 0);
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function createTileTexture(width, height, bgColor, lineColor, tileSize) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, width, height);
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = Math.max(1, Math.floor(width / 100)); // Line width relative to texture size
            ctx.beginPath();
            for (let x = 0; x <= width; x += tileSize) {
                ctx.moveTo(x, 0); ctx.lineTo(x, height);
            }
            for (let y = 0; y <= height; y += tileSize) {
                ctx.moveTo(0, y); ctx.lineTo(width, y);
            }
            ctx.stroke();
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        // --- Leaderboard Functions ---
        function getHighScores() { /* ... */ const scoresJSON = localStorage.getItem('officeCrossingHighScores'); const scores = scoresJSON ? JSON.parse(scoresJSON) : []; scores.sort((a, b) => b.score - a.score); return scores; }
        function saveHighScores(scores) { /* ... */ scores.sort((a, b) => b.score - a.score); const topScores = scores.slice(0, MAX_HIGH_SCORES); localStorage.setItem('officeCrossingHighScores', JSON.stringify(topScores)); console.log("High scores saved:", topScores); }
        function displayHighScoresOnScreen() { /* ... */ const scores = getHighScores(); scoreListElement.innerHTML = ''; if (scores.length === 0) { noScoresMessageElement.style.display = 'block'; } else { noScoresMessageElement.style.display = 'none'; scores.forEach((scoreEntry) => { const li = document.createElement('li'); const displayName = scoreEntry.name.substring(0, 10); li.innerHTML = `<span class="name">${displayName}</span><span class="score">${scoreEntry.score}</span>`; scoreListElement.appendChild(li); }); } }

        // --- UI State Management ---
        function showOverlay(overlayElement) { /* ... */ mainMenuElement.classList.add('hidden'); scoreboardScreenElement.classList.add('hidden'); gameOverElement.classList.add('hidden'); infoElement.classList.add('hidden'); if (overlayElement) { overlayElement.classList.remove('hidden'); } }

        // --- Character Selection ---
        function selectCharacter(index) { /* ... */ if (index >= 0 && index < CHARACTERS.length) { selectedCharacterIndex = index; updateCharacterButtonSelection(); console.log(`Selected character: ${CHARACTERS[selectedCharacterIndex].name}`); } }
        function updateCharacterButtonSelection() { /* ... */ const buttons = characterButtonsElement.querySelectorAll('.char-button'); buttons.forEach((button, index) => { if (index === selectedCharacterIndex) button.classList.add('selected'); else button.classList.remove('selected'); }); }
        function populateCharacterButtons() { /* ... */ characterButtonsElement.innerHTML = ''; CHARACTERS.forEach((char, index) => { const button = document.createElement('button'); button.textContent = char.name; button.classList.add('char-button'); button.onclick = () => selectCharacter(index); characterButtonsElement.appendChild(button); }); updateCharacterButtonSelection(); }

        // --- Preload Assets ---
        function preloadAssets() {
            console.log("Preloading assets...");
            // Character Textures
            CHARACTERS.forEach((char, index) => { if (char.imageUrl) { characterTextures[index] = textureLoader.load(char.imageUrl, undefined, undefined, (err) => console.error(`Failed texture: ${char.name}`, err)); } });
            // Obstacle Textures
            for (const type in OBSTACLE_IMAGES) { const imageUrl = OBSTACLE_IMAGES[type]; obstacleTextures[type] = textureLoader.load(imageUrl, undefined, undefined, (err) => console.error(`Failed texture: ${type}`, err)); }

            // --- NEW: Generate Procedural Textures & Materials ---
            const carpetTexture = createNoiseTexture(64, 64, '#D2B48C', '#A08C70'); // Tan carpet with noise
            carpetTexture.repeat.set(4, 4); // How many times texture repeats per lane segment
            laneMaterials[LANE_TYPES.CARPET] = new THREE.MeshStandardMaterial({ map: carpetTexture, roughness: 0.8, metalness: 0.1 });

            const walkwayTexture = createTileTexture(64, 64, '#CCCCCC', '#AAAAAA', 16); // Grey tiles
            walkwayTexture.repeat.set(4, 4);
            laneMaterials[LANE_TYPES.WALKWAY] = new THREE.MeshStandardMaterial({ map: walkwayTexture, roughness: 0.5, metalness: 0.2 });

            const wallTexture = createNoiseTexture(128, 128, '#F5F5F5', '#E0E0E0'); // Off-white wall with subtle noise
            wallTexture.repeat.set(1, 10); // Repeat more vertically along the wall length
            wallMaterial = new THREE.MeshStandardMaterial({ map: wallTexture, roughness: 0.9, metalness: 0.1 });

            console.log("Asset preloading & generation initiated.");
         }

        // --- Initialization ---
        function init() {
            // Basic Three.js Setup
            scene = new THREE.Scene(); scene.background = new THREE.Color(BACKGROUND_COLOR); scene.fog = new THREE.Fog(FOG_COLOR, 20, 60); // Adjust fog
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000); // Slightly narrower FOV
            camera.position.set(0, 9, 8); camera.lookAt(0, 1, 0); // Adjusted camera angle
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; document.body.appendChild(renderer.domElement);
            // Tone mapping for better visuals with StandardMaterial
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.9; // Adjust exposure

            // --- ADJUSTED Lighting ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Less intense ambient
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Slightly stronger directional
            directionalLight.position.set(15, 20, 15); // Higher angle
            directionalLight.castShadow = true;
             directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048;
             directionalLight.shadow.camera.near = 1; directionalLight.shadow.camera.far = 80; // Adjust shadow camera bounds
             directionalLight.shadow.camera.left = -35; directionalLight.shadow.camera.right = 35;
             directionalLight.shadow.camera.top = 35; directionalLight.shadow.camera.bottom = -35;
             directionalLight.shadow.bias = -0.001; // Fine-tune bias
            scene.add(directionalLight);
            // const lightHelper = new THREE.DirectionalLightHelper(directionalLight, 5); scene.add(lightHelper); // Optional helper
            // const shadowHelper = new THREE.CameraHelper(directionalLight.shadow.camera); scene.add(shadowHelper); // Optional helper

            // --- Walls (Uses new material) ---
            const wallHeight = 4; const wallThickness = 1; const wallLength = 300;
            const wallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wallLength);
            // wallMaterial is now created in preloadAssets
            const wallXOffset = laneLength / 2 + wallThickness / 2; const wallZCenter = -(generationDistance * laneWidth / 2);
            const leftWall = new THREE.Mesh(wallGeometry, wallMaterial.clone()); // Clone material if needed
            leftWall.position.set(-wallXOffset, wallHeight / 2, wallZCenter); leftWall.receiveShadow = true; scene.add(leftWall);
            const rightWall = new THREE.Mesh(wallGeometry, wallMaterial.clone());
            rightWall.position.set(wallXOffset, wallHeight / 2, wallZCenter); rightWall.receiveShadow = true; scene.add(rightWall);

            // Preload Assets & Generate Textures
            preloadAssets(); // Creates laneMaterials and wallMaterial

            // Setup UI Buttons
            populateCharacterButtons(); startGameButton.onclick = startGame;
            viewScoresButton.onclick = () => { displayHighScoresOnScreen(); currentGameState = GAME_STATE.SHOW_SCORES; showOverlay(scoreboardScreenElement); };
            backToMenuButton.onclick = goToMenu;

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false); document.addEventListener('keydown', onKeyDown, false);

            // Initial State
            goToMenu();

            // Start main loop
            animate();
         }

        // --- Game Start Logic ---
        function startGame() { /* ... as before ... */
            console.log("Starting game..."); score = 0; playerPosition = { x: 0, z: 0 }; targetPlayerPosition = { x: 0, z: 0 }; lastLaneZ = 0; isMoving = false; infoElement.innerText = `Score: ${score}`;
            clearGameObjects(); createPlayer(); createLane(LANE_TYPES.CARPET, 0); for (let i = 1; i < generationDistance; i++) generateLane();
            camera.position.set(0, 9, 8); camera.lookAt(0, 1, 0); // Reset camera to adjusted angle
            currentGameState = GAME_STATE.PLAYING; showOverlay(null); infoElement.classList.remove('hidden');
            if (!clock.running) clock.start(); if (!animationFrameId) animate();
         }

        // --- Clear Game Objects ---
        function clearGameObjects() { /* ... as before ... */
             console.log("Clearing game objects..."); for (let i = obstacles.length - 1; i >= 0; i--) if (obstacles[i].mesh.parent) scene.remove(obstacles[i].mesh); obstacles = [];
             for (let i = lanes.length - 1; i >= 0; i--) if (lanes[i].mesh.parent) scene.remove(lanes[i].mesh); lanes = [];
             if (player && player.parent) scene.remove(player); player = null; playerBoundingBox = null;
         }

        // --- Create Player (Uses MeshBasicMaterial) ---
        function createPlayer() {
            const character = CHARACTERS[selectedCharacterIndex]; const playerW = character.width; const playerH = character.height; const playerBaseY = playerH / 2; let playerMaterial, playerGeometry;
            if (character.imageUrl && characterTextures[selectedCharacterIndex]) {
                playerGeometry = new THREE.PlaneGeometry(playerW, playerH);
                // --- NEW: Use MeshBasicMaterial for player sprite ---
                playerMaterial = new THREE.MeshBasicMaterial({
                    map: characterTextures[selectedCharacterIndex],
                    transparent: true,
                    // side: THREE.DoubleSide // Usually not needed for BasicMaterial unless camera goes behind
                });
                console.log(`Using texture (Basic) for ${character.name}`);
            } else {
                playerGeometry = new THREE.BoxGeometry(playerW, playerH, playerW);
                playerMaterial = new THREE.MeshStandardMaterial({ color: DEFAULT_PLAYER_COLOR, roughness: 0.6 }); // Use Standard for cube
                console.log(`Using default cube for ${character.name}`);
            }
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(playerPosition.x, playerBaseY, playerPosition.z);
            player.castShadow = true; // Player still casts shadow
            player.receiveShadow = false;
            scene.add(player);
            playerBoundingBox = new THREE.Box3().setFromObject(player);
         }

        // --- UPDATED Lane Generation (Uses new materials) ---
        function createLane(type, zPos) {
            const laneGeometry = new THREE.PlaneGeometry(laneLength, laneWidth);
            // Get the appropriate pre-generated material
            const laneMaterial = laneMaterials[type] || new THREE.MeshStandardMaterial({color: 0xff00ff}); // Fallback pink

            let laneData = { mesh: null, type: type, z: zPos, obstacles: [] };

            const laneMesh = new THREE.Mesh(laneGeometry, laneMaterial); // Use shared/cached material
            laneMesh.rotation.x = -Math.PI / 2; laneMesh.position.set(0, 0, zPos);
            laneMesh.receiveShadow = true; // Lanes receive shadows
            scene.add(laneMesh);
            laneData.mesh = laneMesh; lanes.push(laneData);

            if (type === LANE_TYPES.WALKWAY) addObstaclesToLane(laneData); // Add obstacles to walkways
            lastLaneZ = zPos; return laneData;
         }
        function generateLane() { /* ... as before ... */
             const nextZ = lastLaneZ - laneWidth; const probabilityOfWalkway = Math.max(0.55, Math.min(0.9, 0.55 + Math.abs(nextZ / 70))); const laneType = Math.random() < probabilityOfWalkway ? LANE_TYPES.WALKWAY : LANE_TYPES.CARPET; createLane(laneType, nextZ);
        }

        // --- UPDATED Obstacle Generation (Uses MeshBasicMaterial) ---
        function addObstaclesToLane(laneData) {
             const maxObstacles = Math.min(5, 1 + Math.floor(score / 10));
             const numObstacles = Math.floor(Math.random() * maxObstacles) + 1;
             const speedMultiplier = 1 + Math.min(1.5, score / 80);
             const baseSpeed = (0.05 + Math.random() * 0.06) * speedMultiplier;
             const speed = baseSpeed * (Math.random() < 0.5 ? 1 : -1);
             const direction = Math.sign(speed);
             const startEdge = (laneLength / 2 + 3) * direction * -1;
             const minSpacing = 5;
             const totalSpacingNeeded = (numObstacles -1) * minSpacing;
             const randomSpacingPool = Math.max(0, laneLength - totalSpacingNeeded);
             let currentX = startEdge;
             const availableObstacleTypes = Object.keys(OBSTACLE_TYPES);

             for (let i = 0; i < numObstacles; i++) {
                 const randomTypeKey = availableObstacleTypes[Math.floor(Math.random() * availableObstacleTypes.length)];
                 const obstacleType = OBSTACLE_TYPES[randomTypeKey];
                 const obstacleTexture = obstacleTextures[obstacleType];
                 const obstacleW = OBSTACLE_PLANE_WIDTH; const obstacleH = OBSTACLE_PLANE_HEIGHT;
                 const obstacleYPosition = obstacleH / 2;

                 const obstacleGeometry = new THREE.PlaneGeometry(obstacleW, obstacleH);
                 // --- NEW: Use MeshBasicMaterial for obstacle sprites ---
                 const obstacleMaterial = new THREE.MeshBasicMaterial({
                     map: obstacleTexture || null,
                     color: obstacleTexture ? 0xffffff : DEFAULT_OBSTACLE_COLOR, // Apply color only if texture fails
                     transparent: true,
                 });

                 const obstacleMesh = new THREE.Mesh(obstacleGeometry, obstacleMaterial);

                 if (i > 0) { const spacingToAdd = minSpacing + (numObstacles > 1 ? Math.random() * (randomSpacingPool / (numObstacles - 1)) : 0); currentX -= spacingToAdd * direction; }
                 obstacleMesh.position.set(currentX, obstacleYPosition, laneData.z);
                 obstacleMesh.castShadow = true; // Sprites can still cast shadows
                 obstacleMesh.receiveShadow = false;
                 scene.add(obstacleMesh);

                 const obstacleBoundingBox = new THREE.Box3().setFromObject(obstacleMesh);
                 const obstacleData = { mesh: obstacleMesh, boundingBox: obstacleBoundingBox, speed: speed, direction: direction, laneZ: laneData.z, type: obstacleType };
                 obstacles.push(obstacleData); laneData.obstacles.push(obstacleData);
             }
         }

        // --- Game Loop (Unchanged) ---
        function animate() { /* ... */
            animationFrameId = requestAnimationFrame(animate);
            if (currentGameState === GAME_STATE.PLAYING) { const deltaTime = clock.getDelta(); movePlayerVisually(deltaTime); moveObstacles(); if (player) playerBoundingBox.setFromObject(player); checkCollisions(); updateCamera(); if (player && player.position.z < lastLaneZ + (generationDistance * laneWidth)) generateLane(); cleanupEnvironment(); }
            else if (currentGameState === GAME_STATE.GAME_OVER) { if (player && player.scale.x > 0.01) player.scale.multiplyScalar(0.9); else if (player) player.scale.set(0,0,0); }
            renderer.render(scene, camera);
         }

        // --- Player Movement (Unchanged) ---
        function movePlayerVisually(deltaTime) { /* ... */
             if (!player || !isMoving) return; const character = CHARACTERS[selectedCharacterIndex]; const playerBaseY = character.height / 2; const elapsedTime = clock.elapsedTime * 1000 - moveStartTime; let progress = Math.min(1.0, elapsedTime / moveDuration); const easedProgress = progress * (2 - progress); const startVec = new THREE.Vector3(playerPosition.x, playerBaseY, playerPosition.z); const endVec = new THREE.Vector3(targetPlayerPosition.x, playerBaseY, targetPlayerPosition.z); player.position.lerpVectors(startVec, endVec, easedProgress); const hopHeight = 0.5; player.position.y = playerBaseY + Math.sin(progress * Math.PI) * hopHeight;
             if (progress >= 1.0) { player.position.copy(endVec); player.position.y = playerBaseY; isMoving = false; playerPosition.x = targetPlayerPosition.x; playerPosition.z = targetPlayerPosition.z; if (player) playerBoundingBox.setFromObject(player); }
         }

        // --- Obstacle Movement (Unchanged) ---
        function moveObstacles() { /* ... */
             const wrapEdge = laneLength / 2 + 4; obstacles.forEach(obstacle => { let currentSpeed = obstacle.speed; obstacle.mesh.position.x += currentSpeed; if (obstacle.direction > 0 && obstacle.mesh.position.x > wrapEdge) obstacle.mesh.position.x = -wrapEdge; else if (obstacle.direction < 0 && obstacle.mesh.position.x < -wrapEdge) obstacle.mesh.position.x = wrapEdge; obstacle.boundingBox.setFromObject(obstacle.mesh); });
         }

        // --- Camera Update (Unchanged) ---
         function updateCamera() { /* ... */
             if (!player) return; const targetCameraPosition = new THREE.Vector3( player.position.x, camera.position.y, player.position.z + 7 ); camera.position.lerp(targetCameraPosition, 0.06); const targetLookAt = new THREE.Vector3( player.position.x, 0.5, player.position.z - 6 ); const currentLookAt = new THREE.Vector3(); camera.getWorldDirection(currentLookAt).multiplyScalar(10).add(camera.position); currentLookAt.lerp(targetLookAt, 0.07); camera.lookAt(currentLookAt);
          }

        // --- Collision Detection (Unchanged) ---
        function checkCollisions() { /* ... */
             if (!player || isMoving || currentGameState !== GAME_STATE.PLAYING) return; obstacles.forEach(obstacle => { if (Math.abs(player.position.z - obstacle.laneZ) < laneWidth / 2) { if (playerBoundingBox.intersectsBox(obstacle.boundingBox)) triggerGameOver(); } });
           }

        // --- Environment Cleanup (Unchanged) ---
        function cleanupEnvironment() { /* ... */
              const cleanupThresholdZ = (player ? player.position.z : 0) + (cleanupBuffer * laneWidth);
              lanes = lanes.filter(lane => { if (lane.z < cleanupThresholdZ) return true; else { lane.obstacles.forEach(obstacle => { const index = obstacles.indexOf(obstacle); if (index > -1) obstacles.splice(index, 1); if (obstacle.mesh.parent) scene.remove(obstacle.mesh); }); if (lane.mesh.parent) scene.remove(lane.mesh); return false; } });
              obstacles = obstacles.filter(obstacle => { if (obstacle.laneZ < cleanupThresholdZ) return true; else { if (obstacle.mesh.parent) scene.remove(obstacle.mesh); return false; } });
          }

        // --- Player Controls (Unchanged) ---
        function onKeyDown(event) { /* ... */
            if (currentGameState !== GAME_STATE.PLAYING || isMoving) return; let moved = false; const currentX = playerPosition.x; const currentZ = playerPosition.z;
            switch (event.key) { case 'ArrowUp': case 'w': targetPlayerPosition.z = currentZ - laneWidth; targetPlayerPosition.x = currentX; score++; infoElement.innerText = `Score: ${score}`; moved = true; break; case 'ArrowLeft': case 'a': targetPlayerPosition.x = currentX - laneWidth; targetPlayerPosition.z = currentZ; moved = true; break; case 'ArrowRight': case 'd': targetPlayerPosition.x = currentX + laneWidth; targetPlayerPosition.z = currentZ; moved = true; break; case 'ArrowDown': case 's': targetPlayerPosition.z = currentZ + laneWidth; targetPlayerPosition.x = currentX; moved = true; break; }
            const nextX = targetPlayerPosition.x; const wallBoundary = laneLength / 2; if (moved && (nextX > wallBoundary || nextX < -wallBoundary)) { moved = false; targetPlayerPosition.x = currentX; targetPlayerPosition.z = currentZ; }
            if (moved) { isMoving = true; moveStartTime = clock.elapsedTime * 1000; }
        }

        // --- Game State Transitions (Unchanged) ---
        function triggerGameOver() { /* ... */
            if (currentGameState !== GAME_STATE.PLAYING) return; currentGameState = GAME_STATE.GAME_OVER; console.log("Game Over! Score:", score); finalScoreElement.innerText = score; showOverlay(gameOverElement);
            const highScores = getHighScores(); const scoreNeeded = highScores.length < MAX_HIGH_SCORES ? 0 : highScores[MAX_HIGH_SCORES - 1].score;
            if (score > 0 && score >= scoreNeeded) { const characterName = CHARACTERS[selectedCharacterIndex].name; console.log(`New Top 3 Score with character: ${characterName}`); highScores.push({ name: characterName, score: score }); saveHighScores(highScores); console.log("New high score saved!"); }
        }
        function goToMenu() { /* ... */
             currentGameState = GAME_STATE.MENU; showOverlay(mainMenuElement);
         }

        // --- Utility Functions (Unchanged) ---
        function onWindowResize() { /* ... */
             camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
         }

        // --- Start the application ---
        init();

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Office Crossing Challenge - Firebase Edition!</title>
    <style>
        /* Basic styling for the game elements */
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            font-family: sans-serif;
            background: linear-gradient(to bottom, #87CEEB, #B0E0E6); /* Light blue gradient background */
            color: #333;
            height: 100vh; /* Full viewport height */
        }
        canvas {
            display: block; /* Remove extra space below canvas */
            width: 100%; /* Make canvas fill width */
            height: 100%; /* Make canvas fill height */
        }
        /* Styling for overlay menus (Main Menu, Scoreboard, Game Over) */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background-color: rgba(0, 0, 0, 0.75); /* Semi-transparent black background */
            color: white;
            z-index: 100; /* Ensure overlays are on top */
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
        }
        .hidden {
            display: none; /* Class to hide overlays */
        }
        .overlay-content {
            background-color: rgba(40, 60, 80, 0.9); /* Darker, slightly transparent box for content */
            padding: 30px 40px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4); /* Drop shadow */
            max-width: 90%;
            width: 450px; /* Fixed width for the content box */
        }
        .overlay h2 {
            margin-top: 0;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.5); /* Separator line */
            padding-bottom: 10px;
            color: #FFD700; /* Gold color for headings */
        }
        .overlay button {
            display: block;
            width: 80%;
            margin: 15px auto; /* Center buttons */
            padding: 12px 20px;
            font-size: 18px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background-color: #4682B4; /* Steel blue button */
            color: white;
            transition: background-color 0.3s, transform 0.1s; /* Smooth transitions */
            box-shadow: 0 4px 6px rgba(0,0,0,0.2); /* Button shadow */
        }
        .overlay button:hover {
            background-color: #5A9BD5; /* Lighter blue on hover */
        }
        .overlay button:active {
            transform: scale(0.95); /* Slight shrink effect on click */
            background-color: #41729F; /* Darker blue on click */
        }
        /* Character Selection Specific Styles */
        #mainMenu .character-selection {
            margin-bottom: 20px;
            padding: 10px;
            background-color: rgba(255,255,255,0.1); /* Slightly lighter background for selection area */
            border-radius: 8px;
            max-height: 250px; /* Limit height and allow scrolling */
            overflow-y: auto;
        }
        #mainMenu .character-selection h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 16px;
        }
        #mainMenu .char-button {
            display: inline-block; /* Allow buttons side-by-side */
            width: auto; /* Fit content */
            padding: 8px 15px;
            margin: 5px;
            font-size: 14px;
            border: 2px solid transparent; /* Border for selection indicator */
            background-color: #6c757d; /* Grey button */
        }
        #mainMenu .char-button.selected {
            border-color: #FFD700; /* Gold border for selected character */
            background-color: #4682B4; /* Blue background for selected */
        }
        /* Scoreboard Specific Styles */
        #scoreboardScreen ol {
            margin: 0 0 15px 0;
            padding: 0 0 0 25px; /* Indent list items */
            list-style-position: outside;
            max-height: 150px; /* Limit height and allow scrolling */
            overflow-y: auto;
        }
        #scoreboardScreen li {
            margin-bottom: 8px;
            white-space: nowrap; /* Prevent wrapping */
            overflow: hidden; /* Hide overflow */
            text-overflow: ellipsis; /* Add ... for long names */
            font-size: 16px;
            border-bottom: 1px dotted rgba(255, 255, 255, 0.2); /* Dotted separator */
            padding-bottom: 4px;
        }
        #scoreboardScreen li:last-child {
            border-bottom: none; /* Remove border from last item */
        }
        #scoreboardScreen li span {
            display: inline-block; /* Needed for positioning */
        }
        #scoreboardScreen li .score {
            float: right; /* Align score to the right */
            font-weight: bold;
            margin-left: 15px;
        }
        #scoreboardScreen .no-scores {
            text-align: center;
            font-style: italic;
            color: #ccc; /* Lighter color for message */
            margin-top: 10px;
        }
        /* In-Game Score Display */
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            width: auto;
            text-align: left;
            z-index: 50; /* Below overlays */
            display: block;
            color: #000080; /* Navy blue text */
            font-size: 24px;
            font-weight: bold;
            text-shadow: 1px 1px 1px #FFFFFF; /* White text shadow for readability */
            background-color: rgba(255, 255, 255, 0.6); /* Semi-transparent white background */
            padding: 5px 10px;
            border-radius: 5px;
        }
        /* Game Over Specific Styles */
        #gameOver {
            z-index: 101; /* Ensure Game Over is on top if needed */
        }
        #gameOverReason {
            font-size: 24px;
            margin-bottom: 15px;
            font-style: italic;
            color: #ffdddd; /* Light red color for the reason */
        }
    </style>
</head>
<body>
    <div id="info" class="hidden">Score: 0</div>

    <div id="mainMenu" class="overlay">
        <div class="overlay-content">
            <h2>Ops & QA Crossing Challenge</h2>
            <div class="character-selection">
                <h3>Select Character</h3>
                <div id="characterButtons">
                    </div>
            </div>
            <button id="startGameButton">Start Game</button>
            <button id="viewScoresButton">High Scores</button>
        </div>
    </div>

    <div id="scoreboardScreen" class="overlay hidden">
        <div class="overlay-content">
            <h2>High Scores</h2>
            <ol id="scoreList"></ol>
            <div id="noScoresMessage" class="no-scores" style="display: none;">Loading scores...</div>
            <button id="backToMenuButton">Back to Menu</button>
        </div>
    </div>

    <div id="gameOver" class="overlay hidden">
        <div class="overlay-content">
            <h2 id="gameOverReason">You lost, go back to work!</h2>
            Final Score: <span id="finalScore">0</span><br>
            <button onclick="goToMenu()">Main Menu</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-firestore-compat.js"></script>

    <script>
        // --- Firebase Configuration ---
        // IMPORTANT: Replace with your actual Firebase project configuration!
        // It's recommended to use environment variables or a backend to manage API keys in production.
        const firebaseConfig = {
            apiKey: "YOUR_API_KEY", // Replace with your actual API key
            authDomain: "YOUR_AUTH_DOMAIN", // Replace with your actual auth domain
            projectId: "YOUR_PROJECT_ID", // Replace with your actual project ID
            storageBucket: "YOUR_STORAGE_BUCKET", // Replace with your actual storage bucket
            messagingSenderId: "YOUR_MESSAGING_SENDER_ID", // Replace with your actual sender ID
            appId: "YOUR_APP_ID" // Replace with your actual app ID
        };

        // --- Initialize Firebase ---
        let db; // Firestore database instance
        let highScoresCollection; // Reference to the high scores collection
        try {
            firebase.initializeApp(firebaseConfig);
            db = firebase.firestore(); // Get a Firestore instance
            highScoresCollection = db.collection('highscores'); // Reference to the 'highscores' collection
            console.log("Firebase initialized successfully.");
        } catch (e) {
            console.error("Firebase initialization failed:", e);
            // Alert the user or handle the lack of Firebase connection gracefully
            alert("Could not connect to Firebase. High score functionality will be unavailable.");
            // Optionally, disable high score features in the UI
        }

        // --- Game States ---
        // Define possible states the game can be in
        const GAME_STATE = { MENU: 'menu', PLAYING: 'playing', GAME_OVER: 'game_over', SHOW_SCORES: 'show_scores' };
        let currentGameState = GAME_STATE.MENU; // Start in the main menu

        // --- Global Game Variables ---
        let scene, camera, renderer; // Three.js core components
        let player, playerBoundingBox; // Player object and its collision box
        let lanes = []; // Array to hold lane data (type, position, obstacles, etc.)
        let obstacles = []; // Array to hold active obstacle objects
        let score = 0; // Current game score
        let scenery = []; // Array for decorative scenery objects (desks, plants)
        let safeSpots = []; // Array for safe spots on water lanes (logs, platforms)
        let wallSegments = []; // Array for the side walls to keep the player contained
        let laneWidth = 6; // Width of each lane
        let laneLength = 80; // Length of the visible lane area (affects wall placement)
        let playerPosition = { x: 0, z: 0 }; // Logical grid position of the player (column, row)
        let targetPlayerPosition = { x: 0, z: 0 }; // Target world position for smooth player movement
        let isMoving = false; // Flag to indicate if the player is currently animating a move
        let moveDuration = 150; // Duration of player move animation in milliseconds
        let moveStartTime = 0; // Timestamp when the current move started
        let lastLaneZ = 0; // Z-position of the furthest generated lane
        let generationDistance = 20; // How many lanes ahead of the player to generate
        let cleanupBuffer = 5; // How many lanes behind the player to keep before removing
        let clock = new THREE.Clock(); // Three.js clock for delta time (smooth animations)
        let textureLoader = new THREE.TextureLoader(); // Utility for loading image textures
        const MAX_HIGH_SCORES = 10; // Maximum number of high scores to store and display
        let animationFrameId = null; // ID for the requestAnimationFrame loop (to cancel it)
        let laneMaterials = {}; // Cache for lane materials to avoid recreating them
        let wallMaterial; // Material for side walls
        let sceneryMaterials = {}; // Cache for scenery materials
        let lastMoveTime = 0; // Timestamp of the last player move (for idle check)
        const MAX_IDLE_TIME = 10.0; // Maximum time (seconds) player can be idle before game over
        let directionalLight; // Main light source for shadows

        // --- Wall Constants ---
        const WALL_HEIGHT = 8; // How tall the side walls are
        const WALL_THICKNESS = 1.0; // How thick the side walls are

        // --- Character Definitions ---
        // Add or remove characters here.
        // Ensure image paths are correct relative to the HTML file OR use null for default.
        // Width and height define the size of the character plane.
        const CHARACTERS = [
             { name: 'Alon', imageUrl: 'Alon.png', width: 2.8, height: 3.36 },
             { name: 'Sahar', imageUrl: 'Sahar.png', width: 2.8, height: 3.36 },
             { name: 'Mor', imageUrl: 'Mor.png', width: 2.8, height: 3.36 },
             { name: 'Lin', imageUrl: 'Lin.png', width: 2.8, height: 3.36 },
             { name: 'Asaf', imageUrl: 'Asaf.png', width: 2.8, height: 3.36 },
             { name: 'Tal', imageUrl: 'Tal.png', width: 2.8, height: 3.36 },
             { name: 'Ron', imageUrl: 'Ron.png', width: 2.8, height: 3.36 },
             { name: 'Hadar', imageUrl: 'Hadar.png', width: 2.8, height: 3.36 },
             { name: 'Adi', imageUrl: 'Adi.png', width: 2.8, height: 3.36 },
             { name: 'Alex', imageUrl: 'Alex.png', width: 2.8, height: 3.36 },
             { name: 'Amit', imageUrl: 'Amit.png', width: 2.8, height: 3.36 },
             { name: 'Anna', imageUrl: 'Anna.png', width: 2.8, height: 3.36 },
             { name: 'May Boss', imageUrl: 'May Boss.png', width: 2.8, height: 3.36 },
             { name: 'May QA', imageUrl: 'May QA.png', width: 2.8, height: 3.36 },
             { name: 'Ofek', imageUrl: 'Ofek.png', width: 2.8, height: 3.36 },
             // --- ADDED CHARACTERS ---
             { name: 'Oleksandr', imageUrl: 'Oleksandr.png', width: 2.8, height: 3.36 }, // Added Oleksandr
             { name: 'Ernest', imageUrl: 'Ernest.png', width: 2.8, height: 3.36 },     // Added Ernest
             // --- END ADDED CHARACTERS ---
             { name: 'Default', imageUrl: null, width: 2.2, height: 2.2 } // Fallback if images fail or not provided
        ];
        let selectedCharacterIndex = 0; // Index of the currently selected character in the CHARACTERS array
        let characterTextures = {}; // Cache for loaded character textures to improve performance

        // --- Theme Constants & Colors ---
        const LANE_TYPES = { CARPET: 'carpet', WALKWAY: 'walkway', WATER: 'water' }; // Types of lanes
        const DEFAULT_PLAYER_COLOR = 0xADD8E6; // Light blue for default player cube
        const DEFAULT_OBSTACLE_COLOR = 0xff00ff; // Magenta for default obstacle cube
        const SCENERY_COLORS = { DESK: 0xAF8F6D, PLANT_POT: 0xCD853F, PLANT_LEAF: 0x2E8B57 }; // Colors for scenery elements
        const SAFE_SPOT_COLOR = 0x90EE90; // Light green for safe spots on water
        const WATER_COLOR = 0x1E90FF; // Dodger blue for water lanes

        // --- Obstacle Definitions ---
        // Define types of obstacles and their corresponding image files.
        // 'right' image is for obstacles moving right, 'left' for obstacles moving left.
        const OBSTACLE_TYPES = { CC: 'cc', LIVE_CHANGE: 'live_change', ON_CALL: 'on_call' };
        const OBSTACLE_IMAGES = {
            [OBSTACLE_TYPES.CC]: { right: 'CC.png', left: 'CC R.png' },
            [OBSTACLE_TYPES.LIVE_CHANGE]: { right: 'Live Change.png', left: 'Live Change R.png' },
            [OBSTACLE_TYPES.ON_CALL]: { right: 'On Call.png', left: 'On Call R.png' }
        };
        let obstacleTextures = {}; // Cache for loaded obstacle textures
        const OBSTACLE_PLANE_WIDTH = 5.0; // Visual width of obstacle planes using images
        const OBSTACLE_PLANE_HEIGHT = 5.0; // Visual height of obstacle planes using images

        // --- DOM Element References ---
        // Get references to HTML elements used for UI
        let infoElement, mainMenuElement, scoreboardScreenElement, gameOverElement;
        let characterButtonsElement, startGameButton, viewScoresButton, backToMenuButton;
        let scoreListElement, noScoresMessageElement, finalScoreElement, gameOverReasonElement;

        // --- Texture Generation Functions (Procedural textures for variety) ---

        /**
         * Creates a simple noise texture programmatically.
         * Used for adding subtle detail to flat surfaces.
         * @param {number} width - Texture width.
         * @param {number} height - Texture height.
         * @param {string} color1 - Base color (hex string or CSS color name).
         * @param {string} color2 - Noise color (typically darker).
         * @param {number} [alpha=1] - Opacity (0 to 1).
         * @returns {THREE.CanvasTexture} The generated texture.
         */
        function createNoiseTexture(width, height, color1, color2, alpha = 1) {
            const canvas = document.createElement('canvas');
            canvas.width = width; canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color1;
            ctx.fillRect(0, 0, width, height);
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            // Add random darker pixels for noise effect
            for (let i = 0; i < data.length; i += 4) {
                if (Math.random() > 0.85) { // Adjust density of noise
                    const shade = Math.random() * 50 + (color2 === '#000000' ? 0 : 205); // Calculate shade based on noise color
                    data[i] = shade; data[i + 1] = shade; data[i + 2] = shade; // Apply shade (grayscale noise)
                }
                data[i + 3] = alpha * 255; // Set alpha (opacity)
            }
            ctx.putImageData(imageData, 0, 0);
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping; // Allow texture tiling
            texture.needsUpdate = true; // Ensure texture updates
            return texture;
        }

        /**
         * Creates a simple tile pattern texture programmatically.
         * Used for walkway lanes.
         * @param {number} width - Texture width.
         * @param {number} height - Texture height.
         * @param {string} bgColor - Background color of the tiles.
         * @param {string} lineColor - Color of the tile grid lines.
         * @param {number} tileSize - Size of each square tile.
         * @returns {THREE.CanvasTexture} The generated texture.
         */
        function createTileTexture(width, height, bgColor, lineColor, tileSize) {
            const canvas = document.createElement('canvas');
            canvas.width = width; canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, width, height);
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = Math.max(1, Math.floor(width / 100)); // Line thickness relative to texture size
            ctx.beginPath();
            // Draw vertical lines
            for (let x = 0; x <= width; x += tileSize) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
            // Draw horizontal lines
            for (let y = 0; y <= height; y += tileSize) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
            ctx.stroke();
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping; // Allow texture tiling
            texture.needsUpdate = true; // Ensure texture updates
            return texture;
        }

        // --- Firebase Leaderboard Functions ---

        /**
         * Fetches the top high scores from Firebase Firestore and displays them.
         * Uses async/await for cleaner asynchronous code. Handles loading and error states.
         */
        async function fetchAndDisplayHighScores() {
            if (!highScoresCollection) {
                console.warn("Firestore not initialized. Cannot fetch scores.");
                noScoresMessageElement.textContent = 'High scores unavailable (DB connection failed).';
                noScoresMessageElement.style.display = 'block';
                scoreListElement.innerHTML = '';
                return;
            }

            console.log("Fetching high scores from Firebase...");
            scoreListElement.innerHTML = ''; // Clear previous scores list
            noScoresMessageElement.textContent = 'Loading scores...'; // Show loading indicator
            noScoresMessageElement.style.display = 'block';

            try {
                // Query Firestore for documents in 'highscores' collection
                const querySnapshot = await highScoresCollection
                    .orderBy('score', 'desc') // Order by score, highest first
                    .limit(MAX_HIGH_SCORES)   // Limit to the top N scores
                    .get();                   // Execute the query

                const scores = [];
                querySnapshot.forEach((doc) => {
                    // Extract data from each document
                    scores.push(doc.data());
                });

                console.log("Scores fetched:", scores);

                if (scores.length === 0) {
                    // Display message if no scores are found
                    noScoresMessageElement.textContent = 'No scores yet! Be the first!';
                    noScoresMessageElement.style.display = 'block';
                } else {
                    // Hide loading message and display scores
                    noScoresMessageElement.style.display = 'none';
                    scores.forEach((scoreEntry) => {
                        const li = document.createElement('li');
                        // Sanitize and shorten name display to prevent overflow/XSS
                        const displayName = scoreEntry.name ? String(scoreEntry.name).substring(0, 15).replace(/</g, "&lt;").replace(/>/g, "&gt;") : 'Anonymous';
                        // Ensure score is treated as a number
                        const displayScore = Number(scoreEntry.score) || 0;
                        // Use textContent for safety instead of innerHTML if possible
                        const nameSpan = document.createElement('span');
                        nameSpan.className = 'name';
                        nameSpan.textContent = displayName;
                        const scoreSpan = document.createElement('span');
                        scoreSpan.className = 'score';
                        scoreSpan.textContent = displayScore;
                        li.appendChild(nameSpan);
                        li.appendChild(scoreSpan);
                        scoreListElement.appendChild(li);
                    });
                }
            } catch (error) {
                console.error("Error fetching high scores: ", error);
                noScoresMessageElement.textContent = 'Error loading scores.'; // Show error message
                noScoresMessageElement.style.display = 'block';
                // Consider more specific error handling or logging
            }
        }

        /**
         * Saves a score to Firebase Firestore if it qualifies for the top list.
         * Manages the size of the high score list by pruning older/lower scores.
         * Uses async/await.
         * @param {string} playerName - The name of the player.
         * @param {number} newScore - The score achieved by the player.
         */
        async function saveScoreIfHighScore(playerName, newScore) {
             if (!highScoresCollection) {
                console.warn("Firestore not initialized. Cannot save score.");
                return; // Exit if DB connection failed
            }

            // Sanitize/limit name length and ensure score is a valid number
            const nameToSave = playerName ? String(playerName).substring(0, 20).trim() : 'Anonymous';
            const scoreToSave = Number(newScore);

            if (isNaN(scoreToSave) || scoreToSave <= 0) {
                console.log(`Score (${newScore}) is invalid or zero, not saving.`);
                return; // Don't save zero, negative, or non-numeric scores
            }

            console.log(`Checking if score ${scoreToSave} for ${nameToSave} is a high score...`);

            try {
                // Get current top scores to determine if the new score is high enough
                const querySnapshot = await highScoresCollection
                    .orderBy('score', 'desc')
                    .limit(MAX_HIGH_SCORES)
                    .get();

                const currentTopScores = [];
                querySnapshot.forEach(doc => currentTopScores.push({ id: doc.id, ...doc.data() }));

                // Find the lowest score currently in the top list
                const lowestTopScore = currentTopScores.length > 0 ? (Number(currentTopScores[currentTopScores.length - 1].score) || 0) : 0;

                // Determine if the new score qualifies
                const isHighScore = scoreToSave > lowestTopScore || currentTopScores.length < MAX_HIGH_SCORES;

                if (isHighScore) {
                    console.log(`New high score! Saving ${nameToSave}: ${scoreToSave}`);
                    // Add the new high score document
                    await highScoresCollection.add({
                        name: nameToSave,
                        score: scoreToSave,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp() // Record time
                    });
                    console.log("New score added to Firestore.");

                    // --- Pruning Logic: Keep only the top MAX_HIGH_SCORES ---
                    // After adding, check if we exceed the limit and remove the lowest score(s).
                    const allScoresSnapshot = await highScoresCollection
                        .orderBy('score', 'desc') // Get all scores, highest first
                        .get();

                    if (allScoresSnapshot.size > MAX_HIGH_SCORES) {
                        // Identify scores to delete (those beyond the limit)
                        const scoresToDelete = allScoresSnapshot.docs.slice(MAX_HIGH_SCORES);
                        const batch = db.batch(); // Use a batch for efficient deletion
                        scoresToDelete.forEach(doc => {
                            console.log(`Pruning score ${doc.data().score} (ID: ${doc.id})`);
                            batch.delete(doc.ref); // Add delete operation to the batch
                        });
                        await batch.commit(); // Execute the batch delete
                        console.log(`${scoresToDelete.length} lowest score(s) pruned.`);
                    }
                } else {
                    console.log("Score is not high enough to make the leaderboard.");
                }
            } catch (error) {
                console.error("Error saving high score: ", error);
                // Optionally inform the user about the error (e.g., display a temporary message)
            }
        }

        // --- UI State Management ---

        /**
         * Shows a specific overlay menu (Main Menu, Scoreboard, Game Over)
         * and hides the others, including the in-game score display.
         * @param {HTMLElement | null} overlayElement - The overlay element to show, or null to hide all.
         */
        function showOverlay(overlayElement) {
            // Hide all overlays first
            mainMenuElement.classList.add('hidden');
            scoreboardScreenElement.classList.add('hidden');
            gameOverElement.classList.add('hidden');
            infoElement.classList.add('hidden'); // Hide in-game score when an overlay is shown

            // Show the specified overlay if provided
            if (overlayElement) {
                overlayElement.classList.remove('hidden');
            }
        }

        // --- Character Selection Logic ---

        /**
         * Updates the selected character index and reflects the change in the UI.
         * @param {number} index - The index of the character selected in the CHARACTERS array.
         */
        function selectCharacter(index) {
            if (index >= 0 && index < CHARACTERS.length) {
                selectedCharacterIndex = index;
                updateCharacterButtonSelection(); // Update button visuals
                console.log(`Selected character: ${CHARACTERS[selectedCharacterIndex].name}`);
                // Optionally: Update a preview image if you have one
            }
        }

        /**
         * Updates the visual style ('selected' class) of character buttons
         * based on the currently selectedCharacterIndex.
         */
        function updateCharacterButtonSelection() {
            const buttons = characterButtonsElement.querySelectorAll('.char-button');
            buttons.forEach((button, index) => {
                if (index === selectedCharacterIndex) {
                    button.classList.add('selected'); // Highlight the selected button
                } else {
                    button.classList.remove('selected'); // Remove highlight from others
                }
            });
        }

        /**
         * Populates the character selection area in the main menu
         * with buttons for each defined character.
         */
        function populateCharacterSelection() {
            characterButtonsElement.innerHTML = ''; // Clear existing buttons
            CHARACTERS.forEach((char, index) => {
                const button = document.createElement('button');
                button.classList.add('char-button');
                button.textContent = char.name;
                // Add click listener to select the character
                button.addEventListener('click', () => selectCharacter(index));
                characterButtonsElement.appendChild(button);
            });
            // Set the initial selection visual state
            updateCharacterButtonSelection();
        }

        // --- Preloading Assets ---

        /**
         * Loads character and obstacle image textures asynchronously.
         * Stores loaded textures in caches (characterTextures, obstacleTextures).
         * Uses Promises to track loading progress.
         */
        function preloadAssets() {
            const promises = [];

            // Preload Character Textures
            CHARACTERS.forEach(char => {
                if (char.imageUrl) {
                    const promise = new Promise((resolve, reject) => {
                        textureLoader.load(
                            char.imageUrl,
                            (texture) => {
                                characterTextures[char.name] = texture; // Cache the loaded texture
                                console.log(`Loaded character texture: ${char.imageUrl}`);
                                resolve();
                            },
                            undefined, // Progress callback (optional)
                            (error) => {
                                console.error(`Failed to load character texture: ${char.imageUrl}`, error);
                                // Don't reject, allow game to continue with default
                                resolve(); // Resolve even on error to not block loading
                            }
                        );
                    });
                    promises.push(promise);
                }
            });

            // Preload Obstacle Textures
            Object.values(OBSTACLE_IMAGES).forEach(imageSet => {
                Object.values(imageSet).forEach(imageUrl => {
                     if (imageUrl && !obstacleTextures[imageUrl]) { // Avoid reloading the same image
                        const promise = new Promise((resolve, reject) => {
                            textureLoader.load(
                                imageUrl,
                                (texture) => {
                                    obstacleTextures[imageUrl] = texture; // Cache the loaded texture
                                    console.log(`Loaded obstacle texture: ${imageUrl}`);
                                    resolve();
                                },
                                undefined,
                                (error) => {
                                    console.error(`Failed to load obstacle texture: ${imageUrl}`, error);
                                    resolve(); // Resolve even on error
                                }
                            );
                        });
                        promises.push(promise);
                    }
                });
            });


            // Return a promise that resolves when all assets are attempted to load
            return Promise.all(promises);
        }


        // --- Game Initialization ---

        /**
         * Sets up the initial game scene, camera, renderer, lights,
         * player, initial lanes, event listeners, and UI elements.
         * Calls the main game loop to start.
         */
        async function init() {
            console.log("Initializing game...");

            // --- Get DOM Element References ---
            infoElement = document.getElementById('info');
            mainMenuElement = document.getElementById('mainMenu');
            scoreboardScreenElement = document.getElementById('scoreboardScreen');
            gameOverElement = document.getElementById('gameOver');
            characterButtonsElement = document.getElementById('characterButtons');
            startGameButton = document.getElementById('startGameButton');
            viewScoresButton = document.getElementById('viewScoresButton');
            backToMenuButton = document.getElementById('backToMenuButton');
            scoreListElement = document.getElementById('scoreList');
            noScoresMessageElement = document.getElementById('noScoresMessage');
            finalScoreElement = document.getElementById('finalScore');
            gameOverReasonElement = document.getElementById('gameOverReason');

            // --- Basic Scene Setup ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Light sky blue background
            scene.fog = new THREE.Fog(0x87CEEB, 30, 60); // Add fog for depth perception

            // --- Camera Setup ---
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            // Position the camera to look down at the player's starting area
            camera.position.set(0, 15, 12); // Elevated and slightly behind the start
            camera.lookAt(0, 0, 0); // Look towards the center of the starting area

            // --- Renderer Setup ---
            renderer = new THREE.WebGLRenderer({ antialias: true }); // Enable anti-aliasing for smoother edges
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Enable shadows
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
            document.body.appendChild(renderer.domElement); // Add the canvas to the HTML

            // --- Lighting Setup ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Soft white ambient light
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Brighter directional light
            directionalLight.position.set(5, 15, 10); // Position the light source
            directionalLight.castShadow = true; // Allow this light to cast shadows
            // Configure shadow properties for better performance/quality balance
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            // Optional: Add a light helper to visualize the light source
            // const lightHelper = new THREE.DirectionalLightHelper(directionalLight, 5);
            // scene.add(lightHelper);
            // const shadowCameraHelper = new THREE.CameraHelper(directionalLight.shadow.camera);
            // scene.add(shadowCameraHelper);


            // --- Material Caching ---
            // Create and cache materials that will be reused often
            laneMaterials[LANE_TYPES.CARPET] = new THREE.MeshLambertMaterial({
                map: createNoiseTexture(64, 64, '#A0522D', '#8B4513'), // Sienna/brown noise
                side: THREE.DoubleSide
            });
            laneMaterials[LANE_TYPES.CARPET].map.repeat.set(laneWidth / 4, laneLength / 4); // Adjust texture repeat

            laneMaterials[LANE_TYPES.WALKWAY] = new THREE.MeshLambertMaterial({
                map: createTileTexture(128, 128, '#D3D3D3', '#A9A9A9', 32), // Light grey tiles with dark grey lines
                side: THREE.DoubleSide
            });
            laneMaterials[LANE_TYPES.WALKWAY].map.repeat.set(laneWidth / 8, laneLength / 8); // Adjust texture repeat

            laneMaterials[LANE_TYPES.WATER] = new THREE.MeshPhongMaterial({
                color: WATER_COLOR,
                transparent: true,
                opacity: 0.8, // Make water slightly transparent
                shininess: 80, // Add some shine to the water
                side: THREE.DoubleSide
            });

            wallMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 }); // Grey walls

            sceneryMaterials.desk = new THREE.MeshLambertMaterial({ color: SCENERY_COLORS.DESK });
            sceneryMaterials.plantPot = new THREE.MeshLambertMaterial({ color: SCENERY_COLORS.PLANT_POT });
            sceneryMaterials.plantLeaf = new THREE.MeshLambertMaterial({ color: SCENERY_COLORS.PLANT_LEAF });


            // --- Preload Assets ---
            console.log("Starting asset preloading...");
            // Disable start button until assets are loaded
            startGameButton.disabled = true;
            startGameButton.textContent = "Loading Assets...";
            await preloadAssets(); // Wait for textures to load (or fail)
            console.log("Asset preloading finished.");
            // Re-enable start button
            startGameButton.disabled = false;
            startGameButton.textContent = "Start Game";


            // --- Player Setup ---
            createPlayer(); // Create the initial player object

            // --- Initial Lane Generation ---
            // Create the starting safe zone and the first few lanes
            createLane(LANE_TYPES.CARPET, 0); // Starting lane
            for (let i = 1; i < generationDistance / 2; i++) {
                generateRandomLane(); // Generate initial set of lanes
            }

            // --- Wall Generation ---
            createWalls(); // Create the initial side walls

            // --- Populate UI ---
            populateCharacterSelection(); // Add character buttons to the menu

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize, false); // Handle window resizing
            document.addEventListener('keydown', handleInput); // Handle keyboard input for player movement

            // Setup button listeners
            startGameButton.addEventListener('click', startGame);
            viewScoresButton.addEventListener('click', showScoreboard);
            backToMenuButton.addEventListener('click', goToMenu);

            // --- Initial State ---
            goToMenu(); // Show the main menu initially

            // --- Start Game Loop ---
            // Start the animation loop only AFTER the window is fully loaded
            // to ensure all resources (especially textures) are potentially ready.
            // Using window.onload is generally safer than starting immediately after init.
            window.onload = () => {
                console.log("Window loaded, starting animation loop.");
                if (!animationFrameId) { // Prevent multiple loops if init is called again
                    animate();
                }
            };
        }


        // --- Player Creation ---

        /**
         * Creates the player object (a plane with a character texture or a default cube).
         * Sets its initial position and adds it to the scene.
         * Creates a bounding box for collision detection.
         */
        function createPlayer() {
            // Remove existing player if it exists (e.g., on restart)
            if (player) scene.remove(player);

            const character = CHARACTERS[selectedCharacterIndex];
            const playerTexture = characterTextures[character.name]; // Get preloaded texture

            let playerGeometry, playerMaterial;

            // Use image texture if available and loaded, otherwise use default cube
            if (playerTexture) {
                playerGeometry = new THREE.PlaneGeometry(character.width, character.height);
                playerMaterial = new THREE.MeshLambertMaterial({
                    map: playerTexture,
                    transparent: true, // Allow transparency from PNG
                    side: THREE.DoubleSide, // Render both sides
                    alphaTest: 0.1 // Discard nearly transparent pixels
                });
            } else {
                // Fallback to a simple cube if texture failed or is null
                console.warn(`Texture for ${character.name} not found or failed to load. Using default cube.`);
                playerGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5); // Smaller default cube
                playerMaterial = new THREE.MeshLambertMaterial({ color: DEFAULT_PLAYER_COLOR });
            }

            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(0, character.height / 2, 0); // Position based on height (center bottom on ground)
            player.rotation.x = playerTexture ? 0 : 0; // Keep plane upright
            player.castShadow = true; // Player casts shadows
            player.receiveShadow = false; // Player doesn't receive shadows on itself (usually)
            scene.add(player);

            // --- Player Bounding Box ---
            // Create an invisible box around the player for simpler collision checks
            // Adjust size as needed for better collision feel
            const bboxSize = 1.5; // Make bounding box slightly smaller than visual player
            const bboxGeometry = new THREE.BoxGeometry(bboxSize, bboxSize, bboxSize);
            // Make bounding box invisible but wireframe for debugging
            const bboxMaterial = new THREE.MeshBasicMaterial({ wireframe: true, visible: false }); // Set visible: true to debug
            playerBoundingBox = new THREE.Mesh(bboxGeometry, bboxMaterial);
            playerBoundingBox.position.copy(player.position); // Match player position initially
            scene.add(playerBoundingBox); // Add bounding box to the scene

            // Reset player logical and target positions
            playerPosition = { x: 0, z: 0 };
            targetPlayerPosition = { x: player.position.x, z: player.position.z };
        }

        // --- Lane Generation ---

        /**
         * Creates a single lane of a specific type at a given Z position.
         * Adds the lane mesh to the scene and the lanes array.
         * @param {string} type - The type of lane (LANE_TYPES.CARPET, LANE_TYPES.WALKWAY, LANE_TYPES.WATER).
         * @param {number} z - The Z position for the center of the lane.
         */
        function createLane(type, z) {
            const laneGeometry = new THREE.PlaneGeometry(laneLength, laneWidth); // Note: Width/Length swapped for PlaneGeometry rotation
            const material = laneMaterials[type]; // Get cached material

            const laneMesh = new THREE.Mesh(laneGeometry, material);
            laneMesh.rotation.x = -Math.PI / 2; // Rotate plane to be horizontal
            laneMesh.position.set(0, 0, z); // Position the lane
            laneMesh.receiveShadow = true; // Lanes receive shadows
            scene.add(laneMesh);

            const laneData = {
                mesh: laneMesh,
                type: type,
                z: z,
                obstacles: [], // Array to hold obstacles specific to this lane
                scenery: [],   // Array to hold scenery specific to this lane
                safeSpots: [] // Array to hold safe spots specific to this lane (for water)
            };

            lanes.push(laneData);

            // --- Add Obstacles, Scenery, or Safe Spots based on lane type ---
            if (type === LANE_TYPES.WALKWAY) {
                addObstaclesToLane(laneData);
                addSceneryToLane(laneData, 'walkway');
            } else if (type === LANE_TYPES.CARPET) {
                addSceneryToLane(laneData, 'carpet'); // Add different scenery for carpet
            } else if (type === LANE_TYPES.WATER) {
                addSafeSpotsToLane(laneData); // Add logs/platforms to water lanes
            }

            lastLaneZ = z; // Update the position of the furthest generated lane
        }

        /**
         * Generates a new lane with a randomly chosen type, positioned after the last lane.
         */
        function generateRandomLane() {
            const laneTypes = Object.values(LANE_TYPES);
            const randomType = laneTypes[Math.floor(Math.random() * laneTypes.length)];
            const nextZ = lastLaneZ - laneWidth; // Calculate Z position for the next lane
            createLane(randomType, nextZ);
        }

        // --- Obstacle, Scenery, and Safe Spot Generation ---

        /**
         * Adds obstacles (moving objects) to a walkway lane.
         * Randomly determines the number, type, speed, and direction of obstacles.
         * @param {object} laneData - The data object for the lane.
         */
        function addObstaclesToLane(laneData) {
            const numObstacles = Math.floor(Math.random() * 3) + 1; // 1 to 3 obstacles per lane
            const speed = (Math.random() * 2 + 1) * (Math.random() < 0.5 ? 1 : -1); // Random speed and direction
            const obstacleTypeKeys = Object.keys(OBSTACLE_TYPES);
            const randomObstacleTypeKey = obstacleTypeKeys[Math.floor(Math.random() * obstacleTypeKeys.length)];
            const obstacleTypeName = OBSTACLE_TYPES[randomObstacleTypeKey];

            // Determine image based on direction
            const imageUrl = speed > 0 ? OBSTACLE_IMAGES[obstacleTypeName]?.right : OBSTACLE_IMAGES[obstacleTypeName]?.left;
            const texture = obstacleTextures[imageUrl]; // Get preloaded texture

            for (let i = 0; i < numObstacles; i++) {
                let obstacleMesh;
                const obstacleWidth = texture ? OBSTACLE_PLANE_WIDTH : 3; // Use plane width or default box width
                const obstacleHeight = texture ? OBSTACLE_PLANE_HEIGHT : 1;
                const obstacleDepth = texture ? 0.1 : 3; // Plane is thin, box has depth

                if (texture) {
                    // Use PlaneGeometry with texture
                    const geometry = new THREE.PlaneGeometry(obstacleWidth, obstacleHeight);
                    const material = new THREE.MeshLambertMaterial({
                        map: texture,
                        transparent: true,
                        alphaTest: 0.1, // Discard transparent parts of PNG
                        side: THREE.DoubleSide
                    });
                    obstacleMesh = new THREE.Mesh(geometry, material);
                    obstacleMesh.position.y = obstacleHeight / 2; // Position plane center vertically
                } else {
                    // Fallback to BoxGeometry with default color
                    const geometry = new THREE.BoxGeometry(obstacleWidth, obstacleHeight, obstacleDepth);
                    const material = new THREE.MeshLambertMaterial({ color: DEFAULT_OBSTACLE_COLOR });
                    obstacleMesh = new THREE.Mesh(geometry, material);
                    obstacleMesh.position.y = obstacleHeight / 2; // Position box center vertically
                }

                // Position obstacles evenly spaced across the lane length
                const initialX = (laneLength / (numObstacles + 1)) * (i + 1) - laneLength / 2;
                obstacleMesh.position.x = initialX * Math.sign(speed); // Start based on direction
                obstacleMesh.position.z = laneData.z; // Position on the correct lane
                obstacleMesh.castShadow = true;

                scene.add(obstacleMesh);

                const obstacleData = {
                    mesh: obstacleMesh,
                    speed: speed,
                    type: obstacleTypeName,
                    laneZ: laneData.z,
                    width: obstacleWidth, // Store dimensions for collision
                    height: obstacleHeight,
                    depth: obstacleDepth
                };
                obstacles.push(obstacleData); // Add to global obstacles array
                laneData.obstacles.push(obstacleData); // Link to the specific lane
            }
        }

        /**
         * Adds decorative scenery elements (desks, plants) to carpet or walkway lanes.
         * @param {object} laneData - The data object for the lane.
         * @param {string} context - 'carpet' or 'walkway' to vary scenery.
         */
        function addSceneryToLane(laneData, context) {
            const numScenery = Math.random() < 0.6 ? Math.floor(Math.random() * 2) + 1 : 0; // 0 to 2 scenery items

            for (let i = 0; i < numScenery; i++) {
                let sceneryMesh;
                const sceneryType = Math.random() < 0.7 ? 'desk' : 'plant'; // More desks than plants

                if (sceneryType === 'desk') {
                    const deskHeight = 1.5;
                    const deskWidth = 3;
                    const deskDepth = 1.5;
                    const geometry = new THREE.BoxGeometry(deskWidth, deskHeight, deskDepth);
                    sceneryMesh = new THREE.Mesh(geometry, sceneryMaterials.desk);
                    sceneryMesh.position.y = deskHeight / 2; // Place bottom on the ground
                } else { // Plant
                    const potHeight = 0.8;
                    const potRadius = 0.5;
                    const leafHeight = 1.2;
                    const potGeometry = new THREE.CylinderGeometry(potRadius * 0.8, potRadius, potHeight, 16);
                    const potMesh = new THREE.Mesh(potGeometry, sceneryMaterials.plantPot);
                    potMesh.position.y = potHeight / 2;

                    const leafGeometry = new THREE.ConeGeometry(potRadius * 1.2, leafHeight, 16);
                    const leafMesh = new THREE.Mesh(leafGeometry, sceneryMaterials.plantLeaf);
                    leafMesh.position.y = potHeight + leafHeight / 2; // Place leaves on top of pot

                    sceneryMesh = new THREE.Group(); // Group pot and leaves
                    sceneryMesh.add(potMesh);
                    sceneryMesh.add(leafMesh);
                    sceneryMesh.position.y = 0; // Group's base is at ground level
                }

                // Randomly position scenery along the edges of the lane
                const xPos = (Math.random() * (laneLength * 0.8)) - (laneLength * 0.4); // Avoid exact center
                const zOffset = (laneWidth / 2) * (Math.random() < 0.5 ? 0.8 : -0.8); // Place near left or right edge
                sceneryMesh.position.x = xPos;
                sceneryMesh.position.z = laneData.z + zOffset;
                sceneryMesh.castShadow = true;
                sceneryMesh.receiveShadow = true;

                scene.add(sceneryMesh);
                scenery.push(sceneryMesh); // Add to global scenery array
                laneData.scenery.push(sceneryMesh); // Link to the specific lane
            }
        }

        /**
         * Adds safe spots (logs, platforms) to water lanes for the player to land on.
         * These move similarly to obstacles.
         * @param {object} laneData - The data object for the lane.
         */
        function addSafeSpotsToLane(laneData) {
            const numSpots = Math.floor(Math.random() * 2) + 2; // 2 to 3 safe spots per water lane
            const speed = (Math.random() * 1.5 + 0.5) * (Math.random() < 0.5 ? 1 : -1); // Slower than obstacles
            const spotWidth = 4; // Width of the safe spot (log/platform)
            const spotDepth = 1.5; // Depth/thickness of the safe spot
            const spotHeight = 0.4; // How high it sits above the water

            const geometry = new THREE.BoxGeometry(spotWidth, spotHeight, spotDepth);
            const material = new THREE.MeshLambertMaterial({ color: SAFE_SPOT_COLOR }); // Use cached safe spot color

            for (let i = 0; i < numSpots; i++) {
                const spotMesh = new THREE.Mesh(geometry, material);
                spotMesh.position.y = spotHeight / 2 - 0.05; // Slightly above water level

                // Position spots evenly spaced
                const initialX = (laneLength / (numSpots + 1)) * (i + 1) - laneLength / 2;
                spotMesh.position.x = initialX * Math.sign(speed); // Start based on direction
                spotMesh.position.z = laneData.z; // Position on the correct lane
                spotMesh.castShadow = true; // Safe spots can cast shadows
                spotMesh.receiveShadow = true; // Safe spots can receive shadows

                scene.add(spotMesh);

                const spotData = {
                    mesh: spotMesh,
                    speed: speed,
                    laneZ: laneData.z,
                    width: spotWidth,
                    depth: spotDepth
                };
                safeSpots.push(spotData); // Add to global safe spots array
                laneData.safeSpots.push(spotData); // Link to the specific lane
            }
        }


        // --- Wall Generation ---

        /**
         * Creates the two long walls on either side of the playable lane area.
         */
        function createWalls() {
            // Remove existing walls if any
            wallSegments.forEach(wall => scene.remove(wall));
            wallSegments = [];

            const wallGeometry = new THREE.BoxGeometry(WALL_THICKNESS, WALL_HEIGHT, laneLength);

            // Left Wall
            const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
            leftWall.position.set(-laneLength / 2 - WALL_THICKNESS / 2, WALL_HEIGHT / 2, -laneLength / 2 + laneWidth / 2); // Position left wall
            leftWall.castShadow = true;
            leftWall.receiveShadow = true;
            scene.add(leftWall);
            wallSegments.push(leftWall);

            // Right Wall
            const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
            rightWall.position.set(laneLength / 2 + WALL_THICKNESS / 2, WALL_HEIGHT / 2, -laneLength / 2 + laneWidth / 2); // Position right wall
            rightWall.castShadow = true;
            rightWall.receiveShadow = true;
            scene.add(rightWall);
            wallSegments.push(rightWall);
        }

        /**
         * Updates the length and position of the side walls as the player progresses.
         * This gives the illusion of infinite walls without actually creating infinite geometry.
         */
        function updateWalls() {
            // Calculate the center Z position for the walls based on player's Z position
            const centerZ = player.position.z - laneLength / 2 + laneWidth / 2;

            wallSegments.forEach(wall => {
                // Only update Z position, keep X and Y the same
                wall.position.z = centerZ;
            });
        }


        // --- Game Loop and Updates ---

        /**
         * The main game loop, called repeatedly using requestAnimationFrame.
         * Updates game logic (movement, collisions), renders the scene.
         */
        function animate() {
            animationFrameId = requestAnimationFrame(animate); // Schedule next frame

            const deltaTime = clock.getDelta(); // Time since last frame

            // Only run game logic if the game is in the PLAYING state
            if (currentGameState === GAME_STATE.PLAYING) {
                updatePlayerMovement(deltaTime); // Smoothly move player towards target
                updateObstacles(deltaTime); // Move obstacles and safe spots
                updateCamera(); // Keep camera following the player
                updateWalls(); // Adjust wall positions to follow player
                checkCollisions(); // Check for player collisions with obstacles/water
                checkIdleTime(); // Check if player has been idle too long
                manageLanes(); // Generate new lanes and clean up old ones
                updateScore(); // Update the score display
            }

            renderer.render(scene, camera); // Render the scene
        }

        /**
         * Updates the position of obstacles and safe spots based on their speed.
         * Wraps obstacles around the edges of the lane length.
         * @param {number} deltaTime - Time elapsed since the last frame.
         */
        function updateObstacles(deltaTime) {
            // Update Obstacles
            obstacles.forEach(obstacle => {
                obstacle.mesh.position.x += obstacle.speed * deltaTime;
                // Wrap obstacle around if it goes off-screen
                const halfLane = laneLength / 2 + obstacle.width / 2; // Adjust wrap boundary by obstacle size
                if (obstacle.speed > 0 && obstacle.mesh.position.x > halfLane) {
                    obstacle.mesh.position.x = -halfLane;
                } else if (obstacle.speed < 0 && obstacle.mesh.position.x < -halfLane) {
                    obstacle.mesh.position.x = halfLane;
                }
            });

            // Update Safe Spots (similar logic to obstacles)
            safeSpots.forEach(spot => {
                spot.mesh.position.x += spot.speed * deltaTime;
                // Wrap safe spot around
                const halfLane = laneLength / 2 + spot.width / 2;
                if (spot.speed > 0 && spot.mesh.position.x > halfLane) {
                    spot.mesh.position.x = -halfLane;
                } else if (spot.speed < 0 && spot.mesh.position.x < -halfLane) {
                    spot.mesh.position.x = halfLane;
                }
            });
        }

        /**
         * Smoothly interpolates the player's visual position towards the target position.
         * @param {number} deltaTime - Time elapsed since the last frame.
         */
        function updatePlayerMovement(deltaTime) {
            // Update player's visual mesh position smoothly
            if (isMoving) {
                const elapsedTime = clock.elapsedTime * 1000 - moveStartTime; // Time since move started
                const moveProgress = Math.min(elapsedTime / moveDuration, 1); // Clamp progress between 0 and 1

                // Linear interpolation (lerp) for smooth movement
                player.position.x = THREE.MathUtils.lerp(player.position.x, targetPlayerPosition.x, 0.2); // Adjust lerp factor for speed
                player.position.z = THREE.MathUtils.lerp(player.position.z, targetPlayerPosition.z, 0.2);

                // Also move the bounding box with the player
                playerBoundingBox.position.copy(player.position);

                if (moveProgress >= 1) {
                    isMoving = false; // Movement complete
                    player.position.set(targetPlayerPosition.x, player.position.y, targetPlayerPosition.z); // Snap to final position
                    playerBoundingBox.position.copy(player.position);
                }
            } else {
                 // If not animating a move, ensure the visual position matches the logical one
                 // This handles cases where the player might be pushed by a safe spot
                 player.position.x = targetPlayerPosition.x;
                 player.position.z = targetPlayerPosition.z;
                 playerBoundingBox.position.copy(player.position);
            }

             // --- Riding Safe Spots ---
             const currentLane = lanes.find(lane => Math.abs(lane.z - playerPosition.z) < laneWidth / 2);
             if (currentLane && currentLane.type === LANE_TYPES.WATER) {
                 let onSafeSpot = false;
                 for (const spot of currentLane.safeSpots) {
                     // Check if player's X is within the bounds of the safe spot
                     if (Math.abs(player.position.x - spot.mesh.position.x) < spot.width / 2) {
                         onSafeSpot = true;
                         // If player is on a safe spot, move the player with the spot
                         if (!isMoving) { // Only move if not currently hopping
                             const deltaX = spot.speed * deltaTime;
                             targetPlayerPosition.x += deltaX;
                             player.position.x += deltaX; // Move visual mesh directly
                             playerBoundingBox.position.x += deltaX; // Move bounding box too
                             // Prevent player from being pushed off the edges by safe spots
                             const halfPlayableWidth = laneLength / 2 - 1; // Boundary within walls
                             targetPlayerPosition.x = Math.max(-halfPlayableWidth, Math.min(halfPlayableWidth, targetPlayerPosition.x));
                             player.position.x = targetPlayerPosition.x;
                             playerBoundingBox.position.x = targetPlayerPosition.x;
                         }
                         break; // Player can only be on one spot at a time
                     }
                 }
             }
        }


        /**
         * Updates the camera position to follow the player smoothly.
         */
        function updateCamera() {
            // Camera follows player's Z position, but stays centered on X and elevated on Y
            const targetCameraZ = player.position.z + 12; // Maintain distance behind player
            // Smoothly interpolate camera Z position
            camera.position.z = THREE.MathUtils.lerp(camera.position.z, targetCameraZ, 0.05); // Adjust lerp factor for follow speed

            // Keep camera looking slightly ahead of the player
            camera.lookAt(player.position.x, player.position.y, player.position.z - 5);

            // Also update the directional light's target to follow the player
            // This ensures shadows are cast correctly around the player's area
            directionalLight.target = player;
        }

        /**
         * Updates the score display on the screen.
         */
        function updateScore() {
            // Score is based on the maximum Z distance traveled (negative Z is forward)
            const currentMaxZ = -playerPosition.z / laneWidth; // Calculate score based on lanes crossed
            score = Math.max(score, Math.floor(currentMaxZ));
            infoElement.textContent = `Score: ${score}`;
        }

        /**
         * Checks if the player has been idle (not moved) for too long.
         * If idle time exceeds MAX_IDLE_TIME, triggers game over.
         */
        function checkIdleTime() {
            const currentTime = clock.getElapsedTime(); // Get total time elapsed since clock started
            if (currentTime - lastMoveTime > MAX_IDLE_TIME) {
                console.log("Player idle too long!");
                gameOver("Idle for too long!");
            }
        }

        // --- Collision Detection ---

        /**
         * Checks for collisions between the player and obstacles or water.
         * Triggers game over if a collision occurs.
         */
        function checkCollisions() {
            if (isMoving) return; // Don't check collisions while player is mid-hop

            const playerBox = new THREE.Box3().setFromObject(playerBoundingBox); // Get player's bounding box

            // 1. Check Obstacle Collisions
            for (const obstacle of obstacles) {
                // Broad phase check: Only check obstacles on the same lane or adjacent lanes
                if (Math.abs(obstacle.laneZ - playerPosition.z) <= laneWidth) {
                    const obstacleBox = new THREE.Box3().setFromObject(obstacle.mesh);
                    if (playerBox.intersectsBox(obstacleBox)) {
                        console.log("Collision with obstacle!");
                        gameOver(`Hit by ${obstacle.type}!`);
                        return; // Game over, no need to check further
                    }
                }
            }

            // 2. Check Water Collision
            const currentLane = lanes.find(lane => Math.abs(lane.z - playerPosition.z) < laneWidth / 2);
            if (currentLane && currentLane.type === LANE_TYPES.WATER) {
                let onSafeSpot = false;
                // Check if player is on any safe spot within the current water lane
                for (const spot of currentLane.safeSpots) {
                    // Check X-axis overlap (player center vs spot edges)
                    if (Math.abs(player.position.x - spot.mesh.position.x) < spot.width / 2) {
                         // Check Z-axis overlap (should always be true if on the lane, but good practice)
                         if (Math.abs(player.position.z - spot.mesh.position.z) < spot.depth / 2) {
                            onSafeSpot = true;
                            break; // Found a safe spot, no need to check others
                         }
                    }
                }

                if (!onSafeSpot) {
                    console.log("Fell in the water!");
                    gameOver("Fell into the water!");
                    return; // Game over
                }
            }

            // 3. Check Out-of-Bounds (redundant if walls work, but good failsafe)
            const halfPlayableWidth = laneLength / 2;
             if (player.position.x < -halfPlayableWidth || player.position.x > halfPlayableWidth) {
                 console.log("Player went out of bounds!");
                 gameOver("Went out of bounds!");
                 return;
             }
        }


        // --- Lane Management ---

        /**
         * Manages the generation of new lanes ahead of the player
         * and the removal of old lanes behind the player.
         */
        function manageLanes() {
            // --- Generate New Lanes ---
            // Check if the furthest generated lane is close enough to the player
            if (lastLaneZ > player.position.z - generationDistance * laneWidth) {
                generateRandomLane(); // Generate a new lane further ahead
            }

            // --- Clean Up Old Lanes ---
            const cleanupThresholdZ = player.position.z + cleanupBuffer * laneWidth; // Z position behind the player
            for (let i = lanes.length - 1; i >= 0; i--) {
                const lane = lanes[i];
                if (lane.z > cleanupThresholdZ) {
                    // Remove lane mesh from scene
                    scene.remove(lane.mesh);

                    // Remove associated obstacles from scene and global array
                    lane.obstacles.forEach(obstacleData => {
                        scene.remove(obstacleData.mesh);
                        const index = obstacles.indexOf(obstacleData);
                        if (index > -1) obstacles.splice(index, 1);
                    });

                    // Remove associated scenery from scene and global array
                    lane.scenery.forEach(sceneryMesh => {
                        scene.remove(sceneryMesh);
                        const index = scenery.indexOf(sceneryMesh);
                        if (index > -1) scenery.splice(index, 1);
                    });

                    // Remove associated safe spots from scene and global array
                    lane.safeSpots.forEach(spotData => {
                        scene.remove(spotData.mesh);
                        const index = safeSpots.indexOf(spotData);
                        if (index > -1) safeSpots.splice(index, 1);
                    });

                    // Remove lane data from lanes array
                    lanes.splice(i, 1);
                    // console.log("Cleaned up lane at Z:", lane.z);
                }
            }
        }

        // --- Input Handling ---

        /**
         * Handles keyboard input for player movement.
         * Updates the target position and initiates the move animation.
         * @param {Event} event - The keydown event object.
         */
        function handleInput(event) {
            if (currentGameState !== GAME_STATE.PLAYING || isMoving) {
                return; // Ignore input if not playing or already moving
            }

            let moved = false; // Flag to check if a valid move key was pressed
            let targetX = targetPlayerPosition.x;
            let targetZ = targetPlayerPosition.z;
            const moveStep = laneWidth; // Move one lane width forward/backward
            const sideStep = laneWidth / 2; // Move half a lane width sideways (adjust as needed)

            switch (event.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    targetZ -= moveStep; // Move forward
                    playerPosition.z -= moveStep; // Update logical Z immediately
                    moved = true;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    // Allow moving back one step, but not beyond the starting line (or slightly behind)
                    if (playerPosition.z < 0) {
                        targetZ += moveStep; // Move backward
                        playerPosition.z += moveStep; // Update logical Z
                        moved = true;
                    }
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    targetX -= sideStep; // Move left
                    moved = true;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    targetX += sideStep; // Move right
                    moved = true;
                    break;
            }

            if (moved) {
                 // --- Boundary Check ---
                 // Prevent moving beyond the side walls (adjust boundary slightly inwards)
                 const halfPlayableWidth = laneLength / 2 - 1; // Boundary inside the walls
                 targetX = Math.max(-halfPlayableWidth, Math.min(halfPlayableWidth, targetX));


                // Start the movement animation
                targetPlayerPosition.x = targetX;
                targetPlayerPosition.z = targetZ;
                isMoving = true;
                moveStartTime = clock.elapsedTime * 1000; // Record start time in milliseconds
                lastMoveTime = clock.getElapsedTime(); // Update last move time for idle check

                // Update logical X position after boundary check
                playerPosition.x = targetX;
            }
        }

        // --- Game State Management ---

        /**
         * Starts the game: resets state, hides menus, shows game UI, resets player.
         */
        function startGame() {
            console.log("Starting game...");
            currentGameState = GAME_STATE.PLAYING;
            showOverlay(null); // Hide all overlays
            infoElement.classList.remove('hidden'); // Show in-game score

            // Reset game variables
            score = 0;
            lastMoveTime = clock.getElapsedTime(); // Reset idle timer start

            // Remove old lanes, obstacles, etc.
            lanes.forEach(lane => {
                 scene.remove(lane.mesh);
                 lane.obstacles.forEach(o => scene.remove(o.mesh));
                 lane.scenery.forEach(s => scene.remove(s));
                 lane.safeSpots.forEach(sp => scene.remove(sp.mesh));
            });
            lanes = [];
            obstacles = [];
            scenery = [];
            safeSpots = [];
            wallSegments.forEach(w => scene.remove(w));
            wallSegments = [];

            // Reset player position and create new player mesh
            createPlayer(); // Recreates player with selected character
            targetPlayerPosition = { x: 0, z: 0 };
            playerPosition = { x: 0, z: 0 };
            player.position.set(0, CHARACTERS[selectedCharacterIndex].height / 2, 0);
            playerBoundingBox.position.copy(player.position);


            // Generate initial lanes and walls
            lastLaneZ = 0;
            createLane(LANE_TYPES.CARPET, 0); // Starting lane
            for (let i = 1; i < generationDistance / 2; i++) {
                generateRandomLane();
            }
            createWalls();

            // Reset camera position
            camera.position.set(0, 15, 12);
            camera.lookAt(0, 0, 0);

             // Ensure the animation loop is running
             if (!animationFrameId) {
                animate();
             }
        }

        /**
         * Shows the high score screen. Fetches scores from Firebase.
         */
        function showScoreboard() {
            console.log("Showing scoreboard...");
            currentGameState = GAME_STATE.SHOW_SCORES;
            showOverlay(scoreboardScreenElement); // Show the scoreboard overlay
            fetchAndDisplayHighScores(); // Fetch and display scores when shown
        }

        /**
         * Handles the game over state.
         * Stops player input, shows the game over screen, displays final score,
         * and attempts to save the score to Firebase.
         * @param {string} reason - The reason for the game over (e.g., "Hit by obstacle").
         */
        function gameOver(reason = "Unknown cause") {
            if (currentGameState === GAME_STATE.GAME_OVER) return; // Prevent multiple game overs

            console.log(`Game Over: ${reason}`);
            currentGameState = GAME_STATE.GAME_OVER;

            // Stop the animation loop? Maybe not, keep rendering the final state.
            // if (animationFrameId) cancelAnimationFrame(animationFrameId);
            // animationFrameId = null;

            finalScoreElement.textContent = score; // Display final score
            gameOverReasonElement.textContent = reason; // Display reason

            showOverlay(gameOverElement); // Show game over screen

            // --- Attempt to save score to Firebase ---
            const characterName = CHARACTERS[selectedCharacterIndex].name;
            // Only try to save if Firestore was initialized
            if (highScoresCollection) {
                 saveScoreIfHighScore(characterName, score); // Call the Firebase save function
            } else {
                console.warn("Cannot save score, Firestore not available.");
            }
        }

        /**
         * Returns the game to the main menu state.
         */
        function goToMenu() {
            console.log("Returning to main menu...");
            currentGameState = GAME_STATE.MENU;
            showOverlay(mainMenuElement); // Show the main menu overlay
            // Optional: Reset camera to a fixed menu view if desired
             camera.position.set(0, 15, 12);
             camera.lookAt(0, 0, 0);
        }

        // --- Window Resize Handler ---

        /**
         * Updates camera aspect ratio and renderer size when the window is resized.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; // Update aspect ratio
            camera.updateProjectionMatrix(); // Apply aspect ratio change
            renderer.setSize(window.innerWidth, window.innerHeight); // Resize renderer canvas
        }

        // --- Start the application ---
        // Use DOMContentLoaded to ensure the HTML is parsed before trying to access elements
        document.addEventListener('DOMContentLoaded', (event) => {
            console.log("DOM fully loaded and parsed. Initializing game setup.");
            init(); // Initialize the game setup (scene, camera, UI bindings)
            // Note: The actual game loop (animate) is started via window.onload inside init()
        });

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Office Crossing Challenge - Firebase Leaderboard!</title>
    <style>
        /* Styles remain the same */
        body { margin: 0; overflow: hidden; font-family: sans-serif; background: linear-gradient(to bottom, #87CEEB, #B0E0E6); color: #333; height: 100vh; }
        canvas { display: block; }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; flex-direction: column; background-color: rgba(0, 0, 0, 0.75); color: white; z-index: 100; padding: 20px; box-sizing: border-box; text-align: center; }
        .hidden { display: none; }
        .overlay-content { background-color: rgba(40, 60, 80, 0.9); padding: 30px 40px; border-radius: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.4); max-width: 90%; width: 450px; }
        .overlay h2 { margin-top: 0; margin-bottom: 20px; border-bottom: 1px solid rgba(255,255,255,0.5); padding-bottom: 10px; color: #FFD700; }
        .overlay button { display: block; width: 80%; margin: 15px auto; padding: 12px 20px; font-size: 18px; cursor: pointer; border: none; border-radius: 8px; background-color: #4682B4; color: white; transition: background-color 0.3s, transform 0.1s; box-shadow: 0 4px 6px rgba(0,0,0,0.2); }
        .overlay button:hover { background-color: #5A9BD5; }
        .overlay button:active { transform: scale(0.95); background-color: #41729F; }
        #mainMenu .character-selection { margin-bottom: 20px; padding: 10px; background-color: rgba(255,255,255,0.1); border-radius: 8px; max-height: 250px; overflow-y: auto; /* Added scroll for many characters */ }
        #mainMenu .character-selection h3 { margin-top: 0; margin-bottom: 10px; font-size: 16px; }
        #mainMenu .char-button { display: inline-block; width: auto; padding: 8px 15px; margin: 5px; font-size: 14px; border: 2px solid transparent; background-color: #6c757d; }
        #mainMenu .char-button.selected { border-color: #FFD700; background-color: #4682B4; }
        #scoreboardScreen ol { margin: 0 0 15px 0; padding: 0 0 0 25px; list-style-position: outside; max-height: 150px; overflow-y: auto; }
        #scoreboardScreen li { margin-bottom: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 16px; border-bottom: 1px dotted rgba(255, 255, 255, 0.2); padding-bottom: 4px; }
        #scoreboardScreen li:last-child { border-bottom: none; }
        #scoreboardScreen li span { display: inline-block; }
        #scoreboardScreen li .score { float: right; font-weight: bold; margin-left: 15px; }
        #scoreboardScreen .no-scores { text-align: center; font-style: italic; color: #ccc; margin-top: 10px;}
        #info { position: absolute; top: 10px; left: 10px; width: auto; text-align: left; z-index: 50; display: block; color: #000080; font-size: 24px; font-weight: bold; text-shadow: 1px 1px 1px #FFFFFF; background-color: rgba(255, 255, 255, 0.6); padding: 5px 10px; border-radius: 5px; }
        #gameOver { z-index: 101; }
        #gameOverReason { font-size: 24px; margin-bottom: 15px; font-style: italic; color: #ffdddd; }
    </style>

    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-database-compat.js"></script>

</head>
<body>
    <div id="info" class="hidden">Score: 0</div>
    <div id="mainMenu" class="overlay"> <div class="overlay-content"> <h2>Office Crossing Challenge</h2> <div class="character-selection"> <h3>Select Character</h3> <div id="characterButtons"></div> </div> <button id="startGameButton">Start Game</button> <button id="viewScoresButton">High Scores</button> </div> </div>
    <div id="scoreboardScreen" class="overlay hidden"> <div class="overlay-content"> <h2>High Scores (Top 3)</h2> <ol id="scoreList"></ol> <div id="noScoresMessage" class="no-scores" style="display: none;">Loading scores or none yet...</div> <button id="backToMenuButton">Back to Menu</button> </div> </div>
    <div id="gameOver" class="overlay hidden"> <div class="overlay-content"> <h2 id="gameOverReason">Deadline Missed!</h2> Final Score: <span id="finalScore">0</span><br> <button onclick="goToMenu()">Main Menu</button> </div> </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Firebase Configuration ---
        const firebaseConfig = {
          apiKey: "AIzaSyCEVtcw6InjPAtT6qRDnMNNciNAVhMIBhM", // Keep this secure if needed
          authDomain: "office-crossing-game.firebaseapp.com",
          // --- URL UPDATED ---
          databaseURL: "https://office-crossing-game-default-rtdb.europe-west1.firebasedatabase.app",
          projectId: "office-crossing-game",
          storageBucket: "office-crossing-game.appspot.com", // Verify this
          messagingSenderId: "1060039127140",
          appId: "1:1060039127140:web:d7e01f6f64e97b4fcb6f71"
        };

        // --- Initialize Firebase ---
        let firebaseApp;
        let database;
        try {
            // Use compat libraries for easy transition if needed, or update to modular v9 syntax fully
            firebaseApp = firebase.initializeApp(firebaseConfig); // Using compat library syntax
            database = firebase.database(); // Using compat library syntax
            console.log("Firebase Initialized Successfully.");
        } catch (e) {
            console.error("Firebase initialization failed:", e);
            // Optionally, disable leaderboard features or notify user
            alert("Could not connect to the leaderboard database. High scores will not be available.");
        }

        // --- Game States ---
        const GAME_STATE = { MENU: 'menu', PLAYING: 'playing', GAME_OVER: 'game_over', SHOW_SCORES: 'show_scores' };
        let currentGameState = GAME_STATE.MENU;

        // --- Global Variables (Game Logic - unchanged) ---
        let scene, camera, renderer;
        let player, playerBoundingBox;
        let lanes = []; let obstacles = []; let score = 0; let scenery = [];
        let safeSpots = [];
        let wallSegments = [];
        let laneWidth = 6;
        let laneLength = 80;
        let playerPosition = { x: 0, z: 0 }; let targetPlayerPosition = { x: 0, z: 0 };
        let isMoving = false; let moveDuration = 150; let moveStartTime = 0;
        let lastLaneZ = 0; let generationDistance = 20; let cleanupBuffer = 5;
        let clock = new THREE.Clock(); let textureLoader = new THREE.TextureLoader();
        // const MAX_HIGH_SCORES = 3; // No longer needed for local storage limit
        let animationFrameId = null;
        let laneMaterials = {}; let wallMaterial; let sceneryMaterials = {};
        let lastMoveTime = 0; const MAX_IDLE_TIME = 5.0;
        let directionalLight;

        // --- Wall Constants (Unchanged) ---
        const WALL_HEIGHT = 8;
        const WALL_THICKNESS = 1.0;

        // --- Character Definition (Unchanged) ---
        const CHARACTERS = [
             { name: 'Alon', imageUrl: 'Alon.png', width: 2.8, height: 3.36 },
             { name: 'Sahar', imageUrl: 'Sahar.png', width: 2.8, height: 3.36 },
             { name: 'Mor', imageUrl: 'Mor.png', width: 2.8, height: 3.36 },
             { name: 'Lin', imageUrl: 'Lin.png', width: 2.8, height: 3.36 },
             { name: 'Asaf', imageUrl: 'Asaf.png', width: 2.8, height: 3.36 },
             { name: 'Tal', imageUrl: 'Tal.png', width: 2.8, height: 3.36 },
             { name: 'Ron', imageUrl: 'Ron.png', width: 2.8, height: 3.36 },
             { name: 'Hadar', imageUrl: 'Hadar.png', width: 2.8, height: 3.36 },
             { name: 'Adi', imageUrl: 'Adi.png', width: 2.8, height: 3.36 },
             { name: 'Alex', imageUrl: 'Alex.png', width: 2.8, height: 3.36 },
             { name: 'Amit', imageUrl: 'Amit.png', width: 2.8, height: 3.36 },
             { name: 'Anna', imageUrl: 'Anna.png', width: 2.8, height: 3.36 },
             { name: 'May Boss', imageUrl: 'May Boss.png', width: 2.8, height: 3.36 },
             { name: 'May QA', imageUrl: 'May QA.png', width: 2.8, height: 3.36 },
             { name: 'Ofek', imageUrl: 'Ofek.png', width: 2.8, height: 3.36 },
             { name: 'Default', imageUrl: null, width: 2.2, height: 2.2 }
        ];
        let selectedCharacterIndex = 0;
        let characterTextures = {};

        // --- THEME Constants & Colors (Unchanged) ---
        const LANE_TYPES = { CARPET: 'carpet', WALKWAY: 'walkway', WATER: 'water' };
        const DEFAULT_PLAYER_COLOR = 0xADD8E6;
        const DEFAULT_OBSTACLE_COLOR = 0xff00ff;
        const SCENERY_COLORS = { DESK: 0xAF8F6D, PLANT_POT: 0xCD853F, PLANT_LEAF: 0x2E8B57 };
        const SAFE_SPOT_COLOR = 0x90EE90;
        const WATER_COLOR = 0x1E90FF;

        // --- Obstacle Definitions (Unchanged) ---
        const OBSTACLE_TYPES = { CC: 'cc', LIVE_CHANGE: 'live_change', ON_CALL: 'on_call' };
        const OBSTACLE_IMAGES = {
            [OBSTACLE_TYPES.CC]: { right: 'CC.png', left: 'CC R.png' },
            [OBSTACLE_TYPES.LIVE_CHANGE]: { right: 'Live Change.png', left: 'Live Change R.png' },
            [OBSTACLE_TYPES.ON_CALL]: { right: 'On Call.png', left: 'On Call R.png' }
        };
        let obstacleTextures = {};
        const OBSTACLE_PLANE_WIDTH = 5.0;
        const OBSTACLE_PLANE_HEIGHT = 5.0;

        // --- DOM Elements (Unchanged) ---
        let infoElement, mainMenuElement, scoreboardScreenElement, gameOverElement;
        let characterButtonsElement, startGameButton, viewScoresButton, backToMenuButton;
        let scoreListElement, noScoresMessageElement, finalScoreElement, gameOverReasonElement;

        // --- Texture Generation Functions (Unchanged) ---
        function createNoiseTexture(width, height, color1, color2, alpha = 1) { const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height; const ctx = canvas.getContext('2d'); ctx.fillStyle = color1; ctx.fillRect(0, 0, width, height); const imageData = ctx.getImageData(0, 0, width, height); const data = imageData.data; for (let i = 0; i < data.length; i += 4) { if (Math.random() > 0.85) { const shade = Math.random() * 50 + (color2 === '#000000' ? 0 : 205); data[i] = shade; data[i + 1] = shade; data[i + 2] = shade; } data[i + 3] = alpha * 255; } ctx.putImageData(imageData, 0, 0); const texture = new THREE.CanvasTexture(canvas); texture.wrapS = texture.wrapT = THREE.RepeatWrapping; return texture; }
        function createTileTexture(width, height, bgColor, lineColor, tileSize) { const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height; const ctx = canvas.getContext('2d'); ctx.fillStyle = bgColor; ctx.fillRect(0, 0, width, height); ctx.strokeStyle = lineColor; ctx.lineWidth = Math.max(1, Math.floor(width / 100)); ctx.beginPath(); for (let x = 0; x <= width; x += tileSize) { ctx.moveTo(x, 0); ctx.lineTo(x, height); } for (let y = 0; y <= height; y += tileSize) { ctx.moveTo(0, y); ctx.lineTo(width, y); } ctx.stroke(); const texture = new THREE.CanvasTexture(canvas); texture.wrapS = texture.wrapT = THREE.RepeatWrapping; return texture; }

        // --- Firebase Leaderboard Functions ---

        /**
         * Submits the player's score to the Firebase Realtime Database.
         * @param {string} playerName - The name of the player (currently character name).
         * @param {number} playerScore - The score achieved by the player.
         */
        function submitScoreToFirebase(playerName, playerScore) {
            if (!database) {
                console.error("Database not initialized. Cannot submit score.");
                return;
            }
            if (playerScore <= 0) {
                console.log("Score is 0 or less, not submitting.");
                return; // Don't submit scores of 0 or less
            }

            const scoresRef = database.ref('scores'); // Reference to the 'scores' node
            const newScoreRef = scoresRef.push(); // Generate a unique key

            newScoreRef.set({
                name: playerName,
                score: playerScore,
                // Use server timestamp for fair ordering/tie-breaking if needed
                timestamp: firebase.database.ServerValue.TIMESTAMP
            })
            .then(() => {
                console.log(`Score for ${playerName} (${playerScore}) submitted successfully.`);
            })
            .catch((error) => {
                console.error("Error submitting score to Firebase:", error);
                // Optionally alert the user
                // alert("There was an error submitting your score. Please try again later.");
            });
        }

        /**
         * Sets up a listener for the top 3 high scores from Firebase
         * and updates the scoreboard UI in real-time.
         */
        function listenForHighScores() {
            if (!database) {
                console.error("Database not initialized. Cannot listen for scores.");
                noScoresMessageElement.textContent = "Leaderboard unavailable.";
                noScoresMessageElement.style.display = 'block';
                scoreListElement.innerHTML = '';
                return;
            }

            const scoresRef = database.ref('scores');
            // Query: Order by 'score' descending, limit to the last 3 (which are the highest)
            const topScoresQuery = scoresRef.orderByChild('score').limitToLast(3);

            // Detach previous listener if any (important for re-entering scoreboard)
            topScoresQuery.off('value'); // Turn off previous listeners on this query

            // Attach the listener
            topScoresQuery.on('value', (snapshot) => {
                scoreListElement.innerHTML = ''; // Clear previous list
                const scores = [];
                if (snapshot.exists()) {
                    // Firebase returns data as an object, convert to array
                    snapshot.forEach((childSnapshot) => {
                        scores.push({
                            key: childSnapshot.key,
                            name: childSnapshot.val().name,
                            score: childSnapshot.val().score
                        });
                    });

                    // Sort descending (Firebase limitToLast should already do this, but good practice)
                    scores.sort((a, b) => b.score - a.score);

                    noScoresMessageElement.style.display = 'none'; // Hide 'no scores' message
                    scores.forEach((scoreEntry) => {
                        const li = document.createElement('li');
                        // Truncate name if too long for display
                        const displayName = scoreEntry.name.length > 15 ? scoreEntry.name.substring(0, 12) + '...' : scoreEntry.name;
                        li.innerHTML = `<span class="name">${escapeHtml(displayName)}</span><span class="score">${scoreEntry.score}</span>`;
                        scoreListElement.appendChild(li);
                    });
                } else {
                    // No scores found in the database
                    noScoresMessageElement.textContent = "No scores yet! Be the first!";
                    noScoresMessageElement.style.display = 'block';
                }
            }, (error) => {
                console.error("Error fetching high scores:", error);
                noScoresMessageElement.textContent = "Error loading scores.";
                noScoresMessageElement.style.display = 'block';
                scoreListElement.innerHTML = '';
            });
        }

        // Utility to prevent basic HTML injection from names
        function escapeHtml(unsafe) {
            if (!unsafe) return '';
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        }

        // --- UI State Management (Unchanged) ---
        function showOverlay(overlayElement) {
            mainMenuElement.classList.add('hidden');
            scoreboardScreenElement.classList.add('hidden');
            gameOverElement.classList.add('hidden');
            infoElement.classList.add('hidden'); // Hide score during overlays
            if (overlayElement) {
                overlayElement.classList.remove('hidden');
            }
        }

        // --- Character Selection (Unchanged) ---
        function selectCharacter(index) {
            if (index >= 0 && index < CHARACTERS.length) {
                selectedCharacterIndex = index;
                updateCharacterButtonSelection();
                console.log(`Selected character: ${CHARACTERS[selectedCharacterIndex].name}`);
            }
        }
        function updateCharacterButtonSelection() {
            const buttons = characterButtonsElement.querySelectorAll('.char-button');
            buttons.forEach((button, index) => {
                if (index === selectedCharacterIndex) button.classList.add('selected');
                else button.classList.remove('selected');
            });
        }
        function populateCharacterButtons() {
             characterButtonsElement.innerHTML = '';
             CHARACTERS.forEach((char, index) => {
                 const button = document.createElement('button');
                 button.textContent = char.name;
                 button.classList.add('char-button');
                 button.onclick = () => selectCharacter(index);
                 characterButtonsElement.appendChild(button);
             });
             updateCharacterButtonSelection(); // Set initial selection highlight
        }

        // --- Preload Assets & Materials (MODIFIED: Added error logging) ---
        function preloadAssets() {
            console.log("Preloading assets...");
            let maxAnisotropy = renderer ? renderer.capabilities.getMaxAnisotropy() : 1;

            // Define texture load success/error handlers
            const onTextureLoad = (texture) => {
                 texture.magFilter = THREE.NearestFilter; // Pixelated look
                 texture.anisotropy = maxAnisotropy;
                 texture.needsUpdate = true;
                 // console.log("Texture loaded successfully:", texture.image.src); // Optional: log success
            };
            const onTextureError = (url) => (err) => {
                 console.error(`Failed to load texture: ${url}`, err);
                 // You could potentially set a fallback texture here if needed
            };

            // Load Character Textures
            CHARACTERS.forEach((char, index) => {
                if (char.imageUrl) {
                    characterTextures[index] = textureLoader.load(
                        char.imageUrl,
                        onTextureLoad,
                        undefined, // onProgress callback (optional)
                        onTextureError(char.imageUrl) // onError callback
                    );
                }
             });

            // Load Obstacle Textures
            obstacleTextures = {};
            for (const typeKey in OBSTACLE_IMAGES) {
                const images = OBSTACLE_IMAGES[typeKey];
                obstacleTextures[typeKey] = {};
                if (images.right) {
                    obstacleTextures[typeKey].right = textureLoader.load(
                        images.right,
                        onTextureLoad,
                        undefined,
                        onTextureError(images.right)
                    );
                } else { console.warn(`Missing right image for obstacle type: ${typeKey}`); }

                if (images.left) {
                    obstacleTextures[typeKey].left = textureLoader.load(
                        images.left,
                        onTextureLoad,
                        undefined,
                        onTextureError(images.left)
                    );
                } else {
                    console.warn(`Missing left image for obstacle type: ${typeKey}`);
                    // Fallback to right image if left is missing AND right exists
                    if (obstacleTextures[typeKey].right) {
                         obstacleTextures[typeKey].left = obstacleTextures[typeKey].right;
                    }
                }
            }

            // Define Materials (using generated textures)
            try {
                const carpetTexture = createNoiseTexture(64, 64, '#90EE90', '#3CB371'); carpetTexture.repeat.set(8, 8);
                laneMaterials[LANE_TYPES.CARPET] = new THREE.MeshStandardMaterial({ map: carpetTexture, roughness: 0.9, metalness: 0.05 });

                const walkwayTexture = createTileTexture(64, 64, '#E07A5F', '#D45D3D', 24); walkwayTexture.repeat.set(8, 8);
                laneMaterials[LANE_TYPES.WALKWAY] = new THREE.MeshStandardMaterial({ map: walkwayTexture, roughness: 0.4, metalness: 0.1 });

                laneMaterials[LANE_TYPES.WATER] = new THREE.MeshStandardMaterial({ color: WATER_COLOR, roughness: 0.2, metalness: 0.1, transparent: true, opacity: 0.85 });

                wallMaterial = new THREE.MeshStandardMaterial({ color: 0xFFEBCD, roughness: 0.9, metalness: 0.0 });

                sceneryMaterials.desk = new THREE.MeshStandardMaterial({ color: SCENERY_COLORS.DESK, roughness: 0.8, metalness: 0.1 });
                sceneryMaterials.plantPot = new THREE.MeshStandardMaterial({ color: SCENERY_COLORS.PLANT_POT, roughness: 0.7, metalness: 0.1 });
                sceneryMaterials.plantLeaf = new THREE.MeshStandardMaterial({ color: SCENERY_COLORS.PLANT_LEAF, roughness: 0.8, metalness: 0.0 });
                sceneryMaterials.safeSpot = new THREE.MeshStandardMaterial({ color: SAFE_SPOT_COLOR, roughness: 0.9, metalness: 0.0 });
                console.log("Materials using generated textures defined.");
            } catch (error) {
                console.error("Error defining materials with generated textures:", error);
            }

            console.log("Asset preloading & generation initiated.");
        }

        // --- Initialization (Modified for Firebase) ---
        function init() {
            console.log("Initializing game..."); // Added log
            // Get DOM Elements
            infoElement = document.getElementById('info');
            mainMenuElement = document.getElementById('mainMenu');
            scoreboardScreenElement = document.getElementById('scoreboardScreen');
            gameOverElement = document.getElementById('gameOver');
            characterButtonsElement = document.getElementById('characterButtons');
            startGameButton = document.getElementById('startGameButton');
            viewScoresButton = document.getElementById('viewScoresButton');
            backToMenuButton = document.getElementById('backToMenuButton');
            scoreListElement = document.getElementById('scoreList');
            noScoresMessageElement = document.getElementById('noScoresMessage');
            finalScoreElement = document.getElementById('finalScore');
            gameOverReasonElement = document.getElementById('gameOverReason');

            // Basic Scene Setup
            try { // Wrap scene setup in try-catch
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 15, 12);
                camera.lookAt(0, 0, 0);

                // Renderer Setup
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // alpha:true for transparent background if needed
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
                document.body.appendChild(renderer.domElement);
                renderer.toneMapping = THREE.ACESFilmicToneMapping; // Better color grading
                renderer.toneMappingExposure = 1.0;

                // Lighting Setup
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // Soft ambient light
                scene.add(ambientLight);
                const hemiLight = new THREE.HemisphereLight( 0xE8E8FF, 0xB0B0B0, 0.6 ); // Sky/ground light
                scene.add( hemiLight );
                directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Main sunlight
                directionalLight.position.set(20, 35, 25);
                directionalLight.castShadow = true;
                // Configure shadow properties
                directionalLight.shadow.mapSize.width = 2048; // Higher resolution shadows
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 1;
                directionalLight.shadow.camera.far = 500;
                const initialShadowSize = laneLength / 2 + 10; // Adjust shadow camera frustum
                directionalLight.shadow.camera.left = -initialShadowSize;
                directionalLight.shadow.camera.right = initialShadowSize;
                directionalLight.shadow.camera.top = initialShadowSize;
                directionalLight.shadow.camera.bottom = -initialShadowSize;
                directionalLight.shadow.bias = -0.005; // Adjust shadow bias to prevent artifacts
                scene.add(directionalLight);
                scene.add(directionalLight.target); // Target for the light
                console.log("Three.js scene, camera, renderer, lighting setup complete.");
            } catch (error) {
                console.error("Error during Three.js setup:", error);
                alert("A critical error occurred setting up the 3D scene. The game cannot start.");
                return; // Stop initialization if core setup fails
            }

            // Preload assets (textures, materials)
            preloadAssets();

            // Populate UI Elements
            if (characterButtonsElement) populateCharacterButtons();
            else console.error("characterButtonsElement not found!");

            // Setup Button Listeners
            if (startGameButton) startGameButton.onclick = startGame;
            else console.error("startGameButton not found!");

            if (viewScoresButton) {
                viewScoresButton.onclick = () => {
                    listenForHighScores();
                    currentGameState = GAME_STATE.SHOW_SCORES;
                    showOverlay(scoreboardScreenElement);
                };
            } else {
                console.error("viewScoresButton not found!");
            }

            if (backToMenuButton) {
                backToMenuButton.onclick = () => {
                    if (database) {
                         database.ref('scores').orderByChild('score').limitToLast(3).off('value');
                    }
                    goToMenu();
                };
            } else {
                console.error("backToMenuButton not found!");
            }

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);

            // Initial State
            goToMenu(); // Start at the main menu
            animate(); // Start the animation loop
            console.log("Initialization complete. Starting animation loop.");
        }


        // --- Game Start Logic (Unchanged) ---
        function startGame() {
            console.log("Starting game...");
            score = 0;
            playerPosition = { x: 0, z: 0 };
            targetPlayerPosition = { x: 0, z: 0 };
            lastLaneZ = 0;
            isMoving = false;
            infoElement.innerText = `Score: ${score}`;
            infoElement.classList.remove('hidden'); // Show score display
            lastMoveTime = clock.getElapsedTime(); // Reset idle timer

            clearGameObjects(); // Remove old objects
            createPlayer(); // Create the player model

            // --- Ensure initial lanes are created ---
            try {
                createLane(LANE_TYPES.CARPET, 0); // Create starting lane
                // Generate initial set of lanes
                for (let i = 1; i < generationDistance; i++) {
                    generateLane();
                }
                 console.log("Initial lanes generated.");
            } catch(error) {
                 console.error("Error during initial lane generation:", error);
                 // Optionally show an error to the user
                 // gameOver("setup_error"); // Or a specific error state
                 alert("Error creating the game world. Please reload.");
                 return;
            }


            // Reset camera for game start
            camera.position.set(0, 15, 12); // Adjust as needed
            if(player) camera.lookAt(player.position.x, player.position.y, player.position.z);
            else camera.lookAt(0, 0, 0);


            currentGameState = GAME_STATE.PLAYING;
            showOverlay(null); // Hide all overlays
            if (animationFrameId) cancelAnimationFrame(animationFrameId); // Ensure no duplicate loops
            animate(); // Make sure animation loop is running
             console.log("Game started, state set to PLAYING.");
        }

        // --- Game Object Creation (Player, Lane, Obstacles, Scenery - Largely Unchanged) ---
        function createPlayer() {
            try { // Added try-catch
                const selectedChar = CHARACTERS[selectedCharacterIndex];
                let playerGeometry;
                let playerMaterial;

                if (selectedChar.imageUrl && characterTextures[selectedCharacterIndex]) {
                    playerGeometry = new THREE.PlaneGeometry(selectedChar.width, selectedChar.height);
                    playerMaterial = new THREE.MeshStandardMaterial({
                        map: characterTextures[selectedCharacterIndex],
                        transparent: true, side: THREE.DoubleSide, roughness: 0.8, metalness: 0.1
                    });
                     console.log(`Using texture for player: ${selectedChar.name}`);
                } else {
                    playerGeometry = new THREE.BoxGeometry(selectedChar.width * 0.8, selectedChar.height * 0.8, selectedChar.width * 0.8);
                    playerMaterial = new THREE.MeshStandardMaterial({ color: DEFAULT_PLAYER_COLOR, roughness: 0.6, metalness: 0.2 });
                     console.log(`Using fallback geometry for player: ${selectedChar.name}`);
                }

                player = new THREE.Mesh(playerGeometry, playerMaterial);
                player.position.set(playerPosition.x, selectedChar.height / 2, playerPosition.z);
                player.rotation.y = Math.PI;
                player.castShadow = true;
                player.receiveShadow = false;
                scene.add(player);
                playerBoundingBox = new THREE.Box3().setFromObject(player).expandByScalar(-0.1); // Slightly smaller box
                console.log("Player created successfully.");
            } catch (error) {
                console.error("Error creating player:", error);
            }
        }

        function createLane(type, zPos) {
            // --- MODIFIED: Added log ---
            console.log(`Creating lane type: ${type} at z: ${zPos}`);
            try { // Added try-catch
                const laneGeometry = new THREE.PlaneGeometry(laneWidth, laneLength);
                const material = laneMaterials[type] || laneMaterials[LANE_TYPES.CARPET]; // Fallback material

                if (!material) {
                    console.error(`Material for lane type ${type} is undefined! Using fallback.`);
                    material = laneMaterials[LANE_TYPES.CARPET];
                    if(!material) { // If even fallback fails
                         console.error("FATAL: Fallback CARPET material is also undefined!");
                         throw new Error("Cannot create lane without material.");
                    }
                }


                const laneMesh = new THREE.Mesh(laneGeometry, material);
                laneMesh.rotation.x = -Math.PI / 2; // Rotate flat
                laneMesh.position.set(0, 0, zPos - laneLength / 2); // Position centered at zPos
                laneMesh.receiveShadow = true; // Lanes receive shadows
                scene.add(laneMesh);
                lanes.push({ mesh: laneMesh, type: type, z: zPos });

                // Add walls, scenery, safe spots, obstacles (these calls could also throw errors)
                createWallSegment(zPos);
                if (type === LANE_TYPES.CARPET || type === LANE_TYPES.WALKWAY) addSceneryToLane(zPos, type);
                if (type === LANE_TYPES.CARPET) addSafeSpotsToLane(zPos);
                if (zPos !== 0 && type !== LANE_TYPES.WATER) addObstaclesToLane(zPos, type);

            } catch (error) {
                console.error(`Error in createLane (type: ${type}, z: ${zPos}):`, error);
                // Rethrow or handle as needed, maybe stop game?
                throw error; // Rethrow to be caught by caller (e.g., startGame)
            }
        }

        function createWallSegment(zPos) {
             // --- MODIFIED: Added log ---
             // console.log(`Creating wall segment at z: ${zPos}`); // Optional: can be noisy
             try { // Added try-catch
                if (!wallMaterial) {
                     console.error("Wall material is undefined! Cannot create walls.");
                     return; // Exit if material is missing
                }
                const wallGeometry = new THREE.BoxGeometry(WALL_THICKNESS, WALL_HEIGHT, laneLength);
                const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
                const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);

                leftWall.position.set(-laneWidth / 2 - WALL_THICKNESS / 2, WALL_HEIGHT / 2, zPos - laneLength / 2);
                rightWall.position.set(laneWidth / 2 + WALL_THICKNESS / 2, WALL_HEIGHT / 2, zPos - laneLength / 2);

                leftWall.castShadow = true;
                leftWall.receiveShadow = true;
                rightWall.castShadow = true;
                rightWall.receiveShadow = true;

                scene.add(leftWall);
                scene.add(rightWall);
                wallSegments.push({ left: leftWall, right: rightWall, z: zPos });
             } catch(error) {
                 console.error(`Error creating wall segment at z ${zPos}:`, error);
             }
        }

        // --- Other creation functions (addSceneryToLane, createDesk, createPlant, etc.) remain largely unchanged ---
        // Consider adding try-catch blocks within them too if errors are suspected there.

        function addSceneryToLane(zPos, type) { try { const numSceneryItems = Math.floor(Math.random() * 3) + 1; for (let i = 0; i < numSceneryItems; i++) { const xPos = (Math.random() - 0.5) * (laneWidth * 0.8); const zOffset = (Math.random() - 0.5) * (laneLength * 0.9); const itemZ = zPos - laneLength / 2 + zOffset; if (Math.random() < 0.7) { createDesk(xPos, itemZ); } else { createPlant(xPos, itemZ); } } } catch(e){ console.error("Error in addSceneryToLane:", e); } }
        function createDesk(x, z) { try { const deskGroup = new THREE.Group(); const topGeo = new THREE.BoxGeometry(2.5, 0.2, 1.5); const legGeo = new THREE.BoxGeometry(0.2, 1.0, 0.2); const top = new THREE.Mesh(topGeo, sceneryMaterials.desk); top.position.y = 1.0 + 0.1; top.castShadow = true; deskGroup.add(top); const legPositions = [ {x: -1.1, z: -0.6}, {x: 1.1, z: -0.6}, {x: -1.1, z: 0.6}, {x: 1.1, z: 0.6} ]; legPositions.forEach(pos => { const leg = new THREE.Mesh(legGeo, sceneryMaterials.desk); leg.position.set(pos.x, 0.5, pos.z); leg.castShadow = true; deskGroup.add(leg); }); deskGroup.position.set(x, 0, z); scene.add(deskGroup); scenery.push(deskGroup); } catch(e){ console.error("Error in createDesk:", e); } }
        function createPlant(x, z) { try { const plantGroup = new THREE.Group(); const potGeo = new THREE.CylinderGeometry(0.5, 0.4, 0.8, 12); const pot = new THREE.Mesh(potGeo, sceneryMaterials.plantPot); pot.position.y = 0.4; pot.castShadow = true; plantGroup.add(pot); const leafGeo = new THREE.SphereGeometry(0.4, 8, 6); const leaves = new THREE.Mesh(leafGeo, sceneryMaterials.plantLeaf); leaves.position.y = 0.8 + 0.3; leaves.castShadow = true; plantGroup.add(leaves); plantGroup.position.set(x, 0, z); scene.add(plantGroup); scenery.push(plantGroup); } catch(e){ console.error("Error in createPlant:", e); } }
        function addSafeSpotsToLane(zPos) { try { const numSpots = Math.random() < 0.4 ? 1 : 0; if (numSpots > 0) { const xPos = (Math.random() - 0.5) * (laneWidth * 0.7); const zOffset = (Math.random() - 0.5) * (laneLength * 0.8); const spotZ = zPos - laneLength / 2 + zOffset; createSafeSpot(xPos, spotZ); } } catch(e){ console.error("Error in addSafeSpotsToLane:", e); } }
        function createSafeSpot(x, z) { try { const spotGeometry = new THREE.CylinderGeometry(1.0, 1.0, 0.1, 16); const spotMesh = new THREE.Mesh(spotGeometry, sceneryMaterials.safeSpot); spotMesh.position.set(x, 0.05, z); spotMesh.receiveShadow = true; scene.add(spotMesh); safeSpots.push(spotMesh); } catch(e){ console.error("Error in createSafeSpot:", e); } }
        function addObstaclesToLane(zPos, type) { try { const obstacleCount = Math.floor(Math.random() * 2) + 1; const speed = (Math.random() * 1.5 + 1.0) * (Math.random() < 0.5 ? 1 : -1); const startX = speed > 0 ? -laneWidth / 2 - OBSTACLE_PLANE_WIDTH : laneWidth / 2 + OBSTACLE_PLANE_WIDTH; for (let i = 0; i < obstacleCount; i++) { const zOffset = (laneLength / (obstacleCount + 1)) * (i + 1) - laneLength / 2; const obstacleZ = zPos + zOffset; createObstacle(startX + i * (speed > 0 ? -2 : 2), obstacleZ, speed, type); } } catch(e){ console.error("Error in addObstaclesToLane:", e); } }
        function createObstacle(x, z, speed, laneType) { try { const obstacleTypes = Object.values(OBSTACLE_TYPES); const randomTypeKey = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)]; const texturesForType = obstacleTextures[randomTypeKey]; if (!texturesForType) { console.warn(`Textures not loaded for obstacle type: ${randomTypeKey}. Skipping obstacle.`); return; } let texture = speed > 0 ? texturesForType.right : texturesForType.left; if (!texture) { console.warn(`Specific direction texture missing for ${randomTypeKey}. Using fallback/skipping.`); if (texturesForType.right) texture = texturesForType.right; else if (texturesForType.left) texture = texturesForType.left; else return; } if (!texture) { console.error(`No valid texture found for obstacle ${randomTypeKey}`); return; } const geometry = new THREE.PlaneGeometry(OBSTACLE_PLANE_WIDTH, OBSTACLE_PLANE_HEIGHT); const material = new THREE.MeshStandardMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, roughness: 0.9, metalness: 0.0 }); const obstacleMesh = new THREE.Mesh(geometry, material); obstacleMesh.position.set(x, OBSTACLE_PLANE_HEIGHT / 2, z); obstacleMesh.castShadow = true; scene.add(obstacleMesh); const obstacleData = { mesh: obstacleMesh, speed: speed, boundingBox: new THREE.Box3().setFromObject(obstacleMesh) }; obstacles.push(obstacleData); } catch(e){ console.error("Error in createObstacle:", e); } }


        // --- Game Logic (Movement, Update, Collision, Generation - Largely Unchanged) ---
        function onKeyDown(event) {
            if (currentGameState !== GAME_STATE.PLAYING || isMoving) return; // Only move when playing and not already moving

            let moved = false;
            let targetX = targetPlayerPosition.x;
            let targetZ = targetPlayerPosition.z;

            switch (event.key) {
                case 'ArrowUp':
                case 'w':
                    targetZ -= laneLength; // Move forward one lane length
                    moved = true;
                    break;
                case 'ArrowDown':
                case 's':
                    // Allow moving back, but don't decrease score
                    targetZ += laneLength;
                    moved = true;
                    break;
                case 'ArrowLeft':
                case 'a':
                    targetX -= laneWidth / 3; // Move left within the lane (adjust step)
                    // Clamp to left edge (ensure player geometry is available)
                    if (player && player.geometry && player.geometry.parameters) {
                         targetX = Math.max(-laneWidth / 2 + player.geometry.parameters.width / 2, targetX);
                    } else {
                         targetX = Math.max(-laneWidth / 2 + 1.0, targetX); // Fallback clamp
                    }
                    moved = true;
                    break;
                case 'ArrowRight':
                case 'd':
                    targetX += laneWidth / 3; // Move right within the lane (adjust step)
                     // Clamp to right edge (ensure player geometry is available)
                    if (player && player.geometry && player.geometry.parameters) {
                         targetX = Math.min(laneWidth / 2 - player.geometry.parameters.width / 2, targetX);
                    } else {
                         targetX = Math.min(laneWidth / 2 - 1.0, targetX); // Fallback clamp
                    }
                    moved = true;
                    break;
            }

            if (moved) {
                // Check if moving forward to update score
                if (targetZ < targetPlayerPosition.z) {
                    score++;
                    infoElement.innerText = `Score: ${score}`;
                    // Generate new lane if moving forward
                    try { // Add try-catch around generateLane call
                        generateLane();
                    } catch (error) {
                         console.error("Error generating new lane during move:", error);
                         // Maybe trigger game over?
                         // gameOver("world_error");
                    }
                }

                targetPlayerPosition.x = targetX;
                targetPlayerPosition.z = targetZ;
                isMoving = true;
                moveStartTime = clock.getElapsedTime();
                lastMoveTime = moveStartTime; // Reset idle timer on move
            }
        }

        function updatePlayerPosition(deltaTime) {
            if (!isMoving || !player) return; // Added check for player existence

            const elapsedTime = clock.getElapsedTime() - moveStartTime;
            const moveProgress = Math.min(elapsedTime * 1000 / moveDuration, 1); // Progress from 0 to 1

            // Smooth interpolation (e.g., ease-out)
            const easedProgress = 1 - Math.pow(1 - moveProgress, 3); // Cubic ease-out

            playerPosition.x = THREE.MathUtils.lerp(player.position.x, targetPlayerPosition.x, easedProgress);
            playerPosition.z = THREE.MathUtils.lerp(player.position.z, targetPlayerPosition.z, easedProgress);

            player.position.set(playerPosition.x, player.position.y, playerPosition.z);

            if (moveProgress >= 1) {
                isMoving = false;
                player.position.set(targetPlayerPosition.x, player.position.y, targetPlayerPosition.z); // Snap to final position
                playerPosition = { ...targetPlayerPosition }; // Update current position state
            }
        }

        function updateObstacles(deltaTime) {
            obstacles.forEach(obstacle => {
                if (obstacle && obstacle.mesh) { // Add checks
                    obstacle.mesh.position.x += obstacle.speed * deltaTime;
                    // Wrap around horizontally
                    if (obstacle.speed > 0 && obstacle.mesh.position.x > laneWidth / 2 + OBSTACLE_PLANE_WIDTH * 2) {
                        obstacle.mesh.position.x = -laneWidth / 2 - OBSTACLE_PLANE_WIDTH * 2;
                    } else if (obstacle.speed < 0 && obstacle.mesh.position.x < -laneWidth / 2 - OBSTACLE_PLANE_WIDTH * 2) {
                        obstacle.mesh.position.x = laneWidth / 2 + OBSTACLE_PLANE_WIDTH * 2;
                    }
                    // Update bounding box after moving
                     if (obstacle.boundingBox) { // Add check
                         obstacle.boundingBox.setFromObject(obstacle.mesh);
                     } else { // Initialize if missing (shouldn't happen ideally)
                          console.warn("Obstacle boundingBox missing, re-initializing.");
                          obstacle.boundingBox = new THREE.Box3().setFromObject(obstacle.mesh);
                     }
                }
            });
        }

        function checkCollisions() {
            if (!player || !playerBoundingBox || currentGameState !== GAME_STATE.PLAYING) return; // Added check for playerBoundingBox

            // Update player bounding box
            try {
                playerBoundingBox.setFromObject(player);
            } catch (e) {
                 console.error("Error updating player bounding box:", e);
                 return; // Can't check collisions if box fails
            }


            // 1. Check Obstacle Collisions
            for (const obstacle of obstacles) {
                 // Add checks for obstacle and its properties
                 if (obstacle && obstacle.mesh && obstacle.boundingBox && playerBoundingBox.intersectsBox(obstacle.boundingBox)) {
                    gameOver("hit"); // Pass reason for game over
                    return; // Stop checking after game over
                }
            }

            // 2. Check Water Collision (if player is over a water lane)
            const currentLane = lanes.find(lane =>
                player.position.z < lane.z && player.position.z >= lane.z - laneLength
            );
            if (currentLane && currentLane.type === LANE_TYPES.WATER) {
                 let onSafeSpot = false;
                 for (const spot of safeSpots) {
                      if (spot && spot.position && player.position.distanceTo(spot.position) < 1.1) { // Added checks
                         onSafeSpot = true;
                         break;
                     }
                 }
                 if (!onSafeSpot) {
                     gameOver("drowned");
                     return;
                 }
            }

            // 3. Check Idle Timeout
            if (clock.getElapsedTime() - lastMoveTime > MAX_IDLE_TIME) {
                gameOver("idle");
                return;
            }
        }

        function generateLane() {
            // console.log("Generating new lane..."); // Optional log
            const nextZ = lastLaneZ - laneLength;
            const laneTypes = Object.values(LANE_TYPES);
            const previousLaneType = lanes.length > 0 ? lanes[lanes.length - 1].type : null;
            let randomType;
            if (previousLaneType === LANE_TYPES.WATER && Math.random() < 0.7) {
                 const nonWaterTypes = laneTypes.filter(t => t !== LANE_TYPES.WATER);
                 randomType = nonWaterTypes[Math.floor(Math.random() * nonWaterTypes.length)];
            } else {
                 randomType = laneTypes[Math.floor(Math.random() * laneTypes.length)];
            }

            createLane(randomType, nextZ); // This might throw an error
            lastLaneZ = nextZ;
        }

        function cleanupOldObjects() {
            const cleanupZ = player ? player.position.z + laneLength * cleanupBuffer : 0; // Z position threshold

            try { // Wrap cleanup logic
                // Cleanup Lanes
                lanes = lanes.filter(lane => {
                    if (lane && lane.mesh && lane.z < cleanupZ) { // Added checks
                        scene.remove(lane.mesh);
                        if (lane.mesh.geometry) lane.mesh.geometry.dispose();
                        // Material disposal handled globally or per-lane if unique
                        return false; // Remove from array
                    }
                    return true; // Keep in array
                });

                // Cleanup Walls
                wallSegments = wallSegments.filter(wall => {
                    if (wall && wall.left && wall.right && wall.z < cleanupZ) { // Added checks
                        scene.remove(wall.left);
                        scene.remove(wall.right);
                        if (wall.left.geometry) wall.left.geometry.dispose(); // Dispose only once if shared
                        // Material disposal handled globally
                        return false;
                    }
                    return true;
                });

                // Cleanup Obstacles
                obstacles = obstacles.filter(obstacle => {
                    if (obstacle && obstacle.mesh && obstacle.mesh.position.z > cleanupZ + laneLength) { // Added checks
                        scene.remove(obstacle.mesh);
                        if (obstacle.mesh.geometry) obstacle.mesh.geometry.dispose();
                        if (obstacle.mesh.material) obstacle.mesh.material.dispose(); // Dispose material if unique per obstacle
                        return false;
                    }
                    return true;
                });

                // Cleanup Scenery
                scenery = scenery.filter(item => {
                    if (item && item.position && item.position.z > cleanupZ + laneLength) { // Added checks
                        scene.remove(item);
                        item.traverse(child => {
                            if (child.isMesh) {
                                if (child.geometry) child.geometry.dispose();
                                // if (child.material) child.material.dispose(); // If materials are unique
                            }
                        });
                        return false;
                    }
                    return true;
                });

                // Cleanup Safe Spots
                safeSpots = safeSpots.filter(spot => {
                    if (spot && spot.position && spot.position.z > cleanupZ + laneLength) { // Added checks
                        scene.remove(spot);
                        if (spot.geometry) spot.geometry.dispose();
                        // if (spot.material) spot.material.dispose(); // If material is unique
                        return false;
                    }
                    return true;
                });
            } catch (error) {
                 console.error("Error during object cleanup:", error);
            }
        }

        // --- Animation Loop (Unchanged) ---
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            try { // Wrap game logic updates
                if (currentGameState === GAME_STATE.PLAYING) {
                    updatePlayerPosition(deltaTime);
                    updateObstacles(deltaTime);
                    checkCollisions(); // Check collisions after updates

                    // Dynamic camera follow
                    if (player) {
                        const targetCameraPos = new THREE.Vector3(
                            player.position.x, // Follow X slightly
                            camera.position.y, // Keep Y fixed for now
                            player.position.z + 12 // Maintain distance behind player
                        );
                        camera.position.lerp(targetCameraPos, deltaTime * 2.0); // Adjust lerp factor for speed
                        camera.lookAt(player.position.x, player.position.y, player.position.z); // Look at player

                        // Update light target to follow player
                        if (directionalLight && directionalLight.target) { // Add check
                            directionalLight.target.position.copy(player.position);
                            directionalLight.target.updateMatrixWorld(); // Important after moving target
                        }


                        // Adjust shadow camera frustum to follow player - helps maintain shadow quality
                        if (directionalLight && directionalLight.shadow) { // Add check
                            const shadowCam = directionalLight.shadow.camera;
                            const followOffset = 10; // How far ahead/behind player the shadow focuses
                            const shadowSize = 25; // Size of the shadow area around the player
                            shadowCam.left = player.position.x - shadowSize;
                            shadowCam.right = player.position.x + shadowSize;
                            shadowCam.top = player.position.z + shadowSize - followOffset;
                            shadowCam.bottom = player.position.z - shadowSize - followOffset;
                            shadowCam.updateProjectionMatrix(); // Apply changes
                        }
                    }

                    // Cleanup objects far behind the player
                    cleanupOldObjects();
                }
            } catch (error) {
                console.error("Error during game update loop:", error);
                // Consider pausing the game or showing an error state
                // currentGameState = GAME_STATE.ERROR; // Example
            }


            // Always render the scene regardless of game state
            if (renderer && scene && camera) {
                try { // Wrap rendering
                    renderer.render(scene, camera);
                } catch (error) {
                     console.error("Error during rendering:", error);
                     // Stop the loop if rendering fails catastrophically
                     if (animationFrameId) cancelAnimationFrame(animationFrameId);
                     animationFrameId = null;
                     alert("A rendering error occurred. Please reload the page.");
                }

            }
        }

        // --- Game Over (Modified for Firebase) ---
        function gameOver(reason = "hit") {
            if (currentGameState === GAME_STATE.GAME_OVER) return; // Prevent multiple calls

            currentGameState = GAME_STATE.GAME_OVER;
            console.log(`Game Over! Score: ${score}, Reason: ${reason}`);
            if(finalScoreElement) finalScoreElement.innerText = score; // Update final score display

            // Set reason text
            if(gameOverReasonElement) {
                 if (reason === "idle") { gameOverReasonElement.innerText = "Took too long!"; }
                 else if (reason === "drowned") { gameOverReasonElement.innerText = "Fell in the water cooler!"; }
                 else { gameOverReasonElement.innerText = "Deadline Missed!"; } // Default "hit"
            }


            showOverlay(gameOverElement); // Show game over screen
            if(infoElement) infoElement.classList.add('hidden'); // Hide in-game score display

            // --- MODIFIED: Submit score to Firebase ---
            const characterName = CHARACTERS[selectedCharacterIndex]?.name || "Unknown"; // Add fallback
            submitScoreToFirebase(characterName, score); // Using character name for now

            // Stop animation loop if desired (or let it run for background)
            // cancelAnimationFrame(animationFrameId);
            // animationFrameId = null;
        }

        // --- Go To Menu (Unchanged) ---
        function goToMenu() {
            currentGameState = GAME_STATE.MENU;
            showOverlay(mainMenuElement);
            // Optional: Reset camera to default menu position
            if(camera) {
                camera.position.set(0, 15, 12);
                camera.lookAt(0, 0, 0);
            }
            // Ensure animation loop is running if it was stopped
            if (!animationFrameId) animate();
        }

        // --- Clear Game Objects (Helper Function - Added Checks) ---
        function clearGameObjects() {
             console.log("Clearing game objects...");
            // Remove Player
            if (player) {
                 if (scene) scene.remove(player);
                 if (player.geometry) player.geometry.dispose();
                 if (player.material) player.material.dispose(); // Dispose material too
            }
            player = null;
            playerBoundingBox = null;

            // Remove Lanes
            lanes.forEach(lane => { if (lane && lane.mesh) { if(scene) scene.remove(lane.mesh); if(lane.mesh.geometry) lane.mesh.geometry.dispose(); } });
            lanes = [];

             // Remove Walls
            wallSegments.forEach(wall => { if (wall) { if(wall.left && scene) scene.remove(wall.left); if(wall.right && scene) scene.remove(wall.right); if(wall.left && wall.left.geometry) wall.left.geometry.dispose(); } }); // Dispose geometry once
            wallSegments = [];

            // Remove Obstacles
            obstacles.forEach(obstacle => { if (obstacle && obstacle.mesh) { if(scene) scene.remove(obstacle.mesh); if(obstacle.mesh.geometry) obstacle.mesh.geometry.dispose(); if(obstacle.mesh.material) obstacle.mesh.material.dispose(); } });
            obstacles = [];

            // Remove Scenery
            scenery.forEach(item => { if (item) { if(scene) scene.remove(item); item.traverse(child => { if (child.isMesh) { if(child.geometry) child.geometry.dispose(); /* if(child.material) child.material.dispose(); */ } }); } });
            scenery = [];

             // Remove Safe Spots
            safeSpots.forEach(spot => { if (spot) { if(scene) scene.remove(spot); if(spot.geometry) spot.geometry.dispose(); /* if(spot.material) spot.material.dispose(); */ } });
            safeSpots = [];

            // Reset score display
            score = 0;
            if(infoElement) infoElement.innerText = `Score: ${score}`;
             console.log("Game objects cleared.");
        }


        // --- Resize Handler (Unchanged) ---
        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // --- Start the application ---
        document.addEventListener('DOMContentLoaded', (event) => {
            console.log("DOM fully loaded and parsed");
            init(); // Initialize everything
        });

    </script>
</body>
</html>

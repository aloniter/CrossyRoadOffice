<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Office Crossing Challenge - Hard Mode</title> {/* Updated Title */}
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #E5E7EB; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display: block;
            color: #333;
            font-size: 24px;
            text-shadow: 1px 1px 2px #ccc;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 101;
            display: none;
            background-color: rgba(50, 50, 50, 0.85);
            color: white;
            padding: 25px 45px;
            border-radius: 12px;
            text-align: center;
            font-size: 32px;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
         #gameOver button {
            margin-top: 20px;
            padding: 12px 24px;
            font-size: 20px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background-color: #5DADE2;
            color: white;
            transition: background-color 0.3s, transform 0.1s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }
        #gameOver button:hover {
            background-color: #3498DB;
        }
         #gameOver button:active {
            transform: scale(0.95);
            background-color: #2E86C1;
        }
    </style>
</head>
<body>
    <div id="info">Score: 0</div>
    <div id="gameOver">
        Deadline Missed!<br>
        Final Score: <span id="finalScore">0</span><br>
        <button onclick="restartGame()">Try Again</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Global Variables ---
        let scene, camera, renderer;
        let player, playerBoundingBox;
        let lanes = [];
        let obstacles = [];
        let score = 0;
        let laneWidth = 2;
        let laneLength = 50; // Width of the office floor area shown
        let playerPosition = { x: 0, z: 0 };
        let targetPlayerPosition = { x: 0, z: 0 };
        let isMoving = false;
        let moveDuration = 150; // Keep move animation duration same
        let moveStartTime = 0;
        let gameOver = false;
        let lastLaneZ = 0;
        let generationDistance = 20; // How many lanes ahead to generate visually
        let cleanupBuffer = 5; // How many lanes to keep behind the player before cleaning up
        let clock = new THREE.Clock();
        let textureLoader = new THREE.TextureLoader();

        // --- THEME Constants ---
        const LANE_TYPES = { CARPET: 'carpet', WALKWAY: 'walkway' };
        const OBSTACLE_TYPES = { CHAIR: 'chair', PERSON: 'person', CART: 'cart' };
        const CARPET_COLORS = [0xD2B48C, 0xAAAAAA, 0xBDB76B]; // Tan, Grey, DarkKhaki
        const WALKWAY_COLOR = 0xCCCCCC; // Light grey floor
        const OBSTACLE_COLORS = {
            [OBSTACLE_TYPES.CHAIR]: [0x8B4513, 0x000000, 0x444444], // Brown, Black, Dark Grey
            [OBSTACLE_TYPES.PERSON]: [0x6495ED, 0x808080, 0xF5F5DC, 0xB0C4DE], // CornflowerBlue, Grey, Beige, LightSteelBlue
            [OBSTACLE_TYPES.CART]: [0x778899, 0x4682B4] // LightSlateGray, SteelBlue
        };
        const WALL_COLOR = 0xF5F5F5; // Off-white wall color
        const BACKGROUND_COLOR = 0xE5E7EB; // Light grey background
        const FOG_COLOR = 0xE5E7EB;
        const PLAYER_IMAGE_URL = 'Alon.png'; // Assuming this works with local server now
        const PLAYER_WIDTH = 1.0;
        const PLAYER_HEIGHT = 1.2;

        // --- Initialization ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(BACKGROUND_COLOR);
            scene.fog = new THREE.Fog(FOG_COLOR, 15, 50); // Slightly increase fog end distance

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 7);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(10, 15, 12);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 60;
            directionalLight.shadow.camera.left = -30; // Adjust shadow camera to include walls if needed
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            directionalLight.shadow.bias = -0.0005;
            scene.add(directionalLight);

            // --- Player (Image Plane) ---
            const playerTexture = textureLoader.load(
                PLAYER_IMAGE_URL,
                () => { console.log(`Player texture '${PLAYER_IMAGE_URL}' loaded successfully.`); },
                undefined,
                (err) => {
                    console.error(`Error loading player texture '${PLAYER_IMAGE_URL}':`, err);
                    if (player && player.material) {
                        player.material.map = null; player.material.color.set(0xff00ff);
                        player.material.needsUpdate = true; console.log("Player color set to pink due to texture load error.");
                    }
                }
            );
            const playerGeometry = new THREE.PlaneGeometry(PLAYER_WIDTH, PLAYER_HEIGHT);
            const playerMaterial = new THREE.MeshLambertMaterial({ map: playerTexture, transparent: true, side: THREE.DoubleSide });
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(playerPosition.x, PLAYER_HEIGHT / 2, playerPosition.z);
            player.castShadow = true; player.receiveShadow = false; scene.add(player);
            playerBoundingBox = new THREE.Box3().setFromObject(player);

            // --- Walls ---
            const wallHeight = 4;
            const wallThickness = 1;
            const wallLength = 300; // Make walls very long
            const wallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wallLength);
            const wallMaterial = new THREE.MeshLambertMaterial({ color: WALL_COLOR });

            // Position walls slightly outside the laneLength
            const wallXOffset = laneLength / 2 + wallThickness / 2;
            // Center the long walls roughly around the initial visible area
            const wallZCenter = -(generationDistance * laneWidth / 2);

            const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
            leftWall.position.set(-wallXOffset, wallHeight / 2, wallZCenter);
            leftWall.receiveShadow = true; // Walls receive shadows
            scene.add(leftWall);

            const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
            rightWall.position.set(wallXOffset, wallHeight / 2, wallZCenter);
            rightWall.receiveShadow = true;
            scene.add(rightWall);

            // Initial Lanes
            createLane(LANE_TYPES.CARPET, 0);
            for (let i = 1; i < generationDistance; i++) {
                generateLane();
            }

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);

             // Start Animation Loop
             window.onload = () => {
                clock.start();
                animate();
             };
        }

        // --- Lane and Obstacle Generation ---
        function createLane(type, zPos) {
            const laneGeometry = new THREE.PlaneGeometry(laneLength, laneWidth);
            let laneMaterial;
            let laneData = { mesh: null, type: type, z: zPos, obstacles: [] };
            if (type === LANE_TYPES.CARPET) {
                const carpetColor = CARPET_COLORS[Math.floor(Math.random() * CARPET_COLORS.length)];
                laneMaterial = new THREE.MeshLambertMaterial({ color: carpetColor, side: THREE.DoubleSide });
            } else { // WALKWAY
                laneMaterial = new THREE.MeshLambertMaterial({ color: WALKWAY_COLOR, side: THREE.DoubleSide });
            }
            const laneMesh = new THREE.Mesh(laneGeometry, laneMaterial);
            laneMesh.rotation.x = -Math.PI / 2; laneMesh.position.set(0, 0, zPos); laneMesh.receiveShadow = true;
            scene.add(laneMesh); laneData.mesh = laneMesh; lanes.push(laneData);
            if (type === LANE_TYPES.WALKWAY) addObstaclesToLane(laneData); // Add obstacles to walkways
            lastLaneZ = zPos; return laneData;
        }

        // --- UPDATED Lane Generation (More Walkways) ---
        function generateLane() {
            const nextZ = lastLaneZ - laneWidth;
            // Increase base probability and scaling for walkways
            const probabilityOfWalkway = Math.max(0.55, Math.min(0.9, 0.55 + Math.abs(nextZ / 70)));
            const laneType = Math.random() < probabilityOfWalkway ? LANE_TYPES.WALKWAY : LANE_TYPES.CARPET;
            createLane(laneType, nextZ);
        }

        // --- UPDATED Obstacle Generation (Increased Difficulty) ---
        function addObstaclesToLane(laneData) {
            // Increase max obstacles faster and higher cap
            const maxObstacles = Math.min(5, 1 + Math.floor(score / 10));
            const numObstacles = Math.floor(Math.random() * maxObstacles) + 1;

            // Increase speed multiplier effect and base speed range
            const speedMultiplier = 1 + Math.min(1.5, score / 80); // Faster increase, higher cap
            const baseSpeed = (0.05 + Math.random() * 0.06) * speedMultiplier; // Higher base and range
            const speed = baseSpeed * (Math.random() < 0.5 ? 1 : -1);
            const direction = Math.sign(speed);

            const startEdge = (laneLength / 2 + 3) * direction * -1;
            const minSpacing = 5; // Slightly reduce min spacing for density
            const totalSpacingNeeded = (numObstacles -1) * minSpacing;
            const randomSpacingPool = Math.max(0, laneLength - totalSpacingNeeded);
            let currentX = startEdge;

            for (let i = 0; i < numObstacles; i++) {
                const obstacleTypeKeys = Object.keys(OBSTACLE_TYPES);
                const randomTypeKey = obstacleTypeKeys[Math.floor(Math.random() * obstacleTypeKeys.length)];
                const obstacleType = OBSTACLE_TYPES[randomTypeKey];
                let obstacleGeometry, obstacleMaterial, obstacleYPosition;
                const colorsForType = OBSTACLE_COLORS[obstacleType];
                const randomColor = colorsForType[Math.floor(Math.random() * colorsForType.length)];
                obstacleMaterial = new THREE.MeshLambertMaterial({ color: randomColor });
                switch (obstacleType) {
                    case OBSTACLE_TYPES.CHAIR: obstacleGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8); obstacleYPosition = 0.4; break;
                    case OBSTACLE_TYPES.PERSON: obstacleGeometry = new THREE.BoxGeometry(0.6, 1.5, 0.6); obstacleYPosition = 0.75; break;
                    case OBSTACLE_TYPES.CART: obstacleGeometry = new THREE.BoxGeometry(1.2, 0.6, 0.8); obstacleYPosition = 0.3; break;
                    default: obstacleGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8); obstacleYPosition = 0.4;
                }
                const obstacleMesh = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                if (i > 0) {
                    const spacingToAdd = minSpacing + (numObstacles > 1 ? Math.random() * (randomSpacingPool / (numObstacles - 1)) : 0);
                    currentX -= spacingToAdd * direction;
                }
                obstacleMesh.position.set(currentX, obstacleYPosition, laneData.z);
                obstacleMesh.castShadow = true; obstacleMesh.receiveShadow = false; scene.add(obstacleMesh);
                const obstacleBoundingBox = new THREE.Box3().setFromObject(obstacleMesh);
                const obstacleData = { mesh: obstacleMesh, boundingBox: obstacleBoundingBox, speed: speed, direction: direction, laneZ: laneData.z, type: obstacleType };
                obstacles.push(obstacleData); laneData.obstacles.push(obstacleData);
            }
        }

        // --- Game Loop and Updates ---
        function animate() {
            if (gameOver) {
                 if (player.scale.x > 0.01) player.scale.multiplyScalar(0.9); else player.scale.set(0,0,0);
                 requestAnimationFrame(animate); renderer.render(scene, camera); return;
            }
            requestAnimationFrame(animate); const deltaTime = clock.getDelta();
            movePlayerVisually(deltaTime); moveObstacles();
            playerBoundingBox.setFromObject(player);
            checkCollisions(); updateCamera();
            if (player.position.z < lastLaneZ + (generationDistance * laneWidth)) generateLane();
            cleanupEnvironment();
            renderer.render(scene, camera);
        }

        // --- Player Movement (Hop only) ---
        function movePlayerVisually(deltaTime) {
             const playerBaseY = PLAYER_HEIGHT / 2;
             if (isMoving) {
                const elapsedTime = clock.elapsedTime * 1000 - moveStartTime;
                let progress = Math.min(1.0, elapsedTime / moveDuration);
                const easedProgress = progress * (2 - progress);
                const startVec = new THREE.Vector3(playerPosition.x, playerBaseY, playerPosition.z);
                const endVec = new THREE.Vector3(targetPlayerPosition.x, playerBaseY, targetPlayerPosition.z);
                player.position.lerpVectors(startVec, endVec, easedProgress);
                const hopHeight = 0.5;
                player.position.y = playerBaseY + Math.sin(progress * Math.PI) * hopHeight;
                if (progress >= 1.0) {
                    player.position.copy(endVec); player.position.y = playerBaseY;
                    isMoving = false; playerPosition.x = targetPlayerPosition.x; playerPosition.z = targetPlayerPosition.z;
                    playerBoundingBox.setFromObject(player);
                }
            }
        }

        // --- Obstacle Movement (Unchanged) ---
        function moveObstacles() {
            const wrapEdge = laneLength / 2 + 4; // Obstacles still wrap off-screen past the visible floor width
            obstacles.forEach(obstacle => {
                let currentSpeed = obstacle.speed; obstacle.mesh.position.x += currentSpeed;
                if (obstacle.direction > 0 && obstacle.mesh.position.x > wrapEdge) obstacle.mesh.position.x = -wrapEdge;
                else if (obstacle.direction < 0 && obstacle.mesh.position.x < -wrapEdge) obstacle.mesh.position.x = wrapEdge;
                obstacle.boundingBox.setFromObject(obstacle.mesh);
            });
        }

        // --- Camera Update (Unchanged) ---
         function updateCamera() {
            const targetCameraPosition = new THREE.Vector3( player.position.x, camera.position.y, player.position.z + 7 );
            camera.position.lerp(targetCameraPosition, 0.06);
             const targetLookAt = new THREE.Vector3( player.position.x, 0.5, player.position.z - 6 );
            const currentLookAt = new THREE.Vector3();
            camera.getWorldDirection(currentLookAt).multiplyScalar(10).add(camera.position);
            currentLookAt.lerp(targetLookAt, 0.07); camera.lookAt(currentLookAt);
        }

        // --- Collision Detection (Unchanged) ---
        function checkCollisions() {
             if (!isMoving) {
                 // Check collision with obstacles
                 obstacles.forEach(obstacle => {
                     if (Math.abs(player.position.z - obstacle.laneZ) < laneWidth / 2) {
                         if (playerBoundingBox.intersectsBox(obstacle.boundingBox)) triggerGameOver();
                     }
                 });

                 // Optional: Check collision with walls? (Could stop movement or trigger game over)
                 // For now, walls are just visual boundaries.
             }
        }

        // --- Environment Cleanup (Unchanged) ---
        function cleanupEnvironment() {
            const cleanupThresholdZ = player.position.z + (cleanupBuffer * laneWidth); // Z value behind player to clean up
            lanes = lanes.filter(lane => {
                if (lane.z < cleanupThresholdZ) return true; // Keep lane if it's NOT too far behind
                else { // Remove lane and its obstacles
                    lane.obstacles.forEach(obstacle => {
                         const index = obstacles.indexOf(obstacle); if (index > -1) obstacles.splice(index, 1);
                         if (obstacle.mesh.parent) scene.remove(obstacle.mesh);
                    });
                    if (lane.mesh.parent) scene.remove(lane.mesh); return false;
                }
            });
            obstacles = obstacles.filter(obstacle => { // Redundant obstacle check
                if (obstacle.laneZ < cleanupThresholdZ) return true;
                else { if (obstacle.mesh.parent) scene.remove(obstacle.mesh); return false; }
            });
        }

        // --- Player Controls (Unchanged) ---
        function onKeyDown(event) {
            if (gameOver || isMoving) return; let moved = false; const currentX = playerPosition.x; const currentZ = playerPosition.z;
            switch (event.key) {
                case 'ArrowUp': case 'w': targetPlayerPosition.z = currentZ - laneWidth; targetPlayerPosition.x = currentX; score++; document.getElementById('info').innerText = `Score: ${score}`; moved = true; break;
                case 'ArrowLeft': case 'a': targetPlayerPosition.x = currentX - laneWidth; targetPlayerPosition.z = currentZ; moved = true; break;
                case 'ArrowRight': case 'd': targetPlayerPosition.x = currentX + laneWidth; targetPlayerPosition.z = currentZ; moved = true; break;
                 case 'ArrowDown': case 's': targetPlayerPosition.z = currentZ + laneWidth; targetPlayerPosition.x = currentX; moved = true; break;
            }
            // Prevent moving into walls (simple boundary check)
            const nextX = targetPlayerPosition.x;
            const wallBoundary = laneLength / 2; // Player center shouldn't go past the edge of the lanes
            if (moved && (nextX > wallBoundary || nextX < -wallBoundary)) {
                 moved = false; // Cancel move if it goes beyond lane edges
                 targetPlayerPosition.x = currentX; // Reset target X
                 targetPlayerPosition.z = currentZ; // Reset target Z
            }

            if (moved) { isMoving = true; moveStartTime = clock.elapsedTime * 1000; }
        }

        // --- Game State (Unchanged) ---
        function triggerGameOver() {
            if (gameOver) return; gameOver = true;
            document.getElementById('finalScore').innerText = score; document.getElementById('gameOver').style.display = 'block';
        }

        // --- Restart Game (Unchanged) ---
        function restartGame() {
            score = 0; gameOver = false; playerPosition = { x: 0, z: 0 }; targetPlayerPosition = { x: 0, z: 0 }; lastLaneZ = 0; isMoving = false;
            player.position.set(playerPosition.x, PLAYER_HEIGHT / 2, playerPosition.z); player.scale.set(1, 1, 1); playerBoundingBox.setFromObject(player);
            // Note: Walls are static and not removed/re-added on restart
            for (let i = obstacles.length - 1; i >= 0; i--) { const obstacle = obstacles[i]; if (obstacle.mesh.parent) scene.remove(obstacle.mesh); } obstacles = [];
            for (let i = lanes.length - 1; i >= 0; i--) { const lane = lanes[i]; if (lane.mesh.parent) scene.remove(lane.mesh); } lanes = [];
            document.getElementById('info').innerText = `Score: ${score}`; document.getElementById('gameOver').style.display = 'none';
            createLane(LANE_TYPES.CARPET, 0); for (let i = 1; i < generationDistance; i++) generateLane();
            camera.position.set(0, 8, 7); camera.lookAt(0, 0, 0);
            animate();
        }

        // --- Utility Functions ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Start the game ---
        init();

    </script>
</body>
</html>

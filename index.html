<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Office Crossing Challenge - Firebase Edition!</title>
    <style>
        /* Basic styling for the game elements */
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            font-family: sans-serif;
            background: linear-gradient(to bottom, #87CEEB, #B0E0E6); /* Light blue gradient background */
            color: #333;
            height: 100vh; /* Full viewport height */
        }
        canvas {
            display: block; /* Remove extra space below canvas */
            width: 100%; /* Make canvas fill width */
            height: 100%; /* Make canvas fill height */
        }
        /* Styling for overlay menus (Main Menu, Scoreboard, Game Over) */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background-color: rgba(0, 0, 0, 0.75); /* Semi-transparent black background */
            color: white;
            z-index: 100; /* Ensure overlays are on top */
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
        }
        .hidden {
            display: none; /* Class to hide overlays */
        }
        .overlay-content {
            background-color: rgba(40, 60, 80, 0.9); /* Darker, slightly transparent box for content */
            padding: 30px 40px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4); /* Drop shadow */
            max-width: 90%;
            width: 450px; /* Fixed width for the content box */
        }
        .overlay h2 {
            margin-top: 0;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.5); /* Separator line */
            padding-bottom: 10px;
            color: #FFD700; /* Gold color for headings */
        }
        .overlay button {
            display: block;
            width: 80%;
            margin: 15px auto; /* Center buttons */
            padding: 12px 20px;
            font-size: 18px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background-color: #4682B4; /* Steel blue button */
            color: white;
            transition: background-color 0.3s, transform 0.1s; /* Smooth transitions */
            box-shadow: 0 4px 6px rgba(0,0,0,0.2); /* Button shadow */
        }
        .overlay button:hover {
            background-color: #5A9BD5; /* Lighter blue on hover */
        }
        .overlay button:active {
            transform: scale(0.95); /* Slight shrink effect on click */
            background-color: #41729F; /* Darker blue on click */
        }
        /* Character Selection Specific Styles */
        #mainMenu .character-selection {
            margin-bottom: 20px;
            padding: 10px;
            background-color: rgba(255,255,255,0.1); /* Slightly lighter background for selection area */
            border-radius: 8px;
            max-height: 250px; /* Limit height and allow scrolling */
            overflow-y: auto;
        }
        #mainMenu .character-selection h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 16px;
        }
        #mainMenu .char-button {
            display: inline-block; /* Allow buttons side-by-side */
            width: auto; /* Fit content */
            padding: 8px 15px;
            margin: 5px;
            font-size: 14px;
            border: 2px solid transparent; /* Border for selection indicator */
            background-color: #6c757d; /* Grey button */
        }
        #mainMenu .char-button.selected {
            border-color: #FFD700; /* Gold border for selected character */
            background-color: #4682B4; /* Blue background for selected */
        }
        /* Scoreboard Specific Styles */
        #scoreboardScreen ol {
            margin: 0 0 15px 0;
            padding: 0 0 0 25px; /* Indent list items */
            list-style-position: outside;
            max-height: 150px; /* Limit height and allow scrolling */
            overflow-y: auto;
        }
        #scoreboardScreen li {
            margin-bottom: 8px;
            white-space: nowrap; /* Prevent wrapping */
            overflow: hidden; /* Hide overflow */
            text-overflow: ellipsis; /* Add ... for long names */
            font-size: 16px;
            border-bottom: 1px dotted rgba(255, 255, 255, 0.2); /* Dotted separator */
            padding-bottom: 4px;
        }
        #scoreboardScreen li:last-child {
            border-bottom: none; /* Remove border from last item */
        }
        #scoreboardScreen li span {
            display: inline-block; /* Needed for positioning */
        }
        #scoreboardScreen li .score {
            float: right; /* Align score to the right */
            font-weight: bold;
            margin-left: 15px;
        }
        #scoreboardScreen .no-scores {
            text-align: center;
            font-style: italic;
            color: #ccc; /* Lighter color for message */
            margin-top: 10px;
        }
        /* In-Game Score Display */
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            width: auto;
            text-align: left;
            z-index: 50; /* Below overlays */
            display: block;
            color: #000080; /* Navy blue text */
            font-size: 24px;
            font-weight: bold;
            text-shadow: 1px 1px 1px #FFFFFF; /* White text shadow for readability */
            background-color: rgba(255, 255, 255, 0.6); /* Semi-transparent white background */
            padding: 5px 10px;
            border-radius: 5px;
        }
        /* Game Over Specific Styles */
        #gameOver {
            z-index: 101; /* Ensure Game Over is on top if needed */
        }
        #gameOverReason {
            font-size: 24px;
            margin-bottom: 15px;
            font-style: italic;
            color: #ffdddd; /* Light red color for the reason */
        }
    </style>
</head>
<body>
    <div id="info" class="hidden">Score: 0</div>

    <div id="mainMenu" class="overlay">
        <div class="overlay-content">
            <h2>Ops & QA Crossing Challenge</h2>
            <div class="character-selection">
                <h3>Select Character</h3>
                <div id="characterButtons">
                    </div>
            </div>
            <button id="startGameButton">Start Game</button>
            <button id="viewScoresButton">High Scores</button>
        </div>
    </div>

    <div id="scoreboardScreen" class="overlay hidden">
        <div class="overlay-content">
            <h2>High Scores</h2>
            <ol id="scoreList"></ol>
            <div id="noScoresMessage" class="no-scores" style="display: none;">Loading scores...</div>
            <button id="backToMenuButton">Back to Menu</button>
        </div>
    </div>

    <div id="gameOver" class="overlay hidden">
        <div class="overlay-content">
            <h2 id="gameOverReason">You lost, go back to work!</h2>
            Final Score: <span id="finalScore">0</span><br>
            <button onclick="goToMenu()">Main Menu</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-firestore-compat.js"></script>

    <script>
        // --- Firebase Configuration ---
        // IMPORTANT: Replace with your actual Firebase project configuration!
        // It's recommended to use environment variables or a backend to manage API keys in production.
        const firebaseConfig = {
            apiKey: "YOUR_API_KEY", // Replace with your actual API key
            authDomain: "YOUR_AUTH_DOMAIN", // Replace with your actual auth domain
            projectId: "YOUR_PROJECT_ID", // Replace with your actual project ID
            storageBucket: "YOUR_STORAGE_BUCKET", // Replace with your actual storage bucket
            messagingSenderId: "YOUR_MESSAGING_SENDER_ID", // Replace with your actual sender ID
            appId: "YOUR_APP_ID" // Replace with your actual app ID
        };

        // --- Initialize Firebase ---
        let db; // Firestore database instance
        let highScoresCollection; // Reference to the high scores collection
        try {
            firebase.initializeApp(firebaseConfig);
            db = firebase.firestore(); // Get a Firestore instance
            highScoresCollection = db.collection('highscores'); // Reference to the 'highscores' collection
            console.log("Firebase initialized successfully.");
        } catch (e) {
            console.error("Firebase initialization failed:", e);
            // Alert the user or handle the lack of Firebase connection gracefully
            alert("Could not connect to Firebase. High score functionality will be unavailable.");
            // Optionally, disable high score features in the UI
        }

        // --- Game States ---
        // Define possible states the game can be in
        const GAME_STATE = { MENU: 'menu', PLAYING: 'playing', GAME_OVER: 'game_over', SHOW_SCORES: 'show_scores' };
        let currentGameState = GAME_STATE.MENU; // Start in the main menu

        // --- Global Game Variables ---
        let scene, camera, renderer; // Three.js core components
        let player, playerBoundingBox; // Player object and its collision box
        let lanes = []; // Array to hold lane data (type, position, obstacles, etc.)
        let obstacles = []; // Array to hold active obstacle objects
        let score = 0; // Current game score
        let scenery = []; // Array for decorative scenery objects (desks, plants)
        let safeSpots = []; // Array for safe spots on water lanes (logs, platforms)
        let wallSegments = []; // Array for the side walls to keep the player contained
        let laneWidth = 6; // Width of each lane
        let laneLength = 80; // Length of the visible lane area (affects wall placement)
        let playerPosition = { x: 0, z: 0 }; // Logical grid position of the player (column, row)
        let targetPlayerPosition = { x: 0, z: 0 }; // Target world position for smooth player movement
        let isMoving = false; // Flag to indicate if the player is currently animating a move
        let moveDuration = 150; // Duration of player move animation in milliseconds
        let moveStartTime = 0; // Timestamp when the current move started
        let lastLaneZ = 0; // Z-position of the furthest generated lane
        let generationDistance = 20; // How many lanes ahead of the player to generate
        let cleanupBuffer = 5; // How many lanes behind the player to keep before removing
        let clock = new THREE.Clock(); // Three.js clock for delta time (smooth animations)
        let textureLoader = new THREE.TextureLoader(); // Utility for loading image textures
        const MAX_HIGH_SCORES = 10; // Maximum number of high scores to store and display
        let animationFrameId = null; // ID for the requestAnimationFrame loop (to cancel it)
        let laneMaterials = {}; // Cache for lane materials to avoid recreating them
        let wallMaterial; // Material for side walls
        let sceneryMaterials = {}; // Cache for scenery materials
        let lastMoveTime = 0; // Timestamp of the last player move (for idle check)
        const MAX_IDLE_TIME = 10.0; // Maximum time (seconds) player can be idle before game over
        let directionalLight; // Main light source for shadows

        // --- Wall Constants ---
        const WALL_HEIGHT = 8; // How tall the side walls are
        const WALL_THICKNESS = 1.0; // How thick the side walls are

        // --- Character Definitions ---
        // Add or remove characters here.
        // Ensure image paths are correct relative to the HTML file OR use null for default.
        // Width and height define the size of the character plane.
        const CHARACTERS = [
             { name: 'Alon', imageUrl: 'Alon.png', width: 2.8, height: 3.36 },
             { name: 'Sahar', imageUrl: 'Sahar.png', width: 2.8, height: 3.36 },
             { name: 'Mor', imageUrl: 'Mor.png', width: 2.8, height: 3.36 },
             { name: 'Lin', imageUrl: 'Lin.png', width: 2.8, height: 3.36 },
             { name: 'Asaf', imageUrl: 'Asaf.png', width: 2.8, height: 3.36 },
             { name: 'Tal', imageUrl: 'Tal.png', width: 2.8, height: 3.36 },
             { name: 'Ron', imageUrl: 'Ron.png', width: 2.8, height: 3.36 },
             { name: 'Hadar', imageUrl: 'Hadar.png', width: 2.8, height: 3.36 },
             { name: 'Adi', imageUrl: 'Adi.png', width: 2.8, height: 3.36 },
             { name: 'Alex', imageUrl: 'Alex.png', width: 2.8, height: 3.36 },
             { name: 'Amit', imageUrl: 'Amit.png', width: 2.8, height: 3.36 },
             { name: 'Anna', imageUrl: 'Anna.png', width: 2.8, height: 3.36 },
             { name: 'May Boss', imageUrl: 'May Boss.png', width: 2.8, height: 3.36 },
             { name: 'May QA', imageUrl: 'May QA.png', width: 2.8, height: 3.36 },
             { name: 'Ofek', imageUrl: 'Ofek.png', width: 2.8, height: 3.36 },
             // --- ADDED CHARACTERS ---
             { name: 'Oleksandr', imageUrl: 'Oleksandr.png', width: 2.8, height: 3.36 }, // Added Oleksandr
             { name: 'Ernest', imageUrl: 'Ernest.png', width: 2.8, height: 3.36 },     // Added Ernest
             // --- END ADDED CHARACTERS ---
             { name: 'Default', imageUrl: null, width: 2.2, height: 2.2 } // Fallback if images fail or not provided
        ];
        let selectedCharacterIndex = 0; // Index of the currently selected character in the CHARACTERS array
        let characterTextures = {}; // Cache for loaded character textures to improve performance

        // --- Theme Constants & Colors ---
        const LANE_TYPES = { CARPET: 'carpet', WALKWAY: 'walkway', WATER: 'water' }; // Types of lanes
        const DEFAULT_PLAYER_COLOR = 0xADD8E6; // Light blue for default player cube
        const DEFAULT_OBSTACLE_COLOR = 0xff00ff; // Magenta for default obstacle cube
        const SCENERY_COLORS = { DESK: 0xAF8F6D, PLANT_POT: 0xCD853F, PLANT_LEAF: 0x2E8B57 }; // Colors for scenery elements
        const SAFE_SPOT_COLOR = 0x90EE90; // Light green for safe spots on water
        const WATER_COLOR = 0x1E90FF; // Dodger blue for water lanes

        // --- Obstacle Definitions ---
        // Define types of obstacles and their corresponding image files.
        // 'right' image is for obstacles moving right, 'left' for obstacles moving left.
        const OBSTACLE_TYPES = { CC: 'cc', LIVE_CHANGE: 'live_change', ON_CALL: 'on_call' };
        const OBSTACLE_IMAGES = {
            [OBSTACLE_TYPES.CC]: { right: 'CC.png', left: 'CC R.png' },
            [OBSTACLE_TYPES.LIVE_CHANGE]: { right: 'Live Change.png', left: 'Live Change R.png' },
            [OBSTACLE_TYPES.ON_CALL]: { right: 'On Call.png', left: 'On Call R.png' }
        };
        let obstacleTextures = {}; // Cache for loaded obstacle textures
        const OBSTACLE_PLANE_WIDTH = 5.0; // Visual width of obstacle planes using images
        const OBSTACLE_PLANE_HEIGHT = 5.0; // Visual height of obstacle planes using images

        // --- DOM Element References ---
        // Get references to HTML elements used for UI
        let infoElement, mainMenuElement, scoreboardScreenElement, gameOverElement;
        let characterButtonsElement, startGameButton, viewScoresButton, backToMenuButton;
        let scoreListElement, noScoresMessageElement, finalScoreElement, gameOverReasonElement;

        // --- Texture Generation Functions (Procedural textures for variety) ---

        /**
         * Creates a simple noise texture programmatically.
         * Used for adding subtle detail to flat surfaces.
         * @param {number} width - Texture width.
         * @param {number} height - Texture height.
         * @param {string} color1 - Base color (hex string or CSS color name).
         * @param {string} color2 - Noise color (typically darker).
         * @param {number} [alpha=1] - Opacity (0 to 1).
         * @returns {THREE.CanvasTexture} The generated texture.
         */
        function createNoiseTexture(width, height, color1, color2, alpha = 1) {
            const canvas = document.createElement('canvas');
            canvas.width = width; canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color1;
            ctx.fillRect(0, 0, width, height);
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            // Add random darker pixels for noise effect
            for (let i = 0; i < data.length; i += 4) {
                if (Math.random() > 0.85) { // Adjust density of noise
                    const shade = Math.random() * 50 + (color2 === '#000000' ? 0 : 205); // Calculate shade based on noise color
                    data[i] = shade; data[i + 1] = shade; data[i + 2] = shade; // Apply shade (grayscale noise)
                }
                data[i + 3] = alpha * 255; // Set alpha (opacity)
            }
            ctx.putImageData(imageData, 0, 0);
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping; // Allow texture tiling
            texture.needsUpdate = true; // Ensure texture updates
            return texture;
        }

        /**
         * Creates a simple tile pattern texture programmatically.
         * Used for walkway lanes.
         * @param {number} width - Texture width.
         * @param {number} height - Texture height.
         * @param {string} bgColor - Background color of the tiles.
         * @param {string} lineColor - Color of the tile grid lines.
         * @param {number} tileSize - Size of each square tile.
         * @returns {THREE.CanvasTexture} The generated texture.
         */
        function createTileTexture(width, height, bgColor, lineColor, tileSize) {
            const canvas = document.createElement('canvas');
            canvas.width = width; canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, width, height);
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = Math.max(1, Math.floor(width / 100)); // Line thickness relative to texture size
            ctx.beginPath();
            // Draw vertical lines
            for (let x = 0; x <= width; x += tileSize) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
            // Draw horizontal lines
            for (let y = 0; y <= height; y += tileSize) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
            ctx.stroke();
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping; // Allow texture tiling
            texture.needsUpdate = true; // Ensure texture updates
            return texture;
        }

        // --- Firebase Leaderboard Functions ---

        /**
         * Fetches the top high scores from Firebase Firestore and displays them.
         * Uses async/await for cleaner asynchronous code. Handles loading and error states.
         */
        async function fetchAndDisplayHighScores() {
            // Checks if Firestore is initialized, displays message and exits if not.
            if (!highScoresCollection) {
                console.warn("Firestore not initialized. Cannot fetch scores.");
                noScoresMessageElement.textContent = 'High scores unavailable (DB connection failed).';
                noScoresMessageElement.style.display = 'block';
                scoreListElement.innerHTML = '';
                return;
            }

            console.log("Fetching high scores from Firebase...");
            // Clears previous scores and shows loading message.
            scoreListElement.innerHTML = '';
            noScoresMessageElement.textContent = 'Loading scores...';
            noScoresMessageElement.style.display = 'block';

            try {
                // Queries Firestore for the top N scores, ordered descending.
                const querySnapshot = await highScoresCollection
                    .orderBy('score', 'desc')
                    .limit(MAX_HIGH_SCORES)
                    .get();

                // Extracts score data from the query results.
                const scores = [];
                querySnapshot.forEach((doc) => {
                    scores.push(doc.data());
                });

                console.log("Scores fetched:", scores);

                // Displays scores or a "no scores yet" message.
                if (scores.length === 0) {
                    noScoresMessageElement.textContent = 'No scores yet! Be the first!';
                    noScoresMessageElement.style.display = 'block';
                } else {
                    noScoresMessageElement.style.display = 'none';
                    scores.forEach((scoreEntry) => {
                        // Creates list items for each score, sanitizing name and ensuring score is a number.
                        const li = document.createElement('li');
                        const displayName = scoreEntry.name ? String(scoreEntry.name).substring(0, 15).replace(/</g, "&lt;").replace(/>/g, "&gt;") : 'Anonymous';
                        const displayScore = Number(scoreEntry.score) || 0;
                        const nameSpan = document.createElement('span');
                        nameSpan.className = 'name';
                        nameSpan.textContent = displayName;
                        const scoreSpan = document.createElement('span');
                        scoreSpan.className = 'score';
                        scoreSpan.textContent = displayScore;
                        li.appendChild(nameSpan);
                        li.appendChild(scoreSpan);
                        scoreListElement.appendChild(li);
                    });
                }
            } catch (error) {
                // Logs errors and displays an error message to the user.
                console.error("Error fetching high scores: ", error);
                noScoresMessageElement.textContent = 'Error loading scores.';
                noScoresMessageElement.style.display = 'block';
            }
        }

        /**
         * Saves a score to Firebase Firestore if it qualifies for the top list.
         * Manages the size of the high score list by pruning older/lower scores.
         * Uses async/await.
         * @param {string} playerName - The name of the player.
         * @param {number} newScore - The score achieved by the player.
         */
        async function saveScoreIfHighScore(playerName, newScore) {
             // Checks if Firestore is initialized, exits if not.
             if (!highScoresCollection) {
                console.warn("Firestore not initialized. Cannot save score.");
                return;
            }

            // Sanitizes player name and ensures score is a valid number.
            const nameToSave = playerName ? String(playerName).substring(0, 20).trim() : 'Anonymous';
            const scoreToSave = Number(newScore);

            // Doesn't save invalid, zero, or negative scores.
            if (isNaN(scoreToSave) || scoreToSave <= 0) {
                console.log(`Score (${newScore}) is invalid or zero, not saving.`);
                return;
            }

            console.log(`Checking if score ${scoreToSave} for ${nameToSave} is a high score...`);

            try {
                // Gets current top scores to check if the new score qualifies.
                const querySnapshot = await highScoresCollection
                    .orderBy('score', 'desc')
                    .limit(MAX_HIGH_SCORES)
                    .get();

                const currentTopScores = [];
                querySnapshot.forEach(doc => currentTopScores.push({ id: doc.id, ...doc.data() }));

                // Finds the lowest score currently in the top list.
                const lowestTopScore = currentTopScores.length > 0 ? (Number(currentTopScores[currentTopScores.length - 1].score) || 0) : 0;

                // Determines if the new score is high enough or if the list isn't full.
                const isHighScore = scoreToSave > lowestTopScore || currentTopScores.length < MAX_HIGH_SCORES;

                if (isHighScore) {
                    console.log(`New high score! Saving ${nameToSave}: ${scoreToSave}`);
                    // Adds the new high score document to Firestore.
                    await highScoresCollection.add({
                        name: nameToSave,
                        score: scoreToSave,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp() // Records server time
                    });
                    console.log("New score added to Firestore.");

                    // --- Pruning Logic: Keep only the top MAX_HIGH_SCORES ---
                    // Fetches all scores again to check if pruning is needed.
                    const allScoresSnapshot = await highScoresCollection
                        .orderBy('score', 'desc')
                        .get();

                    // If the list size exceeds the maximum, remove the lowest score(s).
                    if (allScoresSnapshot.size > MAX_HIGH_SCORES) {
                        const scoresToDelete = allScoresSnapshot.docs.slice(MAX_HIGH_SCORES);
                        const batch = db.batch(); // Uses a batch for efficient deletion.
                        scoresToDelete.forEach(doc => {
                            console.log(`Pruning score ${doc.data().score} (ID: ${doc.id})`);
                            batch.delete(doc.ref);
                        });
                        await batch.commit(); // Executes the batch delete.
                        console.log(`${scoresToDelete.length} lowest score(s) pruned.`);
                    }
                } else {
                    console.log("Score is not high enough to make the leaderboard.");
                }
            } catch (error) {
                // Logs errors during the save/prune process.
                console.error("Error saving high score: ", error);
            }
        }

        // --- UI State Management ---

        /**
         * Shows a specific overlay menu (Main Menu, Scoreboard, Game Over)
         * and hides the others, including the in-game score display.
         * @param {HTMLElement | null} overlayElement - The overlay element to show, or null to hide all.
         */
        function showOverlay(overlayElement) {
            // Hides all overlays and the in-game score display.
            mainMenuElement.classList.add('hidden');
            scoreboardScreenElement.classList.add('hidden');
            gameOverElement.classList.add('hidden');
            infoElement.classList.add('hidden');

            // Shows the specified overlay if one is provided.
            if (overlayElement) {
                overlayElement.classList.remove('hidden');
            }
        }

        // --- Character Selection Logic ---

        /**
         * Updates the selected character index and reflects the change in the UI.
         * @param {number} index - The index of the character selected in the CHARACTERS array.
         */
        function selectCharacter(index) {
            // Updates the global index and calls the UI update function.
            if (index >= 0 && index < CHARACTERS.length) {
                selectedCharacterIndex = index;
                updateCharacterButtonSelection();
                console.log(`Selected character: ${CHARACTERS[selectedCharacterIndex].name}`);
            }
        }

        /**
         * Updates the visual style ('selected' class) of character buttons
         * based on the currently selectedCharacterIndex.
         */
        function updateCharacterButtonSelection() {
            // Iterates through character buttons, adding/removing the 'selected' class.
            const buttons = characterButtonsElement.querySelectorAll('.char-button');
            buttons.forEach((button, index) => {
                if (index === selectedCharacterIndex) {
                    button.classList.add('selected');
                } else {
                    button.classList.remove('selected');
                }
            });
        }

        /**
         * Populates the character selection area in the main menu
         * with buttons for each defined character.
         */
        function populateCharacterSelection() {
            // Clears existing buttons and creates new ones for each character.
            characterButtonsElement.innerHTML = '';
            CHARACTERS.forEach((char, index) => {
                const button = document.createElement('button');
                button.classList.add('char-button');
                button.textContent = char.name;
                button.addEventListener('click', () => selectCharacter(index)); // Adds click listener
                characterButtonsElement.appendChild(button);
            });
            updateCharacterButtonSelection(); // Sets the initial visual selection.
        }

        // --- Preloading Assets ---

        /**
         * Loads character and obstacle image textures asynchronously.
         * Stores loaded textures in caches (characterTextures, obstacleTextures).
         * Uses Promises to track loading progress.
         */
        function preloadAssets() {
            const promises = [];

            // Preload Character Textures
            // Iterates through characters and loads their images if defined.
            CHARACTERS.forEach(char => {
                if (char.imageUrl) {
                    const promise = new Promise((resolve) => { // Removed reject for simplicity
                        textureLoader.load(
                            char.imageUrl,
                            (texture) => {
                                characterTextures[char.name] = texture; // Caches texture on success.
                                console.log(`Loaded character texture: ${char.imageUrl}`);
                                resolve();
                            },
                            undefined, // Progress callback (unused)
                            (error) => {
                                console.error(`Failed to load character texture: ${char.imageUrl}`, error);
                                resolve(); // Resolves even on error to prevent blocking.
                            }
                        );
                    });
                    promises.push(promise);
                }
            });

            // Preload Obstacle Textures
            // Iterates through obstacle image definitions and loads them if not already cached.
            Object.values(OBSTACLE_IMAGES).forEach(imageSet => {
                Object.values(imageSet).forEach(imageUrl => {
                     if (imageUrl && !obstacleTextures[imageUrl]) { // Avoids reloading.
                        const promise = new Promise((resolve) => { // Removed reject
                            textureLoader.load(
                                imageUrl,
                                (texture) => {
                                    obstacleTextures[imageUrl] = texture; // Caches texture.
                                    console.log(`Loaded obstacle texture: ${imageUrl}`);
                                    resolve();
                                },
                                undefined,
                                (error) => {
                                    console.error(`Failed to load obstacle texture: ${imageUrl}`, error);
                                    resolve(); // Resolves even on error.
                                }
                            );
                        });
                        promises.push(promise);
                    }
                });
            });

            // Returns a promise that resolves when all loading attempts are complete.
            return Promise.all(promises);
        }


        // --- Game Initialization ---

        /**
         * Sets up the initial game scene, camera, renderer, lights,
         * player, initial lanes, event listeners, and UI elements.
         * Calls the main game loop to start.
         */
        async function init() {
            console.log("Initializing game...");

            // --- Get DOM Element References ---
            // Caches references to frequently used UI elements.
            infoElement = document.getElementById('info');
            mainMenuElement = document.getElementById('mainMenu');
            scoreboardScreenElement = document.getElementById('scoreboardScreen');
            gameOverElement = document.getElementById('gameOver');
            characterButtonsElement = document.getElementById('characterButtons');
            startGameButton = document.getElementById('startGameButton');
            viewScoresButton = document.getElementById('viewScoresButton');
            backToMenuButton = document.getElementById('backToMenuButton');
            scoreListElement = document.getElementById('scoreList');
            noScoresMessageElement = document.getElementById('noScoresMessage');
            finalScoreElement = document.getElementById('finalScore');
            gameOverReasonElement = document.getElementById('gameOverReason');

            // --- Basic Scene Setup ---
            // Creates the main Three.js scene with background color and fog.
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 30, 60);

            // --- Camera Setup ---
            // Creates a perspective camera and positions it overlooking the start area.
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 15, 12);
            camera.lookAt(0, 0, 0);

            // --- Renderer Setup ---
            // Creates the WebGL renderer, enables shadows, and adds its canvas to the page.
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // --- Lighting Setup ---
            // Adds ambient light for overall illumination and a directional light for shadows.
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 15, 10);
            directionalLight.castShadow = true;
            // Configures shadow map properties.
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            // Optional helpers for debugging light/shadow positions (commented out).
            // const lightHelper = new THREE.DirectionalLightHelper(directionalLight, 5); scene.add(lightHelper);
            // const shadowCameraHelper = new THREE.CameraHelper(directionalLight.shadow.camera); scene.add(shadowCameraHelper);


            // --- Material Caching ---
            // Creates and caches materials for different lane types using procedural textures.
            laneMaterials[LANE_TYPES.CARPET] = new THREE.MeshLambertMaterial({
                map: createNoiseTexture(64, 64, '#A0522D', '#8B4513'), side: THREE.DoubleSide });
            laneMaterials[LANE_TYPES.CARPET].map.repeat.set(laneWidth / 4, laneLength / 4);

            laneMaterials[LANE_TYPES.WALKWAY] = new THREE.MeshLambertMaterial({
                map: createTileTexture(128, 128, '#D3D3D3', '#A9A9A9', 32), side: THREE.DoubleSide });
            laneMaterials[LANE_TYPES.WALKWAY].map.repeat.set(laneWidth / 8, laneLength / 8);

            laneMaterials[LANE_TYPES.WATER] = new THREE.MeshPhongMaterial({
                color: WATER_COLOR, transparent: true, opacity: 0.8, shininess: 80, side: THREE.DoubleSide });

            // Caches materials for walls and scenery elements.
            wallMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
            sceneryMaterials.desk = new THREE.MeshLambertMaterial({ color: SCENERY_COLORS.DESK });
            sceneryMaterials.plantPot = new THREE.MeshLambertMaterial({ color: SCENERY_COLORS.PLANT_POT });
            sceneryMaterials.plantLeaf = new THREE.MeshLambertMaterial({ color: SCENERY_COLORS.PLANT_LEAF });


            // --- Preload Assets ---
            // Disables start button, awaits asset loading, then re-enables button.
            console.log("Starting asset preloading...");
            startGameButton.disabled = true;
            startGameButton.textContent = "Loading Assets...";
            await preloadAssets();
            console.log("Asset preloading finished.");
            startGameButton.disabled = false;
            startGameButton.textContent = "Start Game";


            // --- Player Setup ---
            // Creates the initial player object based on the default selected character.
            createPlayer();

            // --- Initial Lane Generation ---
            // Creates the starting lane and a few initial random lanes.
            createLane(LANE_TYPES.CARPET, 0);
            for (let i = 1; i < generationDistance / 2; i++) {
                generateRandomLane();
            }

            // --- Wall Generation ---
            // Creates the initial side walls.
            createWalls();

            // --- Populate UI ---
            // Fills the character selection area with buttons.
            populateCharacterSelection();

            // --- Event Listeners ---
            // Sets up listeners for window resize and keyboard input.
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', handleInput);

            // Sets up listeners for UI buttons.
            startGameButton.addEventListener('click', startGame);
            viewScoresButton.addEventListener('click', showScoreboard);
            backToMenuButton.addEventListener('click', goToMenu);

            // --- Initial State ---
            // Sets the initial game state to the main menu.
            goToMenu();

            // --- Start Game Loop ---
            // Waits for the window to fully load before starting the animation loop.
            // This helps ensure textures and other resources are ready.
            window.onload = () => {
                console.log("Window loaded, starting animation loop.");
                if (!animationFrameId) { // Prevents starting multiple loops.
                    animate();
                }
            };
        }


        // --- Player Creation ---

        /**
         * Creates the player object (a plane with a character texture or a default cube).
         * Sets its initial position and adds it to the scene.
         * Creates a bounding box for collision detection.
         */
        function createPlayer() {
            // Removes the previous player mesh if one exists (e.g., on game restart).
            if (player) scene.remove(player);
            if (playerBoundingBox) scene.remove(playerBoundingBox); // Also remove old bounding box

            // Gets the selected character data and its preloaded texture.
            const character = CHARACTERS[selectedCharacterIndex];
            const playerTexture = characterTextures[character.name];

            let playerGeometry, playerMaterial;

            // Creates a plane with the character texture if available and loaded.
            if (playerTexture) {
                playerGeometry = new THREE.PlaneGeometry(character.width, character.height);
                playerMaterial = new THREE.MeshLambertMaterial({
                    map: playerTexture,
                    transparent: true, // Needed for PNG transparency
                    side: THREE.DoubleSide, // Render both sides of the plane
                    alphaTest: 0.1 // Avoid rendering nearly transparent pixels
                });
            } else {
                // Creates a fallback cube if the texture is missing or failed to load.
                console.warn(`Texture for ${character.name} not found or failed to load. Using default cube.`);
                playerGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
                playerMaterial = new THREE.MeshLambertMaterial({ color: DEFAULT_PLAYER_COLOR });
            }

            // Creates the player mesh, positions it, enables shadows, and adds it to the scene.
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(0, character.height / 2, 0); // Position based on height
            player.rotation.x = 0; // Keep plane upright
            player.castShadow = true;
            player.receiveShadow = false;
            scene.add(player);

            // --- Player Bounding Box ---
            // Creates an invisible box mesh used for collision detection.
            const bboxSize = 1.5; // Size of the collision box
            const bboxGeometry = new THREE.BoxGeometry(bboxSize, bboxSize, bboxSize);
            const bboxMaterial = new THREE.MeshBasicMaterial({ wireframe: true, visible: false }); // Invisible normally
            playerBoundingBox = new THREE.Mesh(bboxGeometry, bboxMaterial);
            playerBoundingBox.position.copy(player.position); // Matches player position
            scene.add(playerBoundingBox);

            // Resets logical and target positions for the new player.
            playerPosition = { x: 0, z: 0 };
            targetPlayerPosition = { x: player.position.x, z: player.position.z };
        }

        // --- Lane Generation ---

        /**
         * Creates a single lane of a specific type at a given Z position.
         * Adds the lane mesh to the scene and the lanes array.
         * @param {string} type - The type of lane (LANE_TYPES.CARPET, LANE_TYPES.WALKWAY, LANE_TYPES.WATER).
         * @param {number} z - The Z position for the center of the lane.
         */
        function createLane(type, z) {
            // Creates the plane geometry and gets the cached material for the lane type.
            const laneGeometry = new THREE.PlaneGeometry(laneLength, laneWidth);
            const material = laneMaterials[type];

            // Creates the mesh, rotates it horizontally, positions it, enables shadow receiving.
            const laneMesh = new THREE.Mesh(laneGeometry, material);
            laneMesh.rotation.x = -Math.PI / 2;
            laneMesh.position.set(0, 0, z);
            laneMesh.receiveShadow = true;
            scene.add(laneMesh);

            // Creates a data object storing lane info and references to its contents.
            const laneData = {
                mesh: laneMesh,
                type: type,
                z: z,
                obstacles: [],
                scenery: [],
                safeSpots: []
            };
            lanes.push(laneData); // Adds the data to the global lanes array.

            // --- Add Obstacles, Scenery, or Safe Spots based on lane type ---
            // Calls appropriate functions to populate the lane based on its type.
            if (type === LANE_TYPES.WALKWAY) {
                addObstaclesToLane(laneData);
                addSceneryToLane(laneData, 'walkway');
            } else if (type === LANE_TYPES.CARPET) {
                addSceneryToLane(laneData, 'carpet');
            } else if (type === LANE_TYPES.WATER) {
                addSafeSpotsToLane(laneData);
            }

            lastLaneZ = z; // Updates the Z position of the most recently generated lane.
        }

        /**
         * Generates a new lane with a randomly chosen type, positioned after the last lane.
         */
        function generateRandomLane() {
            // Selects a random lane type and calculates the Z position for the next lane.
            const laneTypes = Object.values(LANE_TYPES);
            const randomType = laneTypes[Math.floor(Math.random() * laneTypes.length)];
            const nextZ = lastLaneZ - laneWidth;
            createLane(randomType, nextZ); // Creates the new lane.
        }

        // --- Obstacle, Scenery, and Safe Spot Generation ---

        /**
         * Adds obstacles (moving objects) to a walkway lane.
         * Randomly determines the number, type, speed, and direction of obstacles.
         * @param {object} laneData - The data object for the lane.
         */
        function addObstaclesToLane(laneData) {
            // Determines random number, speed, direction, and type of obstacles.
            const numObstacles = Math.floor(Math.random() * 3) + 1;
            const speed = (Math.random() * 2 + 1) * (Math.random() < 0.5 ? 1 : -1);
            const obstacleTypeKeys = Object.keys(OBSTACLE_TYPES);
            const randomObstacleTypeKey = obstacleTypeKeys[Math.floor(Math.random() * obstacleTypeKeys.length)];
            const obstacleTypeName = OBSTACLE_TYPES[randomObstacleTypeKey];

            // Gets the appropriate preloaded texture based on obstacle type and direction.
            const imageUrl = speed > 0 ? OBSTACLE_IMAGES[obstacleTypeName]?.right : OBSTACLE_IMAGES[obstacleTypeName]?.left;
            const texture = obstacleTextures[imageUrl];

            // Creates each obstacle.
            for (let i = 0; i < numObstacles; i++) {
                let obstacleMesh;
                const obstacleWidth = texture ? OBSTACLE_PLANE_WIDTH : 3;
                const obstacleHeight = texture ? OBSTACLE_PLANE_HEIGHT : 1;
                const obstacleDepth = texture ? 0.1 : 3;

                // Creates a plane with texture if available, otherwise a fallback colored box.
                if (texture) {
                    const geometry = new THREE.PlaneGeometry(obstacleWidth, obstacleHeight);
                    const material = new THREE.MeshLambertMaterial({
                        map: texture, transparent: true, alphaTest: 0.1, side: THREE.DoubleSide });
                    obstacleMesh = new THREE.Mesh(geometry, material);
                    obstacleMesh.position.y = obstacleHeight / 2;
                } else {
                    const geometry = new THREE.BoxGeometry(obstacleWidth, obstacleHeight, obstacleDepth);
                    const material = new THREE.MeshLambertMaterial({ color: DEFAULT_OBSTACLE_COLOR });
                    obstacleMesh = new THREE.Mesh(geometry, material);
                    obstacleMesh.position.y = obstacleHeight / 2;
                }

                // Positions the obstacle evenly spaced along the lane, sets Z, enables shadows.
                const initialX = (laneLength / (numObstacles + 1)) * (i + 1) - laneLength / 2;
                obstacleMesh.position.x = initialX * Math.sign(speed);
                obstacleMesh.position.z = laneData.z;
                obstacleMesh.castShadow = true;
                scene.add(obstacleMesh);

                // Stores obstacle data and links it to the lane and global obstacles array.
                const obstacleData = {
                    mesh: obstacleMesh, speed: speed, type: obstacleTypeName, laneZ: laneData.z,
                    width: obstacleWidth, height: obstacleHeight, depth: obstacleDepth
                };
                obstacles.push(obstacleData);
                laneData.obstacles.push(obstacleData);
            }
        }

        /**
         * Adds decorative scenery elements (desks, plants) to carpet or walkway lanes.
         * @param {object} laneData - The data object for the lane.
         * @param {string} context - 'carpet' or 'walkway' to vary scenery.
         */
        function addSceneryToLane(laneData, context) {
            // Randomly decides whether to add scenery and how many items.
            const numScenery = Math.random() < 0.6 ? Math.floor(Math.random() * 2) + 1 : 0;

            for (let i = 0; i < numScenery; i++) {
                let sceneryMesh;
                const sceneryType = Math.random() < 0.7 ? 'desk' : 'plant'; // More likely to be a desk

                // Creates either a desk (box) or a plant (cylinder pot + cone leaves).
                if (sceneryType === 'desk') {
                    const deskHeight = 1.5, deskWidth = 3, deskDepth = 1.5;
                    const geometry = new THREE.BoxGeometry(deskWidth, deskHeight, deskDepth);
                    sceneryMesh = new THREE.Mesh(geometry, sceneryMaterials.desk);
                    sceneryMesh.position.y = deskHeight / 2;
                } else { // Plant
                    const potHeight = 0.8, potRadius = 0.5, leafHeight = 1.2;
                    const potGeometry = new THREE.CylinderGeometry(potRadius * 0.8, potRadius, potHeight, 16);
                    const potMesh = new THREE.Mesh(potGeometry, sceneryMaterials.plantPot);
                    potMesh.position.y = potHeight / 2;
                    const leafGeometry = new THREE.ConeGeometry(potRadius * 1.2, leafHeight, 16);
                    const leafMesh = new THREE.Mesh(leafGeometry, sceneryMaterials.plantLeaf);
                    leafMesh.position.y = potHeight + leafHeight / 2;
                    sceneryMesh = new THREE.Group(); // Groups pot and leaves together.
                    sceneryMesh.add(potMesh);
                    sceneryMesh.add(leafMesh);
                    sceneryMesh.position.y = 0;
                }

                // Randomly positions the scenery near the edges of the lane.
                const xPos = (Math.random() * (laneLength * 0.8)) - (laneLength * 0.4);
                const zOffset = (laneWidth / 2) * (Math.random() < 0.5 ? 0.8 : -0.8);
                sceneryMesh.position.x = xPos;
                sceneryMesh.position.z = laneData.z + zOffset;
                sceneryMesh.castShadow = true;
                sceneryMesh.receiveShadow = true;
                scene.add(sceneryMesh);

                // Adds the scenery mesh to global and lane-specific arrays.
                scenery.push(sceneryMesh);
                laneData.scenery.push(sceneryMesh);
            }
        }

        /**
         * Adds safe spots (logs, platforms) to water lanes for the player to land on.
         * These move similarly to obstacles.
         * @param {object} laneData - The data object for the lane.
         */
        function addSafeSpotsToLane(laneData) {
            // Determines random number, speed, and direction for safe spots.
            const numSpots = Math.floor(Math.random() * 2) + 2;
            const speed = (Math.random() * 1.5 + 0.5) * (Math.random() < 0.5 ? 1 : -1);
            const spotWidth = 4, spotDepth = 1.5, spotHeight = 0.4;

            // Creates geometry and uses the cached material for safe spots.
            const geometry = new THREE.BoxGeometry(spotWidth, spotHeight, spotDepth);
            const material = new THREE.MeshLambertMaterial({ color: SAFE_SPOT_COLOR });

            // Creates each safe spot.
            for (let i = 0; i < numSpots; i++) {
                const spotMesh = new THREE.Mesh(geometry, material);
                spotMesh.position.y = spotHeight / 2 - 0.05; // Position slightly above water level.

                // Positions the spot evenly spaced along the lane, sets Z, enables shadows.
                const initialX = (laneLength / (numSpots + 1)) * (i + 1) - laneLength / 2;
                spotMesh.position.x = initialX * Math.sign(speed);
                spotMesh.position.z = laneData.z;
                spotMesh.castShadow = true;
                spotMesh.receiveShadow = true;
                scene.add(spotMesh);

                // Stores safe spot data and links it to the lane and global safeSpots array.
                const spotData = {
                    mesh: spotMesh, speed: speed, laneZ: laneData.z,
                    width: spotWidth, depth: spotDepth
                };
                safeSpots.push(spotData);
                laneData.safeSpots.push(spotData);
            }
        }


        // --- Wall Generation ---

        /**
         * Creates the two long walls on either side of the playable lane area.
         */
        function createWalls() {
            // Removes existing walls before creating new ones (e.g., on restart).
            wallSegments.forEach(wall => scene.remove(wall));
            wallSegments = [];

            // Creates geometry and uses the cached material for walls.
            const wallGeometry = new THREE.BoxGeometry(WALL_THICKNESS, WALL_HEIGHT, laneLength);

            // Creates, positions, enables shadows, and adds the left wall.
            const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
            leftWall.position.set(-laneLength / 2 - WALL_THICKNESS / 2, WALL_HEIGHT / 2, -laneLength / 2 + laneWidth / 2);
            leftWall.castShadow = true;
            leftWall.receiveShadow = true;
            scene.add(leftWall);
            wallSegments.push(leftWall);

            // Creates, positions, enables shadows, and adds the right wall.
            const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
            rightWall.position.set(laneLength / 2 + WALL_THICKNESS / 2, WALL_HEIGHT / 2, -laneLength / 2 + laneWidth / 2);
            rightWall.castShadow = true;
            rightWall.receiveShadow = true;
            scene.add(rightWall);
            wallSegments.push(rightWall);
        }

        /**
         * Updates the position of the side walls as the player progresses.
         * This gives the illusion of infinite walls without actually creating infinite geometry.
         */
        function updateWalls() {
            // Calculates the center Z position for the walls based on the player's current Z.
            const centerZ = player.position.z - laneLength / 2 + laneWidth / 2;
            // Updates the Z position of both wall segments.
            wallSegments.forEach(wall => {
                wall.position.z = centerZ;
            });
        }


        // --- Game Loop and Updates ---

        /**
         * The main game loop, called repeatedly using requestAnimationFrame.
         * Updates game logic (movement, collisions), renders the scene.
         */
        function animate() {
            // Schedules the next frame call.
            animationFrameId = requestAnimationFrame(animate);

            // Gets the time elapsed since the last frame for smooth animations.
            const deltaTime = clock.getDelta();

            // Only performs game logic updates if the game is in the PLAYING state.
            if (currentGameState === GAME_STATE.PLAYING) {
                updatePlayerMovement(deltaTime); // Handles player visual movement and riding safe spots.
                updateObstacles(deltaTime);     // Moves obstacles and safe spots, handles wrapping.
                updateCamera();                 // Makes the camera follow the player.
                updateWalls();                  // Adjusts wall positions to follow the player.
                checkCollisions();              // Checks for player collisions.
                checkIdleTime();                // Checks if the player has been inactive too long.
                manageLanes();                  // Generates new lanes and removes old ones.
                updateScore();                  // Updates the displayed score.
            }

            // Renders the scene from the camera's perspective.
            renderer.render(scene, camera);
        }

        /**
         * Updates the position of obstacles and safe spots based on their speed.
         * Wraps them around the edges of the lane length.
         * @param {number} deltaTime - Time elapsed since the last frame.
         */
        function updateObstacles(deltaTime) {
            // Update Obstacles: Moves each obstacle and wraps it if it goes off-screen.
            obstacles.forEach(obstacle => {
                obstacle.mesh.position.x += obstacle.speed * deltaTime;
                const halfLane = laneLength / 2 + obstacle.width / 2;
                if (obstacle.speed > 0 && obstacle.mesh.position.x > halfLane) {
                    obstacle.mesh.position.x = -halfLane;
                } else if (obstacle.speed < 0 && obstacle.mesh.position.x < -halfLane) {
                    obstacle.mesh.position.x = halfLane;
                }
            });

            // Update Safe Spots: Moves each safe spot and wraps it similarly.
            safeSpots.forEach(spot => {
                spot.mesh.position.x += spot.speed * deltaTime;
                const halfLane = laneLength / 2 + spot.width / 2;
                if (spot.speed > 0 && spot.mesh.position.x > halfLane) {
                    spot.mesh.position.x = -halfLane;
                } else if (spot.speed < 0 && spot.mesh.position.x < -halfLane) {
                    spot.mesh.position.x = halfLane;
                }
            });
        }

        /**
         * Smoothly interpolates the player's visual position towards the target position.
         * Also handles the player "riding" on moving safe spots.
         * @param {number} deltaTime - Time elapsed since the last frame.
         */
        function updatePlayerMovement(deltaTime) {
            // Handles smooth animation during player hops (triggered by input).
            if (isMoving) {
                const elapsedTime = clock.elapsedTime * 1000 - moveStartTime;
                const moveProgress = Math.min(elapsedTime / moveDuration, 1);

                // Interpolates visual position towards the target.
                player.position.x = THREE.MathUtils.lerp(player.position.x, targetPlayerPosition.x, 0.2);
                player.position.z = THREE.MathUtils.lerp(player.position.z, targetPlayerPosition.z, 0.2);
                playerBoundingBox.position.copy(player.position); // Moves collision box too.

                // Snaps to final position when animation is complete.
                if (moveProgress >= 1) {
                    isMoving = false;
                    player.position.set(targetPlayerPosition.x, player.position.y, targetPlayerPosition.z);
                    playerBoundingBox.position.copy(player.position);
                }
            } else {
                // Ensures visual position matches target if not currently hopping.
                 player.position.x = targetPlayerPosition.x;
                 player.position.z = targetPlayerPosition.z;
                 playerBoundingBox.position.copy(player.position);
            }

             // --- Riding Safe Spots ---
             // Finds the lane the player is currently on.
             const currentLane = lanes.find(lane => Math.abs(lane.z - playerPosition.z) < laneWidth / 2);
             // If on a water lane, checks if the player is on a safe spot.
             if (currentLane && currentLane.type === LANE_TYPES.WATER) {
                 let onSafeSpot = false;
                 for (const spot of currentLane.safeSpots) {
                     // Checks for overlap between player's X position and the spot's width.
                     if (Math.abs(player.position.x - spot.mesh.position.x) < spot.width / 2) {
                         onSafeSpot = true;
                         // If on a spot and not currently hopping, move the player with the spot.
                         if (!isMoving) {
                             const deltaX = spot.speed * deltaTime;
                             targetPlayerPosition.x += deltaX; // Update target position
                             player.position.x += deltaX;      // Update visual position directly
                             playerBoundingBox.position.x += deltaX; // Update collision box

                             // Clamps player position to prevent being pushed off the edges by spots.
                             const halfPlayableWidth = laneLength / 2 - 1;
                             targetPlayerPosition.x = Math.max(-halfPlayableWidth, Math.min(halfPlayableWidth, targetPlayerPosition.x));
                             player.position.x = targetPlayerPosition.x;
                             playerBoundingBox.position.x = targetPlayerPosition.x;
                         }
                         break; // Player found on a spot, no need to check others.
                     }
                 }
             }
        }


        /**
         * Updates the camera position to follow the player smoothly.
         */
        function updateCamera() {
            // Calculates the target Z position for the camera, maintaining distance.
            const targetCameraZ = player.position.z + 12;
            // Smoothly interpolates the camera's Z position towards the target.
            camera.position.z = THREE.MathUtils.lerp(camera.position.z, targetCameraZ, 0.05);

            // Makes the camera look slightly ahead of the player.
            camera.lookAt(player.position.x, player.position.y, player.position.z - 5);

            // Updates the directional light's target to follow the player for correct shadows.
            directionalLight.target = player;
            directionalLight.target.updateMatrixWorld(); // Important for light target updates
        }

        /**
         * Updates the score display on the screen based on forward progress.
         */
        function updateScore() {
            // Calculates score based on how many lanes forward (negative Z) the player has moved.
            const currentMaxZ = -playerPosition.z / laneWidth;
            score = Math.max(score, Math.floor(currentMaxZ)); // Score only increases
            infoElement.textContent = `Score: ${score}`; // Updates the HTML element.
        }

        /**
         * Checks if the player has been idle (not moved) for too long.
         * If idle time exceeds MAX_IDLE_TIME, triggers game over.
         */
        function checkIdleTime() {
            // Compares current elapsed time with the time of the last move.
            const currentTime = clock.getElapsedTime();
            if (currentTime - lastMoveTime > MAX_IDLE_TIME) {
                console.log("Player idle too long!");
                gameOver("Idle for too long!"); // Triggers game over with specific reason.
            }
        }

        // --- Collision Detection ---

        /**
         * Checks for collisions between the player and obstacles or water.
         * Triggers game over if a collision occurs.
         */
        function checkCollisions() {
            // Skips collision checks if the player is currently hopping.
            if (isMoving) return;

            // Gets the player's current bounding box in world coordinates.
            const playerBox = new THREE.Box3().setFromObject(playerBoundingBox);

            // 1. Check Obstacle Collisions
            // Iterates through active obstacles.
            for (const obstacle of obstacles) {
                // Broad phase: Only checks obstacles on the same or adjacent lanes for efficiency.
                if (Math.abs(obstacle.laneZ - playerPosition.z) <= laneWidth) {
                    // Narrow phase: Gets the obstacle's bounding box and checks for intersection.
                    const obstacleBox = new THREE.Box3().setFromObject(obstacle.mesh);
                    if (playerBox.intersectsBox(obstacleBox)) {
                        console.log("Collision with obstacle!");
                        gameOver(`Hit by ${obstacle.type}!`); // Triggers game over.
                        return; // Exits check early.
                    }
                }
            }

            // 2. Check Water Collision
            // Finds the lane the player is currently on.
            const currentLane = lanes.find(lane => Math.abs(lane.z - playerPosition.z) < laneWidth / 2);
            // If it's a water lane, checks if the player is on a safe spot.
            if (currentLane && currentLane.type === LANE_TYPES.WATER) {
                let onSafeSpot = false;
                for (const spot of currentLane.safeSpots) {
                    // Checks for overlap on X and Z axes between player and safe spot.
                    if (Math.abs(player.position.x - spot.mesh.position.x) < spot.width / 2 &&
                        Math.abs(player.position.z - spot.mesh.position.z) < spot.depth / 2) { // Added Z check for robustness
                        onSafeSpot = true;
                        break; // Player is safe.
                    }
                }
                // If not on a safe spot while on a water lane, it's game over.
                if (!onSafeSpot) {
                    console.log("Fell in the water!");
                    gameOver("Fell into the water!");
                    return; // Exits check early.
                }
            }

            // 3. Check Out-of-Bounds (X-axis)
            // Checks if the player has moved beyond the playable width.
            const halfPlayableWidth = laneLength / 2;
             if (player.position.x < -halfPlayableWidth || player.position.x > halfPlayableWidth) {
                 console.log("Player went out of bounds!");
                 gameOver("Went out of bounds!");
                 return; // Exits check early.
             }
        }


        // --- Lane Management ---

        /**
         * Manages the generation of new lanes ahead of the player
         * and the removal of old lanes behind the player.
         */
        function manageLanes() {
            // --- Generate New Lanes ---
            // Checks if the player is getting close to the furthest generated lane.
            if (lastLaneZ > player.position.z - generationDistance * laneWidth) {
                generateRandomLane(); // Generates a new lane ahead.
            }

            // --- Clean Up Old Lanes ---
            // Calculates the Z threshold behind the player for cleanup.
            const cleanupThresholdZ = player.position.z + cleanupBuffer * laneWidth;
            // Iterates backwards through the lanes array.
            for (let i = lanes.length - 1; i >= 0; i--) {
                const lane = lanes[i];
                // If a lane is beyond the cleanup threshold:
                if (lane.z > cleanupThresholdZ) {
                    // Removes the lane mesh from the scene.
                    scene.remove(lane.mesh);

                    // Removes associated obstacles from the scene and the global obstacles array.
                    lane.obstacles.forEach(obstacleData => {
                        scene.remove(obstacleData.mesh);
                        const index = obstacles.indexOf(obstacleData);
                        if (index > -1) obstacles.splice(index, 1);
                    });

                    // Removes associated scenery from the scene and the global scenery array.
                    lane.scenery.forEach(sceneryMesh => {
                        scene.remove(sceneryMesh);
                        const index = scenery.indexOf(sceneryMesh);
                        if (index > -1) scenery.splice(index, 1);
                    });

                    // Removes associated safe spots from the scene and the global safeSpots array.
                    lane.safeSpots.forEach(spotData => {
                        scene.remove(spotData.mesh);
                        const index = safeSpots.indexOf(spotData);
                        if (index > -1) safeSpots.splice(index, 1);
                    });

                    // Removes the lane data object from the lanes array.
                    lanes.splice(i, 1);
                    // console.log("Cleaned up lane at Z:", lane.z); // Optional log
                }
            }
        }

        // --- Input Handling ---

        /**
         * Handles keyboard input for player movement.
         * Updates the target position and initiates the move animation.
         * @param {Event} event - The keydown event object.
         */
        function handleInput(event) {
            // Ignores input if not in PLAYING state or if player is already moving.
            if (currentGameState !== GAME_STATE.PLAYING || isMoving) {
                return;
            }

            let moved = false; // Flag to track if a valid move key was pressed.
            let targetX = targetPlayerPosition.x; // Start with current target position.
            let targetZ = targetPlayerPosition.z;
            const moveStep = laneWidth; // Distance for forward/backward moves.
            const sideStep = laneWidth / 2; // Distance for left/right moves.

            // Determines the intended move based on the key pressed.
            switch (event.key) {
                case 'ArrowUp': case 'w': case 'W':
                    targetZ -= moveStep;
                    playerPosition.z -= moveStep; // Update logical Z immediately for score/lane checks.
                    moved = true;
                    break;
                case 'ArrowDown': case 's': case 'S':
                    // Allows moving back only if not at the starting line (or behind).
                    if (playerPosition.z < 0) {
                        targetZ += moveStep;
                        playerPosition.z += moveStep;
                        moved = true;
                    }
                    break;
                case 'ArrowLeft': case 'a': case 'A':
                    targetX -= sideStep;
                    moved = true;
                    break;
                case 'ArrowRight': case 'd': case 'D':
                    targetX += sideStep;
                    moved = true;
                    break;
            }

            // If a valid move key was pressed:
            if (moved) {
                 // --- Boundary Check (X-axis) ---
                 // Clamps the target X position within the playable lane width.
                 const halfPlayableWidth = laneLength / 2 - 1; // Slightly inside walls
                 targetX = Math.max(-halfPlayableWidth, Math.min(halfPlayableWidth, targetX));

                // Sets the new target position for the animation.
                targetPlayerPosition.x = targetX;
                targetPlayerPosition.z = targetZ;
                // Starts the movement animation state.
                isMoving = true;
                moveStartTime = clock.elapsedTime * 1000; // Records animation start time.
                lastMoveTime = clock.getElapsedTime(); // Updates time for idle check.

                // Updates logical X position after clamping.
                playerPosition.x = targetX;
            }
        }

        // --- Game State Management ---

        /**
         * Starts the game: resets state, hides menus, shows game UI, resets player and world.
         */
        function startGame() {
            console.log("Starting game...");
            // Sets game state and updates UI visibility.
            currentGameState = GAME_STATE.PLAYING;
            showOverlay(null);
            infoElement.classList.remove('hidden');

            // Resets score and idle timer.
            score = 0;
            lastMoveTime = clock.getElapsedTime();

            // Clears existing game world elements (lanes, obstacles, scenery, spots, walls).
            lanes.forEach(lane => {
                 scene.remove(lane.mesh);
                 lane.obstacles.forEach(o => scene.remove(o.mesh));
                 lane.scenery.forEach(s => scene.remove(s));
                 lane.safeSpots.forEach(sp => scene.remove(sp.mesh));
            });
            lanes = [];
            obstacles = [];
            scenery = [];
            safeSpots = [];
            wallSegments.forEach(w => scene.remove(w));
            wallSegments = [];

            // Resets player position and mesh (using the currently selected character).
            createPlayer();
            targetPlayerPosition = { x: 0, z: 0 };
            playerPosition = { x: 0, z: 0 };
            // Ensure initial visual position matches logical position
            player.position.set(targetPlayerPosition.x, CHARACTERS[selectedCharacterIndex].height / 2, targetPlayerPosition.z);
            playerBoundingBox.position.copy(player.position);


            // Generates the initial set of lanes and walls.
            lastLaneZ = 0;
            createLane(LANE_TYPES.CARPET, 0);
            for (let i = 1; i < generationDistance / 2; i++) {
                generateRandomLane();
            }
            createWalls();

            // Resets camera to starting view.
            camera.position.set(0, 15, 12);
            camera.lookAt(0, 0, 0);

             // Ensures the animation loop is running if it was stopped.
             if (!animationFrameId) {
                animate();
             }
        }

        /**
         * Shows the high score screen. Fetches scores from Firebase.
         */
        function showScoreboard() {
            console.log("Showing scoreboard...");
            // Sets game state and shows the scoreboard overlay.
            currentGameState = GAME_STATE.SHOW_SCORES;
            showOverlay(scoreboardScreenElement);
            // Fetches and displays scores when the scoreboard is shown.
            fetchAndDisplayHighScores();
        }

        /**
         * Handles the game over state.
         * Stops player input, shows the game over screen, displays final score,
         * and attempts to save the score to Firebase.
         * @param {string} reason - The reason for the game over (e.g., "Hit by obstacle").
         */
        function gameOver(reason = "Unknown cause") {
            // Prevents triggering game over multiple times.
            if (currentGameState === GAME_STATE.GAME_OVER) return;

            console.log(`Game Over: ${reason}`);
            // Sets game state.
            currentGameState = GAME_STATE.GAME_OVER;

            // Updates and shows the game over overlay with score and reason.
            finalScoreElement.textContent = score;
            gameOverReasonElement.textContent = reason;
            showOverlay(gameOverElement);

            // --- Attempt to save score to Firebase ---
            // Gets the current character's name.
            const characterName = CHARACTERS[selectedCharacterIndex].name;
            // Calls the save function only if Firestore is available.
            if (highScoresCollection) {
                 saveScoreIfHighScore(characterName, score);
            } else {
                console.warn("Cannot save score, Firestore not available.");
            }
        }

        /**
         * Returns the game to the main menu state.
         */
        function goToMenu() {
            console.log("Returning to main menu...");
            // Sets game state and shows the main menu overlay.
            currentGameState = GAME_STATE.MENU;
            showOverlay(mainMenuElement);
            // Optional: Reset camera to a fixed menu view.
             // camera.position.set(0, 15, 12);
             // camera.lookAt(0, 0, 0);
        }

        // --- Window Resize Handler ---

        /**
         * Updates camera aspect ratio and renderer size when the window is resized.
         */
        function onWindowResize() {
            // Updates camera aspect ratio based on new window dimensions.
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix(); // Applies the aspect ratio change.
            // Resizes the renderer's canvas to fit the new window size.
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Start the application ---
        // Uses DOMContentLoaded to ensure the HTML structure is ready before running the init script.
        document.addEventListener('DOMContentLoaded', (event) => {
            console.log("DOM fully loaded and parsed. Initializing game setup.");
            init(); // Initializes the game setup (scene, camera, UI, etc.).
                    // The actual game loop (animate) is started via window.onload inside init().
        });

    </script>
</body>
</html>
